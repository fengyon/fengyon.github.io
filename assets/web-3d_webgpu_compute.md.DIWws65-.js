import{_ as a,c as n,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const F=JSON.parse('{"title":"WebGPU 计算","description":"","frontmatter":{},"headers":[{"level":2,"title":"计算管线概述","slug":"计算管线概述","link":"#计算管线概述","children":[]},{"level":2,"title":"计算着色器基础","slug":"计算着色器基础","link":"#计算着色器基础","children":[{"level":3,"title":"基本计算着色器结构","slug":"基本计算着色器结构","link":"#基本计算着色器结构","children":[]},{"level":3,"title":"内置变量","slug":"内置变量","link":"#内置变量","children":[]}]},{"level":2,"title":"工作组与执行模型","slug":"工作组与执行模型","link":"#工作组与执行模型","children":[{"level":3,"title":"执行层次结构","slug":"执行层次结构","link":"#执行层次结构","children":[]},{"level":3,"title":"工作组大小优化","slug":"工作组大小优化","link":"#工作组大小优化","children":[]}]},{"level":2,"title":"存储资源绑定","slug":"存储资源绑定","link":"#存储资源绑定","children":[{"level":3,"title":"存储缓冲区","slug":"存储缓冲区","link":"#存储缓冲区","children":[]},{"level":3,"title":"存储纹理","slug":"存储纹理","link":"#存储纹理","children":[]}]},{"level":2,"title":"计算管道创建","slug":"计算管道创建","link":"#计算管道创建","children":[{"level":3,"title":"管道设置","slug":"管道设置","link":"#管道设置","children":[]}]},{"level":2,"title":"计算通道编码","slug":"计算通道编码","link":"#计算通道编码","children":[{"level":3,"title":"计算通道设置","slug":"计算通道设置","link":"#计算通道设置","children":[]},{"level":3,"title":"工作组调度","slug":"工作组调度","link":"#工作组调度","children":[]}]},{"level":2,"title":"共享内存与同步","slug":"共享内存与同步","link":"#共享内存与同步","children":[{"level":3,"title":"工作组共享内存","slug":"工作组共享内存","link":"#工作组共享内存","children":[]},{"level":3,"title":"原子操作","slug":"原子操作","link":"#原子操作","children":[]}]},{"level":2,"title":"实用计算模式","slug":"实用计算模式","link":"#实用计算模式","children":[{"level":3,"title":"归约操作","slug":"归约操作","link":"#归约操作","children":[]},{"level":3,"title":"扫描操作","slug":"扫描操作","link":"#扫描操作","children":[]}]},{"level":2,"title":"性能优化技术","slug":"性能优化技术","link":"#性能优化技术","children":[{"level":3,"title":"内存访问模式","slug":"内存访问模式","link":"#内存访问模式","children":[]},{"level":3,"title":"占用率优化","slug":"占用率优化","link":"#占用率优化","children":[]},{"level":3,"title":"双缓冲技术","slug":"双缓冲技术","link":"#双缓冲技术","children":[]}]},{"level":2,"title":"实际应用案例","slug":"实际应用案例","link":"#实际应用案例","children":[{"level":3,"title":"物理模拟","slug":"物理模拟","link":"#物理模拟","children":[]},{"level":3,"title":"图像处理","slug":"图像处理","link":"#图像处理","children":[]}]},{"level":2,"title":"调试与性能分析","slug":"调试与性能分析","link":"#调试与性能分析","children":[{"level":3,"title":"调试技术","slug":"调试技术","link":"#调试技术","children":[]},{"level":3,"title":"性能测量","slug":"性能测量","link":"#性能测量","children":[]}]}],"relativePath":"web-3d/webgpu/compute.md","filePath":"web-3d/webgpu/compute.md"}'),o={name:"web-3d/webgpu/compute.md"};function e(c,s,t,r,E,y){return l(),n("div",null,[...s[0]||(s[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /web-3d/webgpu/compute.md for this page in Markdown format</div><h1 id="webgpu-计算" tabindex="-1">WebGPU 计算 <a class="header-anchor" href="#webgpu-计算" aria-label="Permalink to &quot;WebGPU 计算&quot;">​</a></h1><p>WebGPU 计算是现代 Web 图形编程的革命性特性，它将 GPU 的强大并行计算能力引入 Web 平台。与传统的图形渲染不同，计算管线专注于通用目的计算，能够在数千个线程上并行执行复杂算法，为机器学习、科学计算、物理模拟等领域开辟了新的可能性。</p><h2 id="计算管线概述" tabindex="-1">计算管线概述 <a class="header-anchor" href="#计算管线概述" aria-label="Permalink to &quot;计算管线概述&quot;">​</a></h2><p>WebGPU 计算管线是一种专门用于通用并行计算的管线类型，它不涉及图形渲染的任何阶段，而是直接在 GPU 上执行计算任务。计算管线使用计算着色器，这些着色器在三维网格的工作组中并行执行。</p><p><strong>计算管线架构</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>计算管线创建 → 资源绑定 → 工作组调度 → 并行执行 → 结果获取</span></span>
<span class="line"><span>     ↓            ↓          ↓           ↓         ↓</span></span>
<span class="line"><span> 着色器模块     缓冲区绑定  线程组织      GPU计算   数据读取</span></span></code></pre></div><p>与传统图形管线不同，计算管线没有固定的阶段流程，而是完全由开发者控制的计算内核。</p><h2 id="计算着色器基础" tabindex="-1">计算着色器基础 <a class="header-anchor" href="#计算着色器基础" aria-label="Permalink to &quot;计算着色器基础&quot;">​</a></h2><p>计算着色器是计算管线的核心，使用 WGSL 编写，通过 <code>@compute</code> 属性标识。每个计算着色器定义了一个在多个线程上并行执行的计算内核。</p><h3 id="基本计算着色器结构" tabindex="-1">基本计算着色器结构 <a class="header-anchor" href="#基本计算着色器结构" aria-label="Permalink to &quot;基本计算着色器结构&quot;">​</a></h3><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 简单的向量加法计算着色器</span></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">group</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">@</span><span style="color:#B392F0;">binding</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">storage</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">read</span><span style="color:#E1E4E8;">&gt; input_a: </span><span style="color:#F97583;">array</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">group</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">@</span><span style="color:#B392F0;">binding</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">storage</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">read</span><span style="color:#E1E4E8;">&gt; input_b: </span><span style="color:#F97583;">array</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">group</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">@</span><span style="color:#B392F0;">binding</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">storage</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">read_write</span><span style="color:#E1E4E8;">&gt; output: </span><span style="color:#F97583;">array</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#F97583;">    @</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(global_invocation_id) global_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> global_id</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">x;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 边界检查</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (index &lt; </span><span style="color:#B392F0;">arrayLength</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">output)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        output[index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> input_a[index] </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> input_b[index];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="内置变量" tabindex="-1">内置变量 <a class="header-anchor" href="#内置变量" aria-label="Permalink to &quot;内置变量&quot;">​</a></h3><p>计算着色器可以使用多种内置变量访问执行上下文：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>global_invocation_id: 全局调用ID (三维)</span></span>
<span class="line"><span>local_invocation_id:  工作组内调用ID  </span></span>
<span class="line"><span>workgroup_id:         工作组ID</span></span>
<span class="line"><span>num_workgroups:       调度的工作组数量</span></span></code></pre></div><h2 id="工作组与执行模型" tabindex="-1">工作组与执行模型 <a class="header-anchor" href="#工作组与执行模型" aria-label="Permalink to &quot;工作组与执行模型&quot;">​</a></h2><p>WebGPU 计算使用分层执行模型，将计算任务分解为工作组，每个工作组包含多个调用。</p><h3 id="执行层次结构" tabindex="-1">执行层次结构 <a class="header-anchor" href="#执行层次结构" aria-label="Permalink to &quot;执行层次结构&quot;">​</a></h3><p><strong>执行模型示意图</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>计算网格 (Compute Grid)</span></span>
<span class="line"><span>├── 工作组 X 维度</span></span>
<span class="line"><span>│   ├── 工作组 (0,0,0) → 64个调用</span></span>
<span class="line"><span>│   ├── 工作组 (1,0,0) → 64个调用</span></span>
<span class="line"><span>│   └── ...</span></span>
<span class="line"><span>├── 工作组 Y 维度</span></span>
<span class="line"><span>└── 工作组 Z 维度</span></span></code></pre></div><p>每个工作组内部的调用可以共享内存和同步，而不同工作组之间完全独立。</p><h3 id="工作组大小优化" tabindex="-1">工作组大小优化 <a class="header-anchor" href="#工作组大小优化" aria-label="Permalink to &quot;工作组大小优化&quot;">​</a></h3><p>工作组大小对性能有重大影响，需要根据硬件特性优化：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 优化的工作组大小示例</span></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span><span style="color:#6A737D;">  // 1D工作组，适合向量操作</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> compute_1d</span><span style="color:#E1E4E8;">() { </span><span style="color:#6A737D;">/* ... */</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span><span style="color:#6A737D;">   // 2D工作组，适合图像处理  </span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> compute_2d</span><span style="color:#E1E4E8;">() { </span><span style="color:#6A737D;">/* ... */</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">)</span><span style="color:#6A737D;">   // 3D工作组，适合体积计算</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> compute_3d</span><span style="color:#E1E4E8;">() { </span><span style="color:#6A737D;">/* ... */</span><span style="color:#E1E4E8;"> }</span></span></code></pre></div><h2 id="存储资源绑定" tabindex="-1">存储资源绑定 <a class="header-anchor" href="#存储资源绑定" aria-label="Permalink to &quot;存储资源绑定&quot;">​</a></h2><p>计算着色器通过存储缓冲区与存储纹理与外部数据交互，支持高效的读写操作。</p><h3 id="存储缓冲区" tabindex="-1">存储缓冲区 <a class="header-anchor" href="#存储缓冲区" aria-label="Permalink to &quot;存储缓冲区&quot;">​</a></h3><p>存储缓冲区提供对结构化数据的高效访问：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建存储缓冲区</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> storageBuffer</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createBuffer</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    size: bufferSize,</span></span>
<span class="line"><span style="color:#E1E4E8;">    usage: GPUBufferUsage.</span><span style="color:#79B8FF;">STORAGE</span><span style="color:#F97583;"> |</span><span style="color:#E1E4E8;"> GPUBufferUsage.</span><span style="color:#79B8FF;">COPY_SRC</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    mappedAtCreation: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在绑定组布局中定义存储缓冲区</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bindGroupLayout</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createBindGroupLayout</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    entries: [</span></span>
<span class="line"><span style="color:#E1E4E8;">        {</span></span>
<span class="line"><span style="color:#E1E4E8;">            binding: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            visibility: GPUShaderStage.</span><span style="color:#79B8FF;">COMPUTE</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            buffer: {</span></span>
<span class="line"><span style="color:#E1E4E8;">                type: </span><span style="color:#9ECBFF;">&quot;read-only-storage&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        },</span></span>
<span class="line"><span style="color:#E1E4E8;">        {</span></span>
<span class="line"><span style="color:#E1E4E8;">            binding: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span></span>
<span class="line"><span style="color:#E1E4E8;">            visibility: GPUShaderStage.</span><span style="color:#79B8FF;">COMPUTE</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            buffer: {</span></span>
<span class="line"><span style="color:#E1E4E8;">                type: </span><span style="color:#9ECBFF;">&quot;storage&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    ]</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h3 id="存储纹理" tabindex="-1">存储纹理 <a class="header-anchor" href="#存储纹理" aria-label="Permalink to &quot;存储纹理&quot;">​</a></h3><p>存储纹理允许计算着色器直接读写纹理数据：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">group</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">@</span><span style="color:#B392F0;">binding</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> output_image: texture_storage_2d&lt;rgba8unorm, </span><span style="color:#F97583;">write</span><span style="color:#E1E4E8;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> image_processing</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">@</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(global_invocation_id) global_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> coord </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> vec2</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">i32</span><span style="color:#E1E4E8;">&gt;(global_id</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">xy);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 直接写入纹理</span></span>
<span class="line"><span style="color:#B392F0;">    textureStore</span><span style="color:#E1E4E8;">(output_image, coord, </span><span style="color:#F97583;">vec4</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="计算管道创建" tabindex="-1">计算管道创建 <a class="header-anchor" href="#计算管道创建" aria-label="Permalink to &quot;计算管道创建&quot;">​</a></h2><p>计算管道的创建比渲染管道更简单，只需要计算着色器模块和管线布局。</p><h3 id="管道设置" tabindex="-1">管道设置 <a class="header-anchor" href="#管道设置" aria-label="Permalink to &quot;管道设置&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建计算管道</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> computePipeline</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createComputePipeline</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    layout: pipelineLayout,</span></span>
<span class="line"><span style="color:#E1E4E8;">    compute: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        module: computeShaderModule,</span></span>
<span class="line"><span style="color:#E1E4E8;">        entryPoint: </span><span style="color:#9ECBFF;">&#39;main&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 创建管线布局</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> pipelineLayout</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createPipelineLayout</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    bindGroupLayouts: [bindGroupLayout]</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 创建绑定组</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bindGroup</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createBindGroup</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    layout: bindGroupLayout,</span></span>
<span class="line"><span style="color:#E1E4E8;">    entries: [</span></span>
<span class="line"><span style="color:#E1E4E8;">        {</span></span>
<span class="line"><span style="color:#E1E4E8;">            binding: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            resource: { buffer: inputBuffer }</span></span>
<span class="line"><span style="color:#E1E4E8;">        },</span></span>
<span class="line"><span style="color:#E1E4E8;">        {</span></span>
<span class="line"><span style="color:#E1E4E8;">            binding: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            resource: { buffer: outputBuffer }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    ]</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h2 id="计算通道编码" tabindex="-1">计算通道编码 <a class="header-anchor" href="#计算通道编码" aria-label="Permalink to &quot;计算通道编码&quot;">​</a></h2><p>计算通道负责记录和执行计算命令，通过命令编码器管理。</p><h3 id="计算通道设置" tabindex="-1">计算通道设置 <a class="header-anchor" href="#计算通道设置" aria-label="Permalink to &quot;计算通道设置&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 开始计算通道</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> computePass</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> commandEncoder.</span><span style="color:#B392F0;">beginComputePass</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 设置管道和资源</span></span>
<span class="line"><span style="color:#E1E4E8;">computePass.</span><span style="color:#B392F0;">setPipeline</span><span style="color:#E1E4E8;">(computePipeline);</span></span>
<span class="line"><span style="color:#E1E4E8;">computePass.</span><span style="color:#B392F0;">setBindGroup</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, bindGroup);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 调度计算工作组</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> workgroupCountX</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">ceil</span><span style="color:#E1E4E8;">(dataSize </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 64</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">computePass.</span><span style="color:#B392F0;">dispatchWorkgroups</span><span style="color:#E1E4E8;">(workgroupCountX, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 结束计算通道</span></span>
<span class="line"><span style="color:#E1E4E8;">computePass.</span><span style="color:#B392F0;">end</span><span style="color:#E1E4E8;">();</span></span></code></pre></div><h3 id="工作组调度" tabindex="-1">工作组调度 <a class="header-anchor" href="#工作组调度" aria-label="Permalink to &quot;工作组调度&quot;">​</a></h3><p>工作组调度决定了计算任务的并行程度：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 1D 调度 - 适合向量操作</span></span>
<span class="line"><span style="color:#E1E4E8;">computePass.</span><span style="color:#B392F0;">dispatchWorkgroups</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    Math.</span><span style="color:#B392F0;">ceil</span><span style="color:#E1E4E8;">(arrayLength </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 64</span><span style="color:#E1E4E8;">),  </span><span style="color:#6A737D;">// X 维度</span></span>
<span class="line"><span style="color:#79B8FF;">    1</span><span style="color:#E1E4E8;">,                            </span><span style="color:#6A737D;">// Y 维度  </span></span>
<span class="line"><span style="color:#79B8FF;">    1</span><span style="color:#6A737D;">                             // Z 维度</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 2D 调度 - 适合图像处理</span></span>
<span class="line"><span style="color:#E1E4E8;">computePass.</span><span style="color:#B392F0;">dispatchWorkgroups</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    Math.</span><span style="color:#B392F0;">ceil</span><span style="color:#E1E4E8;">(imageWidth </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 8</span><span style="color:#E1E4E8;">),    </span><span style="color:#6A737D;">// X 维度</span></span>
<span class="line"><span style="color:#E1E4E8;">    Math.</span><span style="color:#B392F0;">ceil</span><span style="color:#E1E4E8;">(imageHeight </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 8</span><span style="color:#E1E4E8;">),   </span><span style="color:#6A737D;">// Y 维度</span></span>
<span class="line"><span style="color:#79B8FF;">    1</span><span style="color:#6A737D;">                             // Z 维度</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 3D 调度 - 适合体积计算</span></span>
<span class="line"><span style="color:#E1E4E8;">computePass.</span><span style="color:#B392F0;">dispatchWorkgroups</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    Math.</span><span style="color:#B392F0;">ceil</span><span style="color:#E1E4E8;">(volumeX </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 4</span><span style="color:#E1E4E8;">),       </span><span style="color:#6A737D;">// X 维度</span></span>
<span class="line"><span style="color:#E1E4E8;">    Math.</span><span style="color:#B392F0;">ceil</span><span style="color:#E1E4E8;">(volumeY </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 4</span><span style="color:#E1E4E8;">),       </span><span style="color:#6A737D;">// Y 维度</span></span>
<span class="line"><span style="color:#E1E4E8;">    Math.</span><span style="color:#B392F0;">ceil</span><span style="color:#E1E4E8;">(volumeZ </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 4</span><span style="color:#E1E4E8;">)        </span><span style="color:#6A737D;">// Z 维度</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre></div><h2 id="共享内存与同步" tabindex="-1">共享内存与同步 <a class="header-anchor" href="#共享内存与同步" aria-label="Permalink to &quot;共享内存与同步&quot;">​</a></h2><p>工作组内的调用可以通过共享内存进行高效通信，并使用屏障进行同步。</p><h3 id="工作组共享内存" tabindex="-1">工作组共享内存 <a class="header-anchor" href="#工作组共享内存" aria-label="Permalink to &quot;工作组共享内存&quot;">​</a></h3><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">workgroup</span><span style="color:#E1E4E8;">&gt; shared_data: </span><span style="color:#F97583;">array</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> parallel_reduction</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">@</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(local_invocation_id) local_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> local_index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> local_id</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">x;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 将数据加载到共享内存</span></span>
<span class="line"><span style="color:#E1E4E8;">    shared_data[local_index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> input_data[global_index];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 同步工作组内所有调用</span></span>
<span class="line"><span style="color:#B392F0;">    workgroupBarrier</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 现在可以安全地读取其他调用写入的共享数据</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (local_index &lt; </span><span style="color:#79B8FF;">32</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        shared_data[local_index] </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> shared_data[local_index </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 32</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#B392F0;">    workgroupBarrier</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 继续归约操作...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="原子操作" tabindex="-1">原子操作 <a class="header-anchor" href="#原子操作" aria-label="Permalink to &quot;原子操作&quot;">​</a></h3><p>WebGPU 支持原子操作，用于无锁的并行算法：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">group</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">@</span><span style="color:#B392F0;">binding</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">storage</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">read_write</span><span style="color:#E1E4E8;">&gt; atomic_counter: </span><span style="color:#F97583;">atomic</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> atomic_example</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">@</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(global_invocation_id) global_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 原子增加</span></span>
<span class="line"><span style="color:#B392F0;">    atomicAdd</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">atomic_counter, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 原子比较交换</span></span>
<span class="line"><span style="color:#F97583;">    var</span><span style="color:#E1E4E8;"> old_value </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> atomicLoad</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">atomic_counter);</span></span>
<span class="line"><span style="color:#F97583;">    while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">atomicCompareExchangeWeak</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">atomic_counter, old_value, old_value </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        old_value </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> atomicLoad</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">atomic_counter);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="实用计算模式" tabindex="-1">实用计算模式 <a class="header-anchor" href="#实用计算模式" aria-label="Permalink to &quot;实用计算模式&quot;">​</a></h2><h3 id="归约操作" tabindex="-1">归约操作 <a class="header-anchor" href="#归约操作" aria-label="Permalink to &quot;归约操作&quot;">​</a></h3><p>归约是将大量数据聚合为单个值的常见模式：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> reduction</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">@</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(local_invocation_id) local_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;,</span></span>
<span class="line"><span style="color:#F97583;">             @</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(workgroup_id) workgroup_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> local_index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> local_id</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">x;</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> workgroup_size </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 64u</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> global_index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workgroup_id</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">x </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> workgroup_size </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> local_index;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 加载数据到共享内存</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (global_index &lt; data_length) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        shared_data[local_index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> input_data[global_index];</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        shared_data[local_index] </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0.0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#B392F0;">    workgroupBarrier</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 并行归约</span></span>
<span class="line"><span style="color:#F97583;">    var</span><span style="color:#E1E4E8;"> offset </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workgroup_size </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">    while</span><span style="color:#E1E4E8;"> (offset &gt; </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (local_index &lt; offset) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            shared_data[local_index] </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> shared_data[local_index </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> offset];</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#B392F0;">        workgroupBarrier</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        offset </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> offset </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 工作组结果</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (local_index </span><span style="color:#F97583;">==</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        partial_sums[workgroup_id</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">x] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> shared_data[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="扫描操作" tabindex="-1">扫描操作 <a class="header-anchor" href="#扫描操作" aria-label="Permalink to &quot;扫描操作&quot;">​</a></h3><p>扫描 (前缀和) 是许多并行算法的基础：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> prefix_sum</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">@</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(local_invocation_id) local_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> local_index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> local_id</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">x;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 加载数据</span></span>
<span class="line"><span style="color:#E1E4E8;">    shared_data[local_index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> input_data[global_index];</span></span>
<span class="line"><span style="color:#B392F0;">    workgroupBarrier</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 工作组内前缀和</span></span>
<span class="line"><span style="color:#F97583;">    var</span><span style="color:#E1E4E8;"> stride </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">    while</span><span style="color:#E1E4E8;"> (stride &lt; </span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (local_index </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> stride) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            shared_data[local_index] </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> shared_data[local_index </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> stride];</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#B392F0;">        workgroupBarrier</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        stride </span><span style="color:#F97583;">*=</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 保存结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    output_data[global_index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> shared_data[local_index];</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="性能优化技术" tabindex="-1">性能优化技术 <a class="header-anchor" href="#性能优化技术" aria-label="Permalink to &quot;性能优化技术&quot;">​</a></h2><h3 id="内存访问模式" tabindex="-1">内存访问模式 <a class="header-anchor" href="#内存访问模式" aria-label="Permalink to &quot;内存访问模式&quot;">​</a></h3><p>优化内存访问模式对性能至关重要：</p><p><strong>合并访问模式</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>优化前 (随机访问):   优化后 (连续访问):</span></span>
<span class="line"><span>[3,7,1,9,2,8,...]   [0,1,2,3,4,5,...]</span></span>
<span class="line"><span>   ↓                    ↓</span></span>
<span class="line"><span>缓存失效             缓存命中</span></span></code></pre></div><h3 id="占用率优化" tabindex="-1">占用率优化 <a class="header-anchor" href="#占用率优化" aria-label="Permalink to &quot;占用率优化&quot;">​</a></h3><p>保持足够的线程占用率以隐藏内存延迟：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 低占用率 - 工作组太大</span></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">256</span><span style="color:#E1E4E8;">)</span><span style="color:#6A737D;">  // 可能超出硬件限制</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> low_occupancy</span><span style="color:#E1E4E8;">() { }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 高占用率 - 适当的工作组大小  </span></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">)</span><span style="color:#6A737D;">   // 适合大多数硬件</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> high_occupancy</span><span style="color:#E1E4E8;">() { }</span></span></code></pre></div><h3 id="双缓冲技术" tabindex="-1">双缓冲技术 <a class="header-anchor" href="#双缓冲技术" aria-label="Permalink to &quot;双缓冲技术&quot;">​</a></h3><p>使用双缓冲区避免读写冲突：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建双缓冲区</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bufferA</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createBuffer</span><span style="color:#E1E4E8;">({ </span><span style="color:#6A737D;">/* ... */</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bufferB</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createBuffer</span><span style="color:#E1E4E8;">({ </span><span style="color:#6A737D;">/* ... */</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 交替使用缓冲区</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> readBuffer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bufferA;</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> writeBuffer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bufferB;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 每帧交换</span></span>
<span class="line"><span style="color:#E1E4E8;">[readBuffer, writeBuffer] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [writeBuffer, readBuffer];</span></span></code></pre></div><h2 id="实际应用案例" tabindex="-1">实际应用案例 <a class="header-anchor" href="#实际应用案例" aria-label="Permalink to &quot;实际应用案例&quot;">​</a></h2><h3 id="物理模拟" tabindex="-1">物理模拟 <a class="header-anchor" href="#物理模拟" aria-label="Permalink to &quot;物理模拟&quot;">​</a></h3><p>计算着色器非常适合物理模拟：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> physics_update</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">@</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(global_invocation_id) global_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> particle_index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> global_id</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">x;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (particle_index &lt; num_particles) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 读取粒子状态</span></span>
<span class="line"><span style="color:#F97583;">        var</span><span style="color:#E1E4E8;"> position </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> positions[particle_index];</span></span>
<span class="line"><span style="color:#F97583;">        var</span><span style="color:#E1E4E8;"> velocity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> velocities[particle_index];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 应用物理规则</span></span>
<span class="line"><span style="color:#E1E4E8;">        velocity </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> gravity </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> delta_time;</span></span>
<span class="line"><span style="color:#E1E4E8;">        position </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> velocity </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> delta_time;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 碰撞检测</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (position</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">y &lt; </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            position</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">y </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0.0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            velocity</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">y </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> -</span><span style="color:#E1E4E8;">velocity</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">y </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> damping;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 更新粒子状态</span></span>
<span class="line"><span style="color:#E1E4E8;">        positions[particle_index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> position;</span></span>
<span class="line"><span style="color:#E1E4E8;">        velocities[particle_index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> velocity;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="图像处理" tabindex="-1">图像处理 <a class="header-anchor" href="#图像处理" aria-label="Permalink to &quot;图像处理&quot;">​</a></h3><p>并行处理图像像素：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> image_filter</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">@</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(global_invocation_id) global_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> coord </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> vec2</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">i32</span><span style="color:#E1E4E8;">&gt;(global_id</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">xy);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 应用卷积滤波器</span></span>
<span class="line"><span style="color:#F97583;">    var</span><span style="color:#E1E4E8;"> sum </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> y </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> -</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; y </span><span style="color:#F97583;">&lt;=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; y</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> -</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; x </span><span style="color:#F97583;">&lt;=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; x</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">            let</span><span style="color:#E1E4E8;"> sample_coord </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> coord </span><span style="color:#F97583;">+</span><span style="color:#F97583;"> vec2</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">i32</span><span style="color:#E1E4E8;">&gt;(x, y);</span></span>
<span class="line"><span style="color:#F97583;">            let</span><span style="color:#E1E4E8;"> sample_color </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> textureLoad</span><span style="color:#E1E4E8;">(input_image, sample_coord, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">rgb;</span></span>
<span class="line"><span style="color:#F97583;">            let</span><span style="color:#E1E4E8;"> kernel_value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> kernel[y </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">][x </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">            sum </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> sample_color </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> kernel_value;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 写入结果</span></span>
<span class="line"><span style="color:#B392F0;">    textureStore</span><span style="color:#E1E4E8;">(output_image, coord, </span><span style="color:#F97583;">vec4</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;(sum, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="调试与性能分析" tabindex="-1">调试与性能分析 <a class="header-anchor" href="#调试与性能分析" aria-label="Permalink to &quot;调试与性能分析&quot;">​</a></h2><h3 id="调试技术" tabindex="-1">调试技术 <a class="header-anchor" href="#调试技术" aria-label="Permalink to &quot;调试技术&quot;">​</a></h3><p>计算着色器的调试需要特殊技术：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 调试输出技术</span></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">group</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">@</span><span style="color:#B392F0;">binding</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">storage</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">read_write</span><span style="color:#E1E4E8;">&gt; debug_buffer: </span><span style="color:#F97583;">array</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> debug_example</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">@</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(global_invocation_id) global_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> global_id</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">x;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 写入调试信息</span></span>
<span class="line"><span style="color:#E1E4E8;">    debug_buffer[index] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> some_computation_result;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 条件调试输出</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (some_condition) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        debug_buffer[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 1.0</span><span style="color:#E1E4E8;">;</span><span style="color:#6A737D;">  // 标记特殊条件</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="性能测量" tabindex="-1">性能测量 <a class="header-anchor" href="#性能测量" aria-label="Permalink to &quot;性能测量&quot;">​</a></h3><p>使用时间戳查询测量计算性能：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建查询集</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> querySet</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createQuerySet</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    type: </span><span style="color:#9ECBFF;">&#39;timestamp&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    count: </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在计算通道中插入时间戳</span></span>
<span class="line"><span style="color:#E1E4E8;">computePass.</span><span style="color:#B392F0;">writeTimestamp</span><span style="color:#E1E4E8;">(querySet, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 开始时间</span></span>
<span class="line"><span style="color:#6A737D;">// ... 计算命令 ...</span></span>
<span class="line"><span style="color:#E1E4E8;">computePass.</span><span style="color:#B392F0;">writeTimestamp</span><span style="color:#E1E4E8;">(querySet, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 结束时间</span></span></code></pre></div><p>WebGPU 计算为 Web 平台带来了前所未有的并行计算能力，使得在浏览器中运行复杂的科学计算、机器学习和实时模拟成为现实。通过合理的工作组设计、内存访问优化和算法并行化，开发者可以充分利用现代 GPU 的强大算力。</p>`,83)])])}const d=a(o,[["render",e]]);export{F as __pageData,d as default};
