import{_ as n,c as a,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const d=JSON.parse('{"title":"Electron 进程模型","description":"","frontmatter":{},"headers":[{"level":2,"title":"进程模型概述","slug":"进程模型概述","link":"#进程模型概述","children":[]},{"level":2,"title":"主进程详解","slug":"主进程详解","link":"#主进程详解","children":[{"level":3,"title":"主进程职责","slug":"主进程职责","link":"#主进程职责","children":[]},{"level":3,"title":"主进程代码示例","slug":"主进程代码示例","link":"#主进程代码示例","children":[]}]},{"level":2,"title":"渲染器进程详解","slug":"渲染器进程详解","link":"#渲染器进程详解","children":[{"level":3,"title":"渲染器进程特点","slug":"渲染器进程特点","link":"#渲染器进程特点","children":[]},{"level":3,"title":"渲染器进程架构","slug":"渲染器进程架构","link":"#渲染器进程架构","children":[]}]},{"level":2,"title":"预加载脚本","slug":"预加载脚本","link":"#预加载脚本","children":[{"level":3,"title":"预加载脚本的作用","slug":"预加载脚本的作用","link":"#预加载脚本的作用","children":[]},{"level":3,"title":"预加载脚本示例","slug":"预加载脚本示例","link":"#预加载脚本示例","children":[]}]},{"level":2,"title":"进程间通信机制","slug":"进程间通信机制","link":"#进程间通信机制","children":[{"level":3,"title":"IPC 通信模式","slug":"ipc-通信模式","link":"#ipc-通信模式","children":[]},{"level":3,"title":"IPC 通信示例","slug":"ipc-通信示例","link":"#ipc-通信示例","children":[]}]},{"level":2,"title":"多进程架构优势","slug":"多进程架构优势","link":"#多进程架构优势","children":[{"level":3,"title":"稳定性","slug":"稳定性","link":"#稳定性","children":[]},{"level":3,"title":"安全性","slug":"安全性","link":"#安全性","children":[]},{"level":3,"title":"性能优化","slug":"性能优化","link":"#性能优化","children":[]}]},{"level":2,"title":"进程管理实践","slug":"进程管理实践","link":"#进程管理实践","children":[{"level":3,"title":"进程监控","slug":"进程监控","link":"#进程监控","children":[]},{"level":3,"title":"资源优化","slug":"资源优化","link":"#资源优化","children":[]}]}],"relativePath":"special/electron/process-model.md","filePath":"special/electron/process-model.md"}'),o={name:"special/electron/process-model.md"};function e(t,s,c,r,i,E){return l(),a("div",null,[...s[0]||(s[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /special/electron/process-model.md for this page in Markdown format</div><h1 id="electron-进程模型" tabindex="-1">Electron 进程模型 <a class="header-anchor" href="#electron-进程模型" aria-label="Permalink to &quot;Electron 进程模型&quot;">​</a></h1><p>Electron 进程模型是理解 Electron 应用程序架构的核心概念。它基于 Chromium 的多进程架构，将传统的桌面应用程序分解为多个独立的进程，每个进程负责不同的功能，共同协作提供安全、稳定的应用程序体验。</p><h2 id="进程模型概述" tabindex="-1">进程模型概述 <a class="header-anchor" href="#进程模型概述" aria-label="Permalink to &quot;进程模型概述&quot;">​</a></h2><p>Electron 应用采用多进程架构，主要包含两种类型的进程：主进程和渲染器进程。这种设计借鉴了现代浏览器的架构理念，将用户界面和业务逻辑分离，确保应用程序的稳定性和安全性。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>应用程序启动</span></span>
<span class="line"><span>     |</span></span>
<span class="line"><span>     +-- 主进程 (Main Process) [唯一]</span></span>
<span class="line"><span>     |     |</span></span>
<span class="line"><span>     |     +-- 创建和管理所有窗口</span></span>
<span class="line"><span>     |     +-- 处理应用程序生命周期</span></span>
<span class="line"><span>     |     +-- 访问原生 GUI 和系统 API</span></span>
<span class="line"><span>     |</span></span>
<span class="line"><span>     +-- 渲染器进程 (Renderer Processes) [多个]</span></span>
<span class="line"><span>           |</span></span>
<span class="line"><span>           +-- 每个窗口一个渲染器进程</span></span>
<span class="line"><span>           +-- 运行在沙箱环境中</span></span>
<span class="line"><span>           +-- 负责显示 Web 内容</span></span></code></pre></div><p>这种架构的核心优势在于隔离性：如果一个渲染器进程崩溃，不会影响主进程和其他渲染器进程，应用程序仍可继续运行。</p><h2 id="主进程详解" tabindex="-1">主进程详解 <a class="header-anchor" href="#主进程详解" aria-label="Permalink to &quot;主进程详解&quot;">​</a></h2><p>主进程是 Electron 应用程序的入口点，也是整个应用的控制中心。每个 Electron 应用有且仅有一个主进程，它在 Node.js 环境中运行，拥有完整的系统访问权限。</p><h3 id="主进程职责" tabindex="-1">主进程职责 <a class="header-anchor" href="#主进程职责" aria-label="Permalink to &quot;主进程职责&quot;">​</a></h3><p>主进程负责以下关键功能：</p><ul><li><strong>应用程序生命周期管理</strong>：处理应用的启动、就绪、窗口全部关闭和退出等事件</li><li><strong>窗口管理</strong>：创建、管理和销毁浏览器窗口</li><li><strong>菜单和系统托盘</strong>：创建应用程序菜单、上下文菜单和系统托盘图标</li><li><strong>文件系统和网络访问</strong>：通过 Node.js API 访问操作系统资源</li><li><strong>进程间通信</strong>：作为通信枢纽，协调各个渲染器进程之间的数据交换</li></ul><h3 id="主进程代码示例" tabindex="-1">主进程代码示例 <a class="header-anchor" href="#主进程代码示例" aria-label="Permalink to &quot;主进程代码示例&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">app</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">BrowserWindow</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">ipcMain</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;electron&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> path</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;path&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 应用程序生命周期事件</span></span>
<span class="line"><span style="color:#E1E4E8;">app.</span><span style="color:#B392F0;">whenReady</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(createWindow);</span></span>
<span class="line"><span style="color:#E1E4E8;">app.</span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;window-all-closed&#39;</span><span style="color:#E1E4E8;">, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (process.platform </span><span style="color:#F97583;">!==</span><span style="color:#9ECBFF;"> &#39;darwin&#39;</span><span style="color:#E1E4E8;">) app.</span><span style="color:#B392F0;">quit</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">app.</span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;activate&#39;</span><span style="color:#E1E4E8;">, recreateWindowIfNeeded);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 窗口管理</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> createWindow</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> mainWindow</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> BrowserWindow</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    width: </span><span style="color:#79B8FF;">800</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    height: </span><span style="color:#79B8FF;">600</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    webPreferences: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      preload: path.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">(__dirname, </span><span style="color:#9ECBFF;">&#39;preload.js&#39;</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#E1E4E8;">      contextIsolation: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      nodeIntegration: </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  mainWindow.</span><span style="color:#B392F0;">loadFile</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;index.html&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 进程间通信处理</span></span>
<span class="line"><span style="color:#E1E4E8;">ipcMain.</span><span style="color:#B392F0;">handle</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;read-file&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">event</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">filePath</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> fs</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;fs&#39;</span><span style="color:#E1E4E8;">).promises;</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> content</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> fs.</span><span style="color:#B392F0;">readFile</span><span style="color:#E1E4E8;">(filePath, </span><span style="color:#9ECBFF;">&#39;utf-8&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> content;</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h2 id="渲染器进程详解" tabindex="-1">渲染器进程详解 <a class="header-anchor" href="#渲染器进程详解" aria-label="Permalink to &quot;渲染器进程详解&quot;">​</a></h2><p>渲染器进程负责显示用户界面。每个 Electron 窗口都运行在独立的渲染器进程中，这些进程基于 Chromium 内核，专门用于渲染 Web 内容。</p><h3 id="渲染器进程特点" tabindex="-1">渲染器进程特点 <a class="header-anchor" href="#渲染器进程特点" aria-label="Permalink to &quot;渲染器进程特点&quot;">​</a></h3><ul><li><strong>基于 Chromium</strong>：每个渲染器进程都是独立的 Chromium 实例，拥有自己的 JavaScript 执行环境和 DOM</li><li><strong>进程隔离</strong>：每个窗口的渲染器进程相互隔离，崩溃不会相互影响</li><li><strong>沙箱环境</strong>：默认运行在受限的沙箱环境中，无法直接访问 Node.js API</li><li><strong>Web 标准支持</strong>：完整支持 HTML5、CSS3 和现代 JavaScript 特性</li></ul><h3 id="渲染器进程架构" tabindex="-1">渲染器进程架构 <a class="header-anchor" href="#渲染器进程架构" aria-label="Permalink to &quot;渲染器进程架构&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>渲染器进程 (Renderer Process)</span></span>
<span class="line"><span>     |</span></span>
<span class="line"><span>     +-- HTML 解析器</span></span>
<span class="line"><span>     |     |</span></span>
<span class="line"><span>     |     +-- 解析和构建 DOM 树</span></span>
<span class="line"><span>     |</span></span>
<span class="line"><span>     +-- CSS 解析器</span></span>
<span class="line"><span>     |     |</span></span>
<span class="line"><span>     |     +-- 计算样式和布局</span></span>
<span class="line"><span>     |</span></span>
<span class="line"><span>     +-- JavaScript 引擎 (V8)</span></span>
<span class="line"><span>     |     |</span></span>
<span class="line"><span>     |     +-- 执行页面脚本</span></span>
<span class="line"><span>     |     +-- 处理用户交互</span></span>
<span class="line"><span>     |</span></span>
<span class="line"><span>     +-- 图形渲染管线</span></span>
<span class="line"><span>           |</span></span>
<span class="line"><span>           +-- 合成和绘制页面</span></span></code></pre></div><h2 id="预加载脚本" tabindex="-1">预加载脚本 <a class="header-anchor" href="#预加载脚本" aria-label="Permalink to &quot;预加载脚本&quot;">​</a></h2><p>预加载脚本是 Electron 进程模型中的重要组成部分，它在渲染器进程加载网页之前运行，充当主进程和渲染器进程之间的安全桥梁。</p><h3 id="预加载脚本的作用" tabindex="-1">预加载脚本的作用 <a class="header-anchor" href="#预加载脚本的作用" aria-label="Permalink to &quot;预加载脚本的作用&quot;">​</a></h3><ul><li><strong>上下文隔离</strong>：在独立的 JavaScript 上下文中运行，与网页内容隔离</li><li><strong>API 暴露</strong>：安全地将 Node.js 功能和主进程 API 暴露给渲染器</li><li><strong>安全性增强</strong>：防止渲染器直接访问敏感的系统 API</li></ul><h3 id="预加载脚本示例" tabindex="-1">预加载脚本示例 <a class="header-anchor" href="#预加载脚本示例" aria-label="Permalink to &quot;预加载脚本示例&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// preload.js</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">contextBridge</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">ipcRenderer</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;electron&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 通过 contextBridge 安全地暴露 API 给渲染器</span></span>
<span class="line"><span style="color:#E1E4E8;">contextBridge.</span><span style="color:#B392F0;">exposeInMainWorld</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;electronAPI&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#B392F0;">  readFile</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">filePath</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> ipcRenderer.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;read-file&#39;</span><span style="color:#E1E4E8;">, filePath),</span></span>
<span class="line"><span style="color:#B392F0;">  showDialog</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">options</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> ipcRenderer.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;show-dialog&#39;</span><span style="color:#E1E4E8;">, options),</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">  // 监听主进程消息</span></span>
<span class="line"><span style="color:#B392F0;">  onUpdateAvailable</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">callback</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">    ipcRenderer.</span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;update-available&#39;</span><span style="color:#E1E4E8;">, callback)</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在渲染器中可以通过 window.electronAPI 访问这些方法</span></span></code></pre></div><h2 id="进程间通信机制" tabindex="-1">进程间通信机制 <a class="header-anchor" href="#进程间通信机制" aria-label="Permalink to &quot;进程间通信机制&quot;">​</a></h2><p>进程间通信是 Electron 多进程架构的核心，允许主进程和渲染器进程安全地交换数据和调用功能。</p><h3 id="ipc-通信模式" tabindex="-1">IPC 通信模式 <a class="header-anchor" href="#ipc-通信模式" aria-label="Permalink to &quot;IPC 通信模式&quot;">​</a></h3><p>Electron 提供了多种 IPC 通信模式：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>主进程 (ipcMain) &lt;---&gt; 渲染器进程 (ipcRenderer)</span></span>
<span class="line"><span>     ^                         ^</span></span>
<span class="line"><span>     |                         |</span></span>
<span class="line"><span>     +-- 异步消息 (invoke/handle)</span></span>
<span class="line"><span>     |                         |</span></span>
<span class="line"><span>     +-- 事件监听 (on/off)</span></span>
<span class="line"><span>     |                         |</span></span>
<span class="line"><span>     +-- 同步消息 (sendSync)</span></span></code></pre></div><h3 id="ipc-通信示例" tabindex="-1">IPC 通信示例 <a class="header-anchor" href="#ipc-通信示例" aria-label="Permalink to &quot;IPC 通信示例&quot;">​</a></h3><p><strong>主进程端</strong>：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">ipcMain</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;electron&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 处理异步请求</span></span>
<span class="line"><span style="color:#E1E4E8;">ipcMain.</span><span style="color:#B392F0;">handle</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;get-system-info&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    platform: process.platform,</span></span>
<span class="line"><span style="color:#E1E4E8;">    arch: process.arch,</span></span>
<span class="line"><span style="color:#E1E4E8;">    versions: process.versions</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 发送事件到渲染器</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> sendUpdateToRenderer</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">updateInfo</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  mainWindow.webContents.</span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;update-available&#39;</span><span style="color:#E1E4E8;">, updateInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p><strong>渲染器端</strong> (通过预加载脚本)：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 调用主进程方法</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> systemInfo</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> window.electronAPI.</span><span style="color:#B392F0;">getSystemInfo</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 监听主进程事件</span></span>
<span class="line"><span style="color:#E1E4E8;">window.electronAPI.</span><span style="color:#B392F0;">onUpdateAvailable</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">event</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">updateInfo</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;收到更新:&#39;</span><span style="color:#E1E4E8;">, updateInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h2 id="多进程架构优势" tabindex="-1">多进程架构优势 <a class="header-anchor" href="#多进程架构优势" aria-label="Permalink to &quot;多进程架构优势&quot;">​</a></h2><p>Electron 的多进程架构带来了显著的优势：</p><h3 id="稳定性" tabindex="-1">稳定性 <a class="header-anchor" href="#稳定性" aria-label="Permalink to &quot;稳定性&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>应用崩溃影响分析：</span></span>
<span class="line"><span>单进程架构：任何一个错误 → 整个应用崩溃</span></span>
<span class="line"><span>     |</span></span>
<span class="line"><span>多进程架构：渲染器进程崩溃 → 仅影响单个窗口</span></span>
<span class="line"><span>     |</span></span>
<span class="line"><span>         主进程崩溃 → 整个应用退出（但概率较低）</span></span></code></pre></div><p>由于进程隔离，单个渲染器进程的崩溃不会影响其他窗口或主进程，大大提高了应用程序的整体稳定性。</p><h3 id="安全性" tabindex="-1">安全性 <a class="header-anchor" href="#安全性" aria-label="Permalink to &quot;安全性&quot;">​</a></h3><p>通过限制渲染器进程的权限，Electron 提供了更好的安全保护：</p><ul><li><strong>沙箱机制</strong>：渲染器进程默认运行在沙箱中，无法直接访问文件系统</li><li><strong>上下文隔离</strong>：预加载脚本与网页内容隔离，防止恶意代码注入</li><li><strong>权限控制</strong>：细粒度的权限控制，限制对敏感 API 的访问</li></ul><h3 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h3><p>多进程架构支持更好的性能优化：</p><ul><li><strong>并行处理</strong>：多个渲染器进程可以并行执行，充分利用多核 CPU</li><li><strong>内存管理</strong>：独立的内存空间，便于垃圾回收和内存优化</li><li><strong>资源分配</strong>：可以根据窗口重要性分配不同的系统资源</li></ul><h2 id="进程管理实践" tabindex="-1">进程管理实践 <a class="header-anchor" href="#进程管理实践" aria-label="Permalink to &quot;进程管理实践&quot;">​</a></h2><h3 id="进程监控" tabindex="-1">进程监控 <a class="header-anchor" href="#进程监控" aria-label="Permalink to &quot;进程监控&quot;">​</a></h3><p>开发人员可以监控和管理各个进程的状态：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 获取所有窗口的 WebContents</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> allWindows</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> BrowserWindow.</span><span style="color:#B392F0;">getAllWindows</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">allWindows.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">win</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">index</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`窗口 \${</span><span style="color:#E1E4E8;">index</span><span style="color:#9ECBFF;">}:\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`- PID: \${</span><span style="color:#E1E4E8;">win</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">webContents</span><span style="color:#9ECBFF;">.</span><span style="color:#B392F0;">getProcessId</span><span style="color:#9ECBFF;">()</span><span style="color:#9ECBFF;">}\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`- 内存使用: \${</span><span style="color:#E1E4E8;">win</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">webContents</span><span style="color:#9ECBFF;">.</span><span style="color:#B392F0;">getProcessMemoryInfo</span><span style="color:#9ECBFF;">()</span><span style="color:#9ECBFF;">}\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 监听进程崩溃</span></span>
<span class="line"><span style="color:#E1E4E8;">win.webContents.</span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;render-process-gone&#39;</span><span style="color:#E1E4E8;">, (</span><span style="color:#FFAB70;">event</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">details</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;渲染器进程崩溃:&#39;</span><span style="color:#E1E4E8;">, details);</span></span>
<span class="line"><span style="color:#6A737D;">  // 可以在这里重新创建窗口或显示错误信息</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h3 id="资源优化" tabindex="-1">资源优化 <a class="header-anchor" href="#资源优化" aria-label="Permalink to &quot;资源优化&quot;">​</a></h3><p>对于资源密集型的应用，可以采取以下优化策略：</p><ul><li><strong>进程复用</strong>：对相似的窗口可以共享渲染器进程</li><li><strong>懒加载</strong>：非活动窗口可以暂停 JavaScript 执行</li><li><strong>进程优先级</strong>：为关键窗口设置更高的进程优先级</li></ul><p>Electron 的进程模型为开发复杂桌面应用程序提供了坚实的基础，理解这一模型对于构建高性能、安全的 Electron 应用至关重要。</p>`,55)])])}const F=n(o,[["render",e]]);export{d as __pageData,F as default};
