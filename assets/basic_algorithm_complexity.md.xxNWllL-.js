import{_ as a,c as s,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const h=JSON.parse('{"title":"复杂度分析","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是复杂度分析","slug":"什么是复杂度分析","link":"#什么是复杂度分析","children":[]},{"level":2,"title":"大 O 表示法","slug":"大-o-表示法","link":"#大-o-表示法","children":[]},{"level":2,"title":"时间复杂度","slug":"时间复杂度","link":"#时间复杂度","children":[{"level":3,"title":"循环结构分析","slug":"循环结构分析","link":"#循环结构分析","children":[]},{"level":3,"title":"递归算法分析","slug":"递归算法分析","link":"#递归算法分析","children":[]}]},{"level":2,"title":"空间复杂度","slug":"空间复杂度","link":"#空间复杂度","children":[{"level":3,"title":"递归空间分析","slug":"递归空间分析","link":"#递归空间分析","children":[]}]},{"level":2,"title":"常见复杂度类别","slug":"常见复杂度类别","link":"#常见复杂度类别","children":[{"level":3,"title":"常数复杂度 O(1)","slug":"常数复杂度-o-1","link":"#常数复杂度-o-1","children":[]},{"level":3,"title":"对数复杂度 O(log n)","slug":"对数复杂度-o-log-n","link":"#对数复杂度-o-log-n","children":[]},{"level":3,"title":"线性复杂度 O(n)","slug":"线性复杂度-o-n","link":"#线性复杂度-o-n","children":[]},{"level":3,"title":"线性对数复杂度 O(n log n)","slug":"线性对数复杂度-o-n-log-n","link":"#线性对数复杂度-o-n-log-n","children":[]},{"level":3,"title":"平方复杂度 O(n²)","slug":"平方复杂度-o-n2","link":"#平方复杂度-o-n2","children":[]},{"level":3,"title":"指数复杂度 O(2ⁿ)","slug":"指数复杂度-o-2n","link":"#指数复杂度-o-2n","children":[]}]},{"level":2,"title":"复杂度计算规则","slug":"复杂度计算规则","link":"#复杂度计算规则","children":[{"level":3,"title":"加法规则","slug":"加法规则","link":"#加法规则","children":[]},{"level":3,"title":"乘法规则","slug":"乘法规则","link":"#乘法规则","children":[]},{"level":3,"title":"其他规则","slug":"其他规则","link":"#其他规则","children":[]}]},{"level":2,"title":"实际应用技巧","slug":"实际应用技巧","link":"#实际应用技巧","children":[{"level":3,"title":"代码分析步骤","slug":"代码分析步骤","link":"#代码分析步骤","children":[]},{"level":3,"title":"复杂度优化策略","slug":"复杂度优化策略","link":"#复杂度优化策略","children":[]}]}],"relativePath":"basic/algorithm/complexity.md","filePath":"basic/algorithm/complexity.md"}'),e={name:"basic/algorithm/complexity.md"};function i(o,n,t,c,r,d){return l(),s("div",null,[...n[0]||(n[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /basic/algorithm/complexity.md for this page in Markdown format</div><h1 id="复杂度分析" tabindex="-1">复杂度分析 <a class="header-anchor" href="#复杂度分析" aria-label="Permalink to &quot;复杂度分析&quot;">​</a></h1><h2 id="什么是复杂度分析" tabindex="-1">什么是复杂度分析 <a class="header-anchor" href="#什么是复杂度分析" aria-label="Permalink to &quot;什么是复杂度分析&quot;">​</a></h2><p>复杂度分析是评估算法效率的数学方法，用于预测算法在输入规模增长时资源消耗的变化趋势。它不依赖具体硬件和编程语言，而是关注算法内在的效能特性。</p><p>特点：</p><ul><li>抽象性：忽略常数因子和低阶项，关注增长趋势</li><li>预测性：在算法实现前即可评估其 scalability</li><li>双重性：同时分析时间复杂度和空间复杂度</li></ul><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>输入规模n增大时：</span></span>
<span class="line"><span>高效算法：资源消耗缓慢增长 → ／</span></span>
<span class="line"><span>低效算法：资源消耗快速增长 → ＼</span></span></code></pre></div><h2 id="大-o-表示法" tabindex="-1">大 O 表示法 <a class="header-anchor" href="#大-o-表示法" aria-label="Permalink to &quot;大 O 表示法&quot;">​</a></h2><p>大 O 表示法描述算法复杂度的上界，表示最坏情况下的增长趋势。它捕捉算法性能的本质特征，忽略具体细节。</p><p>特点：</p><ul><li>渐进性：只关心 n 趋近无穷大时的行为</li><li>简化性：去掉常数系数和低阶项</li><li>可比性：便于不同算法间的效率比较</li></ul><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>O(1):     ─────────  恒定不变</span></span>
<span class="line"><span>O(log n): ／          缓慢增长  </span></span>
<span class="line"><span>O(n):    ／│          线性增长</span></span>
<span class="line"><span>O(n²):   ／│││        平方增长</span></span>
<span class="line"><span>O(2ⁿ):   ／││││││││  指数爆炸</span></span></code></pre></div><h2 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h2><p>时间复杂度度量算法运行时间随输入规模的增长关系。通过分析基本操作次数来估算，重点关注循环和递归结构。</p><p>特点：</p><ul><li>操作计数：以基本操作 (比较、赋值等) 为单位</li><li>最坏情况：保证算法在任何输入下的性能下限</li><li>平均情况：反映算法在典型输入下的表现</li></ul><p>示意图 (常见时间复杂度对比)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>n=10时：</span></span>
<span class="line"><span>O(1): 1步</span></span>
<span class="line"><span>O(log n): ~3步  </span></span>
<span class="line"><span>O(n): 10步</span></span>
<span class="line"><span>O(n log n): ~30步</span></span>
<span class="line"><span>O(n²): 100步</span></span>
<span class="line"><span>O(2ⁿ): 1024步</span></span></code></pre></div><h3 id="循环结构分析" tabindex="-1">循环结构分析 <a class="header-anchor" href="#循环结构分析" aria-label="Permalink to &quot;循环结构分析&quot;">​</a></h3><p>单层循环的时间复杂度通常为 O(n)，嵌套循环为 O(n²)，但具体取决于循环条件和步长。</p><p>特点：</p><ul><li>循环变量：分析索引 i 的变化模式</li><li>终止条件：确定循环执行次数</li><li>步长影响：i*=2 产生 O(log n)</li></ul><p>示意图 (不同循环模式)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>for(i=0; i&lt;n; i++):     O(n)  → ││││││││</span></span>
<span class="line"><span>for(i=1; i&lt;n; i*=2):    O(log n) → │ │ │</span></span>
<span class="line"><span>for(i=0; i&lt;n; i++):     O(n²) → 每个│展开为n个小│</span></span>
<span class="line"><span>    for(j=0; j&lt;n; j++)</span></span></code></pre></div><h3 id="递归算法分析" tabindex="-1">递归算法分析 <a class="header-anchor" href="#递归算法分析" aria-label="Permalink to &quot;递归算法分析&quot;">​</a></h3><p>递归复杂度通过递推关系式求解，常用主定理或递归树方法。</p><p>特点：</p><ul><li>递推方程：T(n) = aT(n/b) + f(n)</li><li>递归深度：影响空间复杂度</li><li>子问题数：决定时间复杂度</li></ul><p>示意图 (递归树，以归并排序为例)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>        n</span></span>
<span class="line"><span>      /   \\</span></span>
<span class="line"><span>    n/2   n/2</span></span>
<span class="line"><span>    / \\   / \\</span></span>
<span class="line"><span>  n/4 n/4 n/4 n/4</span></span>
<span class="line"><span>  ...直到叶子节点为1</span></span>
<span class="line"><span>每层工作量：n → n → n → ...</span></span>
<span class="line"><span>层数：log n</span></span>
<span class="line"><span>总工作量：O(n log n)</span></span></code></pre></div><h2 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-label="Permalink to &quot;空间复杂度&quot;">​</a></h2><p>空间复杂度度量算法执行所需内存空间随输入规模的增长关系，包括程序代码、变量、栈空间等。</p><p>特点：</p><ul><li>固定部分：与输入无关的常量空间</li><li>可变部分：依赖输入规模的额外空间</li><li>原地算法：空间复杂度为 O(1)</li></ul><p>示意图 (内存使用分布)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[代码区][静态数据区][栈空间][堆空间]</span></span>
<span class="line"><span>        固定部分     ↑     可变部分</span></span>
<span class="line"><span>                递归深度  动态分配</span></span></code></pre></div><h3 id="递归空间分析" tabindex="-1">递归空间分析 <a class="header-anchor" href="#递归空间分析" aria-label="Permalink to &quot;递归空间分析&quot;">​</a></h3><p>递归调用在栈中保存状态信息，空间复杂度与递归深度直接相关。</p><p>特点：</p><ul><li>栈帧累积：每次递归调用创建新的栈帧</li><li>深度影响：最坏情况下可能达到 O(n)</li><li>尾递归优化：可减少栈空间使用</li></ul><p>示意图 (递归调用栈)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>函数A(n)调用A(n-1)调用A(n-2)...调用A(1)</span></span>
<span class="line"><span>栈深度：n</span></span>
<span class="line"><span>栈内容：[A(n)状态][A(n-1)状态]...[A(1)状态]</span></span></code></pre></div><h2 id="常见复杂度类别" tabindex="-1">常见复杂度类别 <a class="header-anchor" href="#常见复杂度类别" aria-label="Permalink to &quot;常见复杂度类别&quot;">​</a></h2><h3 id="常数复杂度-o-1" tabindex="-1">常数复杂度 O(1) <a class="header-anchor" href="#常数复杂度-o-1" aria-label="Permalink to &quot;常数复杂度 O(1)&quot;">​</a></h3><p>算法执行时间与输入规模无关，是最理想的复杂度。</p><p>特点：</p><ul><li>无循环：操作次数固定</li><li>直接访问：如数组按索引访问</li><li>数学运算：基本算术操作</li></ul><p>示例：</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">def</span><span style="color:#B392F0;"> get_first_element</span><span style="color:#E1E4E8;">(arr):</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> arr[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]  </span><span style="color:#6A737D;"># 无论arr多大，都只需一步</span></span></code></pre></div><h3 id="对数复杂度-o-log-n" tabindex="-1">对数复杂度 O(log n) <a class="header-anchor" href="#对数复杂度-o-log-n" aria-label="Permalink to &quot;对数复杂度 O(log n)&quot;">​</a></h3><p>算法每步将问题规模减小固定比例，常见于分治算法。</p><p>特点：</p><ul><li>问题折半：每次减少一半搜索空间</li><li>指数逆运算：log₂n 是 2ⁿ 的反函数</li><li>高效搜索：在有序数据中快速定位</li></ul><p>示意图 (二分搜索)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>搜索空间: n → n/2 → n/4 → ... → 1</span></span>
<span class="line"><span>步骤数: log₂n</span></span>
<span class="line"><span>如n=16: 16→8→4→2→1 (4步)</span></span></code></pre></div><h3 id="线性复杂度-o-n" tabindex="-1">线性复杂度 O(n) <a class="header-anchor" href="#线性复杂度-o-n" aria-label="Permalink to &quot;线性复杂度 O(n)&quot;">​</a></h3><p>算法执行时间与输入规模成正比，需要遍历整个输入。</p><p>特点：</p><ul><li>单次遍历：从头到尾处理每个元素</li><li>比例关系：输入翻倍，时间翻倍</li><li>基础操作：如查找最大值、求和</li></ul><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>处理数组: [×][×][×][×][×][×][×][×]</span></span>
<span class="line"><span>每个×需要固定时间c，总时间c×n</span></span></code></pre></div><h3 id="线性对数复杂度-o-n-log-n" tabindex="-1">线性对数复杂度 O(n log n) <a class="header-anchor" href="#线性对数复杂度-o-n-log-n" aria-label="Permalink to &quot;线性对数复杂度 O(n log n)&quot;">​</a></h3><p>结合线性和对数特性，常见于高效排序算法。</p><p>特点：</p><ul><li>分层处理：每层 O(n) 工作，共 O(log n) 层</li><li>最优比较排序：基于比较的排序算法下限</li><li>分治策略：如归并排序、快速排序</li></ul><p>示意图 (归并排序工作模式)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>分层:    [n个元素]</span></span>
<span class="line"><span>        [n/2][n/2]      ← 每层合并工作量O(n)</span></span>
<span class="line"><span>        [n/4][n/4][n/4][n/4]</span></span>
<span class="line"><span>        ...共log n层</span></span>
<span class="line"><span>总工作量: n × log n</span></span></code></pre></div><h3 id="平方复杂度-o-n2" tabindex="-1">平方复杂度 O(n²) <a class="header-anchor" href="#平方复杂度-o-n2" aria-label="Permalink to &quot;平方复杂度 O(n²)&quot;">​</a></h3><p>通常源于嵌套循环，输入规模微小增加导致时间显著增长。</p><p>特点：</p><ul><li>成对比较：每个元素与其他所有元素交互</li><li>效率低下：大规模数据时性能急剧下降</li><li>简单算法：如冒泡排序、选择排序</li></ul><p>示意图 (嵌套循环访问模式)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>i=0: j=0,1,2,...,n-1</span></span>
<span class="line"><span>i=1: j=0,1,2,...,n-1</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>i=n-1: j=0,1,2,...,n-1</span></span>
<span class="line"><span>总访问次数: n × n = n²</span></span></code></pre></div><h3 id="指数复杂度-o-2n" tabindex="-1">指数复杂度 O(2ⁿ) <a class="header-anchor" href="#指数复杂度-o-2n" aria-label="Permalink to &quot;指数复杂度 O(2ⁿ)&quot;">​</a></h3><p>问题规模轻微增加导致运行时间翻倍，仅适用于极小规模问题。</p><p>特点：</p><ul><li>组合爆炸：处理所有子集或排列</li><li>暴力搜索：穷举所有可能解</li><li>实际限制：n&gt;30时通常不可行</li></ul><p>示意图 (子集生成)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>n=3时子集: {},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}</span></span>
<span class="line"><span>数量: 2³ = 8</span></span>
<span class="line"><span>n每增加1，子集数翻倍</span></span></code></pre></div><h2 id="复杂度计算规则" tabindex="-1">复杂度计算规则 <a class="header-anchor" href="#复杂度计算规则" aria-label="Permalink to &quot;复杂度计算规则&quot;">​</a></h2><h3 id="加法规则" tabindex="-1">加法规则 <a class="header-anchor" href="#加法规则" aria-label="Permalink to &quot;加法规则&quot;">​</a></h3><p>顺序执行多个算法时，总复杂度由最高阶项决定。</p><p>特点：</p><ul><li>取最大值：O(f(n)) + O(g(n)) = O(max(f(n)，g(n)))</li><li>忽略低阶：n² + n = O(n²)</li><li>关注主导：增长最快的项决定整体行为</li></ul><p>示例：</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;"># O(n) + O(n²) = O(n²)</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">in</span><span style="color:#79B8FF;"> range</span><span style="color:#E1E4E8;">(n):        </span><span style="color:#6A737D;"># O(n)</span></span>
<span class="line"><span style="color:#79B8FF;">    print</span><span style="color:#E1E4E8;">(i)</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">in</span><span style="color:#79B8FF;"> range</span><span style="color:#E1E4E8;">(n):        </span><span style="color:#6A737D;"># O(n²)  </span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">in</span><span style="color:#79B8FF;"> range</span><span style="color:#E1E4E8;">(n):</span></span>
<span class="line"><span style="color:#79B8FF;">        print</span><span style="color:#E1E4E8;">(i, j)</span></span></code></pre></div><h3 id="乘法规则" tabindex="-1">乘法规则 <a class="header-anchor" href="#乘法规则" aria-label="Permalink to &quot;乘法规则&quot;">​</a></h3><p>嵌套执行算法时，复杂度为各层复杂度的乘积。</p><p>特点：</p><ul><li>逐层相乘：O(f(n)) × O(g(n)) = O(f(n) × g(n))</li><li>循环嵌套：外层循环次数乘以内层循环次数</li><li>递归调用：递归次数乘以每次递归的工作量</li></ul><p>示例：</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;"># O(n) × O(n) = O(n²)</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">in</span><span style="color:#79B8FF;"> range</span><span style="color:#E1E4E8;">(n):        </span><span style="color:#6A737D;"># O(n)次</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">in</span><span style="color:#79B8FF;"> range</span><span style="color:#E1E4E8;">(n):    </span><span style="color:#6A737D;"># 每次O(n)</span></span>
<span class="line"><span style="color:#79B8FF;">        print</span><span style="color:#E1E4E8;">(i, j)</span></span></code></pre></div><h3 id="其他规则" tabindex="-1">其他规则 <a class="header-anchor" href="#其他规则" aria-label="Permalink to &quot;其他规则&quot;">​</a></h3><p>多项式复杂度保留最高次项，对数复杂度忽略底数。</p><p>特点：</p><ul><li>多项式简化：O(3n³ + 2n² + 10n + 5) = O(n³)</li><li>对数底转换：O(log₂n) = O(log₃n) = O(log n)</li><li>常数忽略：O(2n) = O(n)，O(500) = O(1)</li></ul><h2 id="实际应用技巧" tabindex="-1">实际应用技巧 <a class="header-anchor" href="#实际应用技巧" aria-label="Permalink to &quot;实际应用技巧&quot;">​</a></h2><h3 id="代码分析步骤" tabindex="-1">代码分析步骤 <a class="header-anchor" href="#代码分析步骤" aria-label="Permalink to &quot;代码分析步骤&quot;">​</a></h3><p>从内到外分析代码，识别循环和递归结构。</p><p>分析流程：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>1. 识别基本操作（最内层语句）</span></span>
<span class="line"><span>2. 计算每层循环执行次数</span></span>
<span class="line"><span>3. 应用乘法和加法规则</span></span>
<span class="line"><span>4. 简化表达式，保留主导项</span></span></code></pre></div><p>示例分析：</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">def</span><span style="color:#B392F0;"> example</span><span style="color:#E1E4E8;">(n):</span></span>
<span class="line"><span style="color:#79B8FF;">    sum</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> 0</span></span>
<span class="line"><span style="color:#6A737D;">    # 外层循环：O(n)</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">in</span><span style="color:#79B8FF;"> range</span><span style="color:#E1E4E8;">(n):</span></span>
<span class="line"><span style="color:#6A737D;">        # 内层循环：O(log n)  </span></span>
<span class="line"><span style="color:#E1E4E8;">        j </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 1</span></span>
<span class="line"><span style="color:#F97583;">        while</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n:</span></span>
<span class="line"><span style="color:#79B8FF;">            sum</span><span style="color:#F97583;"> +=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> j</span></span>
<span class="line"><span style="color:#E1E4E8;">            j </span><span style="color:#F97583;">*=</span><span style="color:#79B8FF;"> 2</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#79B8FF;"> sum</span></span>
<span class="line"><span style="color:#6A737D;"># 总复杂度：O(n) × O(log n) = O(n log n)</span></span></code></pre></div><h3 id="复杂度优化策略" tabindex="-1">复杂度优化策略 <a class="header-anchor" href="#复杂度优化策略" aria-label="Permalink to &quot;复杂度优化策略&quot;">​</a></h3><p>根据瓶颈分析，选择合适的数据结构和算法。</p><p>优化方向：</p><ul><li>时间换空间：缓存计算结果</li><li>空间换时间：使用辅助数据结构</li><li>算法升级：从 O(n²) 优化到 O(n log n)</li></ul><p>示意图 (优化路径)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>原始: O(n³) → 优化循环: O(n²) → 使用哈希: O(n) → 数学优化: O(1)</span></span>
<span class="line"><span>每一步都可能大幅提升性能</span></span></code></pre></div>`,111)])])}const g=a(e,[["render",i]]);export{h as __pageData,g as default};
