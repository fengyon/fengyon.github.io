import{_ as a,c as s,o as n,b as l}from"./chunks/framework.CMLuPXeo.js";const h=JSON.parse('{"title":"Page Lifecycle API","description":"","frontmatter":{},"headers":[{"level":2,"title":"生命周期阶段","slug":"生命周期阶段","link":"#生命周期阶段","children":[]},{"level":2,"title":"常见场景","slug":"常见场景","link":"#常见场景","children":[]},{"level":2,"title":"事件","slug":"事件","link":"#事件","children":[{"level":3,"title":"focus 事件","slug":"focus-事件","link":"#focus-事件","children":[]},{"level":3,"title":"blur 事件","slug":"blur-事件","link":"#blur-事件","children":[]},{"level":3,"title":"visibilitychange 事件","slug":"visibilitychange-事件","link":"#visibilitychange-事件","children":[]},{"level":3,"title":"freeze 事件","slug":"freeze-事件","link":"#freeze-事件","children":[]},{"level":3,"title":"resume 事件","slug":"resume-事件","link":"#resume-事件","children":[]},{"level":3,"title":"pageshow 事件","slug":"pageshow-事件","link":"#pageshow-事件","children":[]},{"level":3,"title":"pagehide 事件","slug":"pagehide-事件","link":"#pagehide-事件","children":[]},{"level":3,"title":"beforeunload 事件","slug":"beforeunload-事件","link":"#beforeunload-事件","children":[]},{"level":3,"title":"unload 事件","slug":"unload-事件","link":"#unload-事件","children":[]}]},{"level":2,"title":"获取当前阶段","slug":"获取当前阶段","link":"#获取当前阶段","children":[]},{"level":2,"title":"document.wasDiscarded","slug":"document-wasdiscarded","link":"#document-wasdiscarded","children":[]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"relativePath":"basic/bom/page-lifecycle.md","filePath":"basic/bom/page-lifecycle.md"}'),o={name:"basic/bom/page-lifecycle.md"};function p(i,e,t,c,r,d){return n(),s("div",null,[...e[0]||(e[0]=[l(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /basic/bom/page-lifecycle.md for this page in Markdown format</div><h1 id="page-lifecycle-api" tabindex="-1">Page Lifecycle API <a class="header-anchor" href="#page-lifecycle-api" aria-label="Permalink to &quot;Page Lifecycle API&quot;">​</a></h1><p>Android、iOS 和最新的 Windows 系统可以随时自主地停止后台进程，及时释放系统资源。也就是说，网页可能随时被系统丢弃掉。以前的浏览器 API 完全没有考虑到这种情况，导致开发者根本没有办法监听到系统丢弃页面。</p><p>为了解决这个问题，W3C 新制定了一个 Page Lifecycle API，统一了网页从诞生到卸载的行为模式，并且定义了新的事件，允许开发者响应网页状态的各种转换。</p><p>有了这个 API，开发者就可以预测网页下一步的状态，从而进行各种针对性的处理。Chrome 68 支持这个 API，对于老式浏览器可以使用谷歌开发的兼容库 <a href="https://github.com/GoogleChromeLabs/page-lifecycle" target="_blank" rel="noreferrer">PageLifecycle.js</a>。</p><h2 id="生命周期阶段" tabindex="-1">生命周期阶段 <a class="header-anchor" href="#生命周期阶段" aria-label="Permalink to &quot;生命周期阶段&quot;">​</a></h2><p>网页的生命周期分成六个阶段，每个时刻只可能处于其中一个阶段。</p><p><img src="https://www.wangbase.com/blogimg/asset/201811/bg2018110401.png" alt=""></p><p><strong>(1) Active 阶段</strong></p><p>在 Active 阶段，网页处于可见状态，且拥有输入焦点。</p><p><strong>(2) Passive 阶段</strong></p><p>在 Passive 阶段，网页可见，但没有输入焦点，无法接受输入。UI 更新 (比如动画) 仍然在执行。该阶段只可能发生在桌面同时有多个窗口的情况。</p><p><strong>(3) Hidden 阶段</strong></p><p>在 Hidden 阶段，用户的桌面被其他窗口占据，网页不可见，但尚未冻结。UI 更新不再执行。</p><p><strong>(4) Terminated 阶段</strong></p><p>在 Terminated 阶段，由于用户主动关闭窗口，或者在同一个窗口前往其他页面，导致当前页面开始被浏览器卸载并从内存中清除。注意，这个阶段总是在 Hidden 阶段之后发生，也就是说，用户主动离开当前页面，总是先进入 Hidden 阶段，再进入 Terminated 阶段。</p><p>这个阶段会导致网页卸载，任何新任务都不会在这个阶段启动，并且如果运行时间太长，正在进行的任务可能会被终止。</p><p><strong>(5) Frozen 阶段</strong></p><p>如果网页处于 Hidden 阶段的时间过久，用户又不关闭网页，浏览器就有可能冻结网页，使其进入 Frozen 阶段。不过，也有可能，处于可见状态的页面长时间没有操作，也会进入 Frozen 阶段。</p><p>这个阶段的特征是，网页不会再被分配 CPU 计算资源。定时器、回调函数、网络请求、DOM 操作都不会执行，不过正在运行的任务会执行完。浏览器可能会允许 Frozen 阶段的页面，周期性复苏一小段时间，短暂变回 Hidden 状态，允许一小部分任务执行。</p><p><strong>(6) Discarded 阶段</strong></p><p>如果网页长时间处于 Frozen 阶段，用户又不唤醒页面，那么就会进入 Discarded 阶段，即浏览器自动卸载网页，清除该网页的内存占用。不过，Passive 阶段的网页如果长时间没有互动，也可能直接进入 Discarded 阶段。</p><p>这一般是在用户没有介入的情况下，由系统强制执行。任何类型的新任务或 JavaScript 代码，都不能在此阶段执行，因为这时通常处在资源限制的状况下。</p><p>网页被浏览器自动 Discarded 以后，它的 Tab 窗口还是在的。如果用户重新访问这个 Tab 页，浏览器将会重新向服务器发出请求，再一次重新加载网页，回到 Active 阶段。</p><h2 id="常见场景" tabindex="-1">常见场景 <a class="header-anchor" href="#常见场景" aria-label="Permalink to &quot;常见场景&quot;">​</a></h2><p>以下是几个常见场景的网页生命周期变化。</p><p>(1) 用户打开网页后，又切换到其他 App，但只过了一会又回到网页。</p><p>网页由 Active 变成 Hidden，又变回 Active。</p><p>(2) 用户打开网页后，又切换到其他 App，并且长时候使用后者，导致系统自动丢弃网页。</p><p>网页由 Active 变成 Hidden，再变成 Frozen，最后 Discarded。</p><p>(3) 用户打开网页后，又切换到其他 App，然后从任务管理器里面将浏览器进程清除。</p><p>网页由 Active 变成 Hidden，然后 Terminated。</p><p>(4) 系统丢弃了某个 Tab 里面的页面后，用户重新打开这个 Tab。</p><p>网页由 Discarded 变成 Active。</p><h2 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h2><p>生命周期的各个阶段都有自己的事件，以供开发者指定监听函数。这些事件里面，只有两个是新定义的 (<code>freeze</code> 事件和 <code>resume</code> 事件)，其它都是现有的。</p><p>注意，网页的生命周期事件是在所有帧 (frame) 触发，不管是底层的帧，还是内嵌的帧。也就是说，内嵌的 <code>&lt;iframe&gt;</code> 网页跟顶层网页一样，都会同时监听到下面的事件。</p><h3 id="focus-事件" tabindex="-1">focus 事件 <a class="header-anchor" href="#focus-事件" aria-label="Permalink to &quot;focus 事件&quot;">​</a></h3><p><code>focus</code> 事件在页面获得输入焦点时触发，比如网页从 Passive 阶段变为 Active 阶段。</p><h3 id="blur-事件" tabindex="-1">blur 事件 <a class="header-anchor" href="#blur-事件" aria-label="Permalink to &quot;blur 事件&quot;">​</a></h3><p><code>blur</code> 事件在页面失去输入焦点时触发，比如网页从 Active 阶段变为 Passive 阶段。</p><h3 id="visibilitychange-事件" tabindex="-1">visibilitychange 事件 <a class="header-anchor" href="#visibilitychange-事件" aria-label="Permalink to &quot;visibilitychange 事件&quot;">​</a></h3><p><code>visibilitychange</code> 事件在网页可见状态发生变化时触发，一般发生在以下几种场景。</p><blockquote><ul><li>用户隐藏页面 (切换 Tab、最小化浏览器)，页面由 Active 阶段变成 Hidden 阶段。</li><li>用户重新访问隐藏的页面，页面由 Hidden 阶段变成 Active 阶段。</li><li>用户关闭页面，页面会先进入 Hidden 阶段，然后进入 Terminated 阶段。</li></ul></blockquote><p>可以通过 <code>document.onvisibilitychange</code> 属性指定这个事件的回调函数。</p><h3 id="freeze-事件" tabindex="-1">freeze 事件 <a class="header-anchor" href="#freeze-事件" aria-label="Permalink to &quot;freeze 事件&quot;">​</a></h3><p><code>freeze</code> 事件在网页进入 Frozen 阶段时触发。</p><p>可以通过 <code>document.onfreeze</code> 属性指定在进入 Frozen 阶段时调用的回调函数。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> handleFreeze</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // Handle transition to FROZEN</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">document.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;freeze&#39;</span><span style="color:#E1E4E8;">, handleFreeze);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># 或者</span></span>
<span class="line"><span style="color:#E1E4E8;">document.</span><span style="color:#B392F0;">onfreeze</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> function</span><span style="color:#E1E4E8;">() { … }</span></span></code></pre></div><p>这个事件的监听函数，最长只能运行 500 毫秒。并且只能复用已经打开的网络连接，不能发起新的网络请求。</p><p>注意，从 Frozen 阶段进入 Discarded 阶段，不会触发任何事件，无法指定回调函数，只能在进入 Frozen 阶段时指定回调函数。</p><h3 id="resume-事件" tabindex="-1">resume 事件 <a class="header-anchor" href="#resume-事件" aria-label="Permalink to &quot;resume 事件&quot;">​</a></h3><p><code>resume</code> 事件在网页离开 Frozen 阶段，变为 Active / Passive / Hidden 阶段时触发。</p><p><code>document.onresume</code> 属性指的是页面离开 Frozen 阶段、进入可用状态时调用的回调函数。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> handleResume</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // handle state transition FROZEN -&gt; ACTIVE</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">document.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;resume&quot;</span><span style="color:#E1E4E8;">, handleResume);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># 或者</span></span>
<span class="line"><span style="color:#E1E4E8;">document.</span><span style="color:#B392F0;">onresume</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> function</span><span style="color:#E1E4E8;">() { … }</span></span></code></pre></div><h3 id="pageshow-事件" tabindex="-1">pageshow 事件 <a class="header-anchor" href="#pageshow-事件" aria-label="Permalink to &quot;pageshow 事件&quot;">​</a></h3><p><code>pageshow</code> 事件在用户加载网页时触发。这时，有可能是全新的页面加载，也可能是从缓存中获取的页面。如果是从缓存中获取，则该事件对象的 <code>event.persisted</code> 属性为 <code>true</code>，否则为 <code>false</code>。</p><p>这个事件的名字有点误导，它跟页面的可见性其实毫无关系，只跟浏览器的 History 记录的变化有关。</p><h3 id="pagehide-事件" tabindex="-1">pagehide 事件 <a class="header-anchor" href="#pagehide-事件" aria-label="Permalink to &quot;pagehide 事件&quot;">​</a></h3><p><code>pagehide</code> 事件在用户离开当前网页、进入另一个网页时触发。它的前提是浏览器的 History 记录必须发生变化，跟网页是否可见无关。</p><p>如果浏览器能够将当前页面添加到缓存以供稍后重用，则事件对象的 <code>event.persisted</code> 属性为 <code>true</code>。如果为 <code>true</code>。如果页面添加到了缓存，则页面进入 Frozen 状态，否则进入 Terminatied 状态。</p><h3 id="beforeunload-事件" tabindex="-1">beforeunload 事件 <a class="header-anchor" href="#beforeunload-事件" aria-label="Permalink to &quot;beforeunload 事件&quot;">​</a></h3><p><code>beforeunload</code> 事件在窗口或文档即将卸载时触发。该事件发生时，文档仍然可见，此时卸载仍可取消。经过这个事件，网页进入 Terminated 状态。</p><h3 id="unload-事件" tabindex="-1">unload 事件 <a class="header-anchor" href="#unload-事件" aria-label="Permalink to &quot;unload 事件&quot;">​</a></h3><p><code>unload</code> 事件在页面正在卸载时触发。经过这个事件，网页进入 Terminated 状态。</p><h2 id="获取当前阶段" tabindex="-1">获取当前阶段 <a class="header-anchor" href="#获取当前阶段" aria-label="Permalink to &quot;获取当前阶段&quot;">​</a></h2><p>如果网页处于 Active、Passive 或 Hidden 阶段，可以通过下面的代码，获得网页当前的状态。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#B392F0;"> getState</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (document.visibilityState </span><span style="color:#F97583;">===</span><span style="color:#9ECBFF;"> &#39;hidden&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#9ECBFF;"> &#39;hidden&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (document.</span><span style="color:#B392F0;">hasFocus</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#9ECBFF;"> &#39;active&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#9ECBFF;"> &#39;passive&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><p>如果网页处于 Frozen 和 Terminated 状态，由于定时器代码不会执行，只能通过事件监听判断状态。进入 Frozen 阶段，可以监听 <code>freeze</code> 事件；进入 Terminated 阶段，可以监听 <code>pagehide</code> 事件。</p><h2 id="document-wasdiscarded" tabindex="-1">document.wasDiscarded <a class="header-anchor" href="#document-wasdiscarded" aria-label="Permalink to &quot;document.wasDiscarded&quot;">​</a></h2><p>如果某个选项卡处于 Frozen 阶段，就随时有可能被系统丢弃，进入 Discarded 阶段。如果后来用户再次点击该选项卡，浏览器会重新加载该页面。</p><p>这时，开发者可以通过判断 <code>document.wasDiscarded</code> 属性，了解先前的网页是否被丢弃了。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (document.wasDiscarded) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 该网页已经不是原来的状态了，曾经被浏览器丢弃过</span></span>
<span class="line"><span style="color:#6A737D;">  // 恢复以前的状态</span></span>
<span class="line"><span style="color:#B392F0;">  getPersistedState</span><span style="color:#E1E4E8;">(self.discardedClientId);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>同时，<code>window</code> 对象上会新增 <code>window.clientId</code> 和 <code>window.discardedClientId</code> 两个属性，用来恢复丢弃前的状态。</p><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api" target="_blank" rel="noreferrer">Page Lifecycle API</a>, Philip Walton</li><li><a href="https://github.com/WICG/page-lifecycle" target="_blank" rel="noreferrer">Lifecycle API for Web Pages</a>, W3C</li><li><a href="https://wicg.github.io/page-lifecycle/spec.html" target="_blank" rel="noreferrer">Page Lifecycle 1 Editor’s Draft</a>, W3C</li></ul>`,76)])])}const E=a(o,[["render",p]]);export{h as __pageData,E as default};
