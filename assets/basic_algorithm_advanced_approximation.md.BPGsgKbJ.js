import{_ as n,c as a,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const F=JSON.parse('{"title":"近似算法","description":"","frontmatter":{},"headers":[{"level":2,"title":"算法概述","slug":"算法概述","link":"#算法概述","children":[]},{"level":2,"title":"设计技术","slug":"设计技术","link":"#设计技术","children":[{"level":3,"title":"贪心策略","slug":"贪心策略","link":"#贪心策略","children":[]},{"level":3,"title":"线性规划舍入","slug":"线性规划舍入","link":"#线性规划舍入","children":[]},{"level":3,"title":"局部搜索","slug":"局部搜索","link":"#局部搜索","children":[]}]},{"level":2,"title":"经典问题分析","slug":"经典问题分析","link":"#经典问题分析","children":[{"level":3,"title":"顶点覆盖问题","slug":"顶点覆盖问题","link":"#顶点覆盖问题","children":[]},{"level":3,"title":"旅行商问题","slug":"旅行商问题","link":"#旅行商问题","children":[]},{"level":3,"title":"集合覆盖问题","slug":"集合覆盖问题","link":"#集合覆盖问题","children":[]}]},{"level":2,"title":"性能保证理论","slug":"性能保证理论","link":"#性能保证理论","children":[{"level":3,"title":"近似比分析","slug":"近似比分析","link":"#近似比分析","children":[]},{"level":3,"title":"近似模式","slug":"近似模式","link":"#近似模式","children":[]}]},{"level":2,"title":"实际应用优化","slug":"实际应用优化","link":"#实际应用优化","children":[{"level":3,"title":"缓存友好的实现","slug":"缓存友好的实现","link":"#缓存友好的实现","children":[]},{"level":3,"title":"流式处理版本","slug":"流式处理版本","link":"#流式处理版本","children":[]}]}],"relativePath":"basic/algorithm/advanced/approximation.md","filePath":"basic/algorithm/advanced/approximation.md"}'),o={name:"basic/algorithm/advanced/approximation.md"};function e(t,s,c,E,r,y){return l(),a("div",null,[...s[0]||(s[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /basic/algorithm/advanced/approximation.md for this page in Markdown format</div><h1 id="近似算法" tabindex="-1">近似算法 <a class="header-anchor" href="#近似算法" aria-label="Permalink to &quot;近似算法&quot;">​</a></h1><h2 id="算法概述" tabindex="-1">算法概述 <a class="header-anchor" href="#算法概述" aria-label="Permalink to &quot;算法概述&quot;">​</a></h2><p>近似算法是针对 NP 难问题设计的高效解决方案，通过在合理时间内找到接近最优解的答案来平衡精度与效率。当精确解需要指数时间时，这类算法能在多项式时间内提供有质量保证的近似解。</p><p>核心思想可用以下关系表示：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>最优解值 ≤ 近似解值 ≤ ρ × 最优解值</span></span></code></pre></div><p>其中 ρ 为近似比，衡量算法最坏情况下的性能表现。</p><h2 id="设计技术" tabindex="-1">设计技术 <a class="header-anchor" href="#设计技术" aria-label="Permalink to &quot;设计技术&quot;">​</a></h2><h3 id="贪心策略" tabindex="-1">贪心策略 <a class="header-anchor" href="#贪心策略" aria-label="Permalink to &quot;贪心策略&quot;">​</a></h3><p>贪心算法在每一步选择当前最优决策，逐步构建完整解。虽然不能保证全局最优，但在许多问题中能提供良好的近似比。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>问题: 集合覆盖</span></span>
<span class="line"><span>输入: 集合族F = {S₁, S₂, ..., Sₙ}, 全集U</span></span>
<span class="line"><span>过程: </span></span>
<span class="line"><span>   1. 初始化覆盖集合C = ∅, 未覆盖元素R = U</span></span>
<span class="line"><span>   2. while R ≠ ∅:</span></span>
<span class="line"><span>       选择覆盖最多未覆盖元素的集合Sᵢ</span></span>
<span class="line"><span>       C = C ∪ {Sᵢ}</span></span>
<span class="line"><span>       R = R - Sᵢ</span></span>
<span class="line"><span>输出: 覆盖集合C</span></span></code></pre></div><h3 id="线性规划舍入" tabindex="-1">线性规划舍入 <a class="header-anchor" href="#线性规划舍入" aria-label="Permalink to &quot;线性规划舍入&quot;">​</a></h3><p>将离散优化问题松弛为线性规划，求解后对连续解进行舍入得到整数解。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>连续解空间: ○○○○●●●● (分数解)</span></span>
<span class="line"><span>舍入操作: │</span></span>
<span class="line"><span>离散解空间: ○○○○●●●● (整数解)</span></span></code></pre></div><h3 id="局部搜索" tabindex="-1">局部搜索 <a class="header-anchor" href="#局部搜索" aria-label="Permalink to &quot;局部搜索&quot;">​</a></h3><p>从初始解出发，在邻域内寻找更优解，通过局部改进逼近全局最优。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>初始解: ★······</span></span>
<span class="line"><span>搜索邻域: ·★····· → ··★···· → ···★··· </span></span>
<span class="line"><span>改进方向: 逐步向最优解移动</span></span></code></pre></div><h2 id="经典问题分析" tabindex="-1">经典问题分析 <a class="header-anchor" href="#经典问题分析" aria-label="Permalink to &quot;经典问题分析&quot;">​</a></h2><h3 id="顶点覆盖问题" tabindex="-1">顶点覆盖问题 <a class="header-anchor" href="#顶点覆盖问题" aria-label="Permalink to &quot;顶点覆盖问题&quot;">​</a></h3><p>给定无向图 G=(V,E)，寻找最小顶点子集覆盖所有边。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 2-近似算法实现</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> vertexCoverApproximation</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">graph</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> cover</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Set</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> edges</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Set</span><span style="color:#E1E4E8;">([</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">graph.edges]);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    while</span><span style="color:#E1E4E8;"> (edges.size </span><span style="color:#F97583;">&gt;</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 随机选择一条边 (u, v)</span></span>
<span class="line"><span style="color:#F97583;">        const</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">edge</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> edges;</span></span>
<span class="line"><span style="color:#F97583;">        const</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">u</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">v</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> edge;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 将u和v都加入覆盖集</span></span>
<span class="line"><span style="color:#E1E4E8;">        cover.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(u);</span></span>
<span class="line"><span style="color:#E1E4E8;">        cover.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(v);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 移除所有与u或v相邻的边</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> edge</span><span style="color:#F97583;"> of</span><span style="color:#E1E4E8;"> [</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">edges]) {</span></span>
<span class="line"><span style="color:#F97583;">            const</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">x</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">y</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> edge;</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (x </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> u </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> v </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> y </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> u </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> y </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> v) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                edges.</span><span style="color:#B392F0;">delete</span><span style="color:#E1E4E8;">(edge);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> Array.</span><span style="color:#B392F0;">from</span><span style="color:#E1E4E8;">(cover);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 图结构示例</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> exampleGraph</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    vertices: [</span><span style="color:#9ECBFF;">&#39;A&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;B&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;C&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;D&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;E&#39;</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    edges: [</span></span>
<span class="line"><span style="color:#E1E4E8;">        [</span><span style="color:#9ECBFF;">&#39;A&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;B&#39;</span><span style="color:#E1E4E8;">], [</span><span style="color:#9ECBFF;">&#39;A&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;C&#39;</span><span style="color:#E1E4E8;">], [</span><span style="color:#9ECBFF;">&#39;B&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;D&#39;</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">        [</span><span style="color:#9ECBFF;">&#39;C&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;D&#39;</span><span style="color:#E1E4E8;">], [</span><span style="color:#9ECBFF;">&#39;C&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;E&#39;</span><span style="color:#E1E4E8;">], [</span><span style="color:#9ECBFF;">&#39;D&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;E&#39;</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">    ]</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><h3 id="旅行商问题" tabindex="-1">旅行商问题 <a class="header-anchor" href="#旅行商问题" aria-label="Permalink to &quot;旅行商问题&quot;">​</a></h3><p>在完全图中寻找访问所有顶点一次并返回起点的最短回路。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 最近邻启发式算法</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> tspNearestNeighbor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">distances</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">startCity</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> n</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> distances.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> visited</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Array</span><span style="color:#E1E4E8;">(n).</span><span style="color:#B392F0;">fill</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> tour</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [startCity];</span></span>
<span class="line"><span style="color:#E1E4E8;">    visited[startCity] </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> totalDistance </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> currentCity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> startCity;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        let</span><span style="color:#E1E4E8;"> nearestCity </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> -</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">        let</span><span style="color:#E1E4E8;"> minDist </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> Infinity</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 寻找最近的未访问城市</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> city </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; city </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n; city</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">visited[city] </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> distances[currentCity][city] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> minDist) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                minDist </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> distances[currentCity][city];</span></span>
<span class="line"><span style="color:#E1E4E8;">                nearestCity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> city;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        tour.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(nearestCity);</span></span>
<span class="line"><span style="color:#E1E4E8;">        visited[nearestCity] </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        totalDistance </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> minDist;</span></span>
<span class="line"><span style="color:#E1E4E8;">        currentCity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nearestCity;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 返回起点</span></span>
<span class="line"><span style="color:#E1E4E8;">    totalDistance </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> distances[currentCity][startCity];</span></span>
<span class="line"><span style="color:#E1E4E8;">    tour.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(startCity);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> { tour, totalDistance };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 距离矩阵示例</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> const</span><span style="color:#79B8FF;"> exampleDistances</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">9</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span><span style="color:#79B8FF;">15</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">7</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">12</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">];</span></span></code></pre></div><h3 id="集合覆盖问题" tabindex="-1">集合覆盖问题 <a class="header-anchor" href="#集合覆盖问题" aria-label="Permalink to &quot;集合覆盖问题&quot;">​</a></h3><p>从集合族中选择最小数量的子集，使得这些子集的并集包含所有元素。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 贪心集合覆盖算法</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> setCover</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">universe</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">subsets</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> elements</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Set</span><span style="color:#E1E4E8;">(universe);</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> selectedSubsets</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    while</span><span style="color:#E1E4E8;"> (elements.size </span><span style="color:#F97583;">&gt;</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        let</span><span style="color:#E1E4E8;"> bestSubset </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">        let</span><span style="color:#E1E4E8;"> bestCoverage </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 选择覆盖最多未覆盖元素的子集</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> subset</span><span style="color:#F97583;"> of</span><span style="color:#E1E4E8;"> subsets) {</span></span>
<span class="line"><span style="color:#F97583;">            const</span><span style="color:#79B8FF;"> coverage</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> subset.</span><span style="color:#B392F0;">filter</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">x</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> elements.</span><span style="color:#B392F0;">has</span><span style="color:#E1E4E8;">(x)).</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (coverage </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> bestCoverage) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                bestCoverage </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> coverage;</span></span>
<span class="line"><span style="color:#E1E4E8;">                bestSubset </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> subset;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">bestSubset) </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        selectedSubsets.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(bestSubset);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 移除已覆盖元素</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> element</span><span style="color:#F97583;"> of</span><span style="color:#E1E4E8;"> bestSubset) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            elements.</span><span style="color:#B392F0;">delete</span><span style="color:#E1E4E8;">(element);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 移除已选子集</span></span>
<span class="line"><span style="color:#E1E4E8;">        subsets </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> subsets.</span><span style="color:#B392F0;">filter</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">subset</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> subset </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> bestSubset);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> selectedSubsets;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用示例</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> universe</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">7</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">9</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> subsets</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">7</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">9</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">];</span></span></code></pre></div><h2 id="性能保证理论" tabindex="-1">性能保证理论 <a class="header-anchor" href="#性能保证理论" aria-label="Permalink to &quot;性能保证理论&quot;">​</a></h2><h3 id="近似比分析" tabindex="-1">近似比分析 <a class="header-anchor" href="#近似比分析" aria-label="Permalink to &quot;近似比分析&quot;">​</a></h3><p>近似算法性能通过近似比量化：</p><p>最小化问题：<code>ρ = 算法解 / 最优解 ≥ 1</code> 最大化问题：<code>ρ = 最优解 / 算法解 ≥ 1</code></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>性能谱系:</span></span>
<span class="line"><span>精确算法: ρ = 1</span></span>
<span class="line"><span>近似算法: 1 &lt; ρ &lt; ∞</span></span>
<span class="line"><span>无保证启发式: ρ → ∞</span></span></code></pre></div><h3 id="近似模式" tabindex="-1">近似模式 <a class="header-anchor" href="#近似模式" aria-label="Permalink to &quot;近似模式&quot;">​</a></h3><p>多项式时间近似模式 (PTAS) 允许通过调整参数 ε 控制精度：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 背包问题的PTAS框架</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> knapsackPTAS</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">weights</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">values</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">capacity</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">epsilon</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> 0.1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> n</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> weights.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (epsilon </span><span style="color:#F97583;">===</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 精确算法（指数时间）</span></span>
<span class="line"><span style="color:#F97583;">        return</span><span style="color:#B392F0;"> knapsackExact</span><span style="color:#E1E4E8;">(weights, values, capacity);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 缩放价值的近似算法</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> maxValue</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">values);</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> scale</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, Math.</span><span style="color:#B392F0;">floor</span><span style="color:#E1E4E8;">(epsilon </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> maxValue </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> n));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> scaledValues</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> values.</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">v</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">floor</span><span style="color:#E1E4E8;">(v </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> scale));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 使用动态规划求解缩放后的问题</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#B392F0;"> knapsackDP</span><span style="color:#E1E4E8;">(weights, scaledValues, capacity)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">solution</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> ({</span></span>
<span class="line"><span style="color:#F97583;">            ...</span><span style="color:#E1E4E8;">solution,</span></span>
<span class="line"><span style="color:#E1E4E8;">            value: solution.value </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> scale </span><span style="color:#6A737D;">// 还原实际价值</span></span>
<span class="line"><span style="color:#E1E4E8;">        }));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="实际应用优化" tabindex="-1">实际应用优化 <a class="header-anchor" href="#实际应用优化" aria-label="Permalink to &quot;实际应用优化&quot;">​</a></h2><h3 id="缓存友好的实现" tabindex="-1">缓存友好的实现 <a class="header-anchor" href="#缓存友好的实现" aria-label="Permalink to &quot;缓存友好的实现&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 优化的贪心集合覆盖</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> optimizedSetCover</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">universe</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">subsets</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> elements</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Set</span><span style="color:#E1E4E8;">(universe);</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> selectedSubsets</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 预计算覆盖信息</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> coverageInfo</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> subsets.</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">subset</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> ({</span></span>
<span class="line"><span style="color:#E1E4E8;">        subset,</span></span>
<span class="line"><span style="color:#E1E4E8;">        elements: </span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> Set</span><span style="color:#E1E4E8;">(subset),</span></span>
<span class="line"><span style="color:#E1E4E8;">        count: subset.</span><span style="color:#79B8FF;">length</span></span>
<span class="line"><span style="color:#E1E4E8;">    }));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    while</span><span style="color:#E1E4E8;"> (elements.size </span><span style="color:#F97583;">&gt;</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        let</span><span style="color:#E1E4E8;"> bestIndex </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> -</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">        let</span><span style="color:#E1E4E8;"> bestCount </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 并行计算覆盖数</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> coverageInfo.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">coverageInfo[i]) </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span></span>
<span class="line"><span style="color:#F97583;">            let</span><span style="color:#E1E4E8;"> count </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">            for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> element</span><span style="color:#F97583;"> of</span><span style="color:#E1E4E8;"> coverageInfo[i].elements) {</span></span>
<span class="line"><span style="color:#F97583;">                if</span><span style="color:#E1E4E8;"> (elements.</span><span style="color:#B392F0;">has</span><span style="color:#E1E4E8;">(element)) count</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (count </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> bestCount) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                bestCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> count;</span></span>
<span class="line"><span style="color:#E1E4E8;">                bestIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (bestIndex </span><span style="color:#F97583;">===</span><span style="color:#F97583;"> -</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        selectedSubsets.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(coverageInfo[bestIndex].subset);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 批量移除元素</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> element</span><span style="color:#F97583;"> of</span><span style="color:#E1E4E8;"> coverageInfo[bestIndex].elements) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            elements.</span><span style="color:#B392F0;">delete</span><span style="color:#E1E4E8;">(element);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        coverageInfo[bestIndex] </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> selectedSubsets;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="流式处理版本" tabindex="-1">流式处理版本 <a class="header-anchor" href="#流式处理版本" aria-label="Permalink to &quot;流式处理版本&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 流式贪心集合覆盖</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function*</span><span style="color:#B392F0;"> streamingSetCover</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">subsetsStream</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> uncovered</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Set</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> bestCurrent </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> bestScore </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> subset</span><span style="color:#F97583;"> of</span><span style="color:#E1E4E8;"> subsetsStream) {</span></span>
<span class="line"><span style="color:#6A737D;">        // 计算新子集的覆盖分数</span></span>
<span class="line"><span style="color:#F97583;">        let</span><span style="color:#E1E4E8;"> score </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">        for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> element</span><span style="color:#F97583;"> of</span><span style="color:#E1E4E8;"> subset) {</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">uncovered.</span><span style="color:#B392F0;">has</span><span style="color:#E1E4E8;">(element)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                uncovered.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(element);</span></span>
<span class="line"><span style="color:#E1E4E8;">                score</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 更新最佳候选</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">bestCurrent </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> score </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> bestScore) {</span></span>
<span class="line"><span style="color:#F97583;">            if</span><span style="color:#E1E4E8;"> (bestCurrent) {</span></span>
<span class="line"><span style="color:#F97583;">                yield</span><span style="color:#E1E4E8;"> bestCurrent; </span><span style="color:#6A737D;">// 输出之前的最佳子集</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            bestCurrent </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> subset;</span></span>
<span class="line"><span style="color:#E1E4E8;">            bestScore </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> score;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#6A737D;">        // 如果当前子集明显更好，立即输出</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (score </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> bestScore </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">            yield</span><span style="color:#E1E4E8;"> subset;</span></span>
<span class="line"><span style="color:#E1E4E8;">            bestCurrent </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            bestScore </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (bestCurrent) {</span></span>
<span class="line"><span style="color:#F97583;">        yield</span><span style="color:#E1E4E8;"> bestCurrent;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div>`,40)])])}const d=n(o,[["render",e]]);export{F as __pageData,d as default};
