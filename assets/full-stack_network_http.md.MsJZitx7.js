import{_ as n,c as s,o as l,b as e}from"./chunks/framework.CMLuPXeo.js";const u=JSON.parse('{"title":"HTTP","description":"","frontmatter":{},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"历史","slug":"历史","link":"#历史","children":[]},{"level":2,"title":"版本概述","slug":"版本概述","link":"#版本概述","children":[]},{"level":2,"title":"核心特点","slug":"核心特点","link":"#核心特点","children":[{"level":3,"title":"无状态性","slug":"无状态性","link":"#无状态性","children":[]},{"level":3,"title":"请求-响应模型","slug":"请求-响应模型","link":"#请求-响应模型","children":[]},{"level":3,"title":"可缓存性","slug":"可缓存性","link":"#可缓存性","children":[]},{"level":3,"title":"方法多样性","slug":"方法多样性","link":"#方法多样性","children":[]},{"level":3,"title":"文本到二进制演进","slug":"文本到二进制演进","link":"#文本到二进制演进","children":[]},{"level":3,"title":"灵活性","slug":"灵活性","link":"#灵活性","children":[]},{"level":3,"title":"安全增强","slug":"安全增强","link":"#安全增强","children":[]}]},{"level":2,"title":"工作原理","slug":"工作原理","link":"#工作原理","children":[]},{"level":2,"title":"请求格式","slug":"请求格式","link":"#请求格式","children":[]},{"level":2,"title":"响应格式","slug":"响应格式","link":"#响应格式","children":[]},{"level":2,"title":"状态码","slug":"状态码","link":"#状态码","children":[]},{"level":2,"title":"缓存机制","slug":"缓存机制","link":"#缓存机制","children":[]},{"level":2,"title":"安全考虑","slug":"安全考虑","link":"#安全考虑","children":[]}],"relativePath":"full-stack/network/http.md","filePath":"full-stack/network/http.md"}'),t={name:"full-stack/network/http.md"};function i(p,a,o,c,d,r){return l(),s("div",null,[...a[0]||(a[0]=[e(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /full-stack/network/http.md for this page in Markdown format</div><h1 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h1><h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><p>HTTP (Hypertext Transfer Protocol) 是一种应用层协议，用于在万维网上传输超文本数据。它基于客户端-服务器模型，通过请求和响应交换信息，支撑着网页浏览、API 调用等互联网应用。HTTP 设计简单、灵活，且独立于底层传输协议 (如 TCP)，但随着互联网发展，其版本不断演进以提升性能和安全。</p><h2 id="历史" tabindex="-1">历史 <a class="header-anchor" href="#历史" aria-label="Permalink to &quot;历史&quot;">​</a></h2><p>HTTP 由蒂姆·伯纳斯-李于1989年提出，最初版本 HTTP/0.9 仅支持 GET 方法，用于获取纯文本资源。1996年，HTTP/1.0 引入状态码、头部字段和多方法支持，但每个请求需新建连接，效率低。HTTP/1.1 在1997年标准化，添加持久连接、管道化和缓存机制，成为多年主流。2015年，HTTP/2 推出，采用二进制分帧和多路复用，大幅提升性能。2022年，HTTP/3 基于 QUIC 协议，进一步优化延迟和可靠性。</p><h2 id="版本概述" tabindex="-1">版本概述 <a class="header-anchor" href="#版本概述" aria-label="Permalink to &quot;版本概述&quot;">​</a></h2><ul><li><strong>HTTP/0.9</strong>：极简协议，只支持 GET，无头部。</li><li><strong>HTTP/1.0</strong>：添加方法 (如 POST)、状态码和头部，但连接不持久。</li><li><strong>HTTP/1.1</strong>：引入持久连接、管道化、缓存控制和 Host 头部，解决 1.0 的瓶颈。</li><li><strong>HTTP/2</strong>：二进制协议，支持多路复用、头部压缩和服务器推送，减少延迟。</li><li><strong>HTTP/3</strong>：基于 UDP 的 QUIC 协议，内置加密，避免队头阻塞，提升移动网络性能。</li></ul><h2 id="核心特点" tabindex="-1">核心特点 <a class="header-anchor" href="#核心特点" aria-label="Permalink to &quot;核心特点&quot;">​</a></h2><h3 id="无状态性" tabindex="-1">无状态性 <a class="header-anchor" href="#无状态性" aria-label="Permalink to &quot;无状态性&quot;">​</a></h3><p>HTTP 是无状态协议：每个请求独立，服务器不保存客户端上下文。这简化了服务器设计，但需依赖 Cookie 或 Session 管理状态。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>客户端请求1 -&gt; 服务器处理 -&gt; 响应</span></span>
<span class="line"><span>客户端请求2 -&gt; 服务器处理 -&gt; 响应（无记忆前请求）</span></span></code></pre></div><p>优点：可扩展性强；缺点：需额外机制 (如令牌) 维持会话。</p><h3 id="请求-响应模型" tabindex="-1">请求-响应模型 <a class="header-anchor" href="#请求-响应模型" aria-label="Permalink to &quot;请求-响应模型&quot;">​</a></h3><p>客户端发送请求，服务器返回响应，形成典型循环。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>客户端: [请求方法] [URL] [协议版本]</span></span>
<span class="line"><span>         [头部字段]</span></span>
<span class="line"><span>         [可选消息体]</span></span>
<span class="line"><span>服务器: [协议版本] [状态码] [原因短语]</span></span>
<span class="line"><span>         [头部字段]</span></span>
<span class="line"><span>         [消息体]</span></span></code></pre></div><p>例如，浏览器请求页面，服务器返回 HTML。</p><h3 id="可缓存性" tabindex="-1">可缓存性 <a class="header-anchor" href="#可缓存性" aria-label="Permalink to &quot;可缓存性&quot;">​</a></h3><p>HTTP 响应可被缓存 (客户端、代理或服务器)，减少重复请求，提升性能。通过头部字段 (如 Cache-Control、ETag) 控制缓存策略。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>请求 -&gt; 检查缓存 -&gt; 命中则返回缓存数据，否则转发请求 -&gt; 服务器响应 -&gt; 更新缓存</span></span></code></pre></div><p>这降低带宽使用和延迟，尤其适用于静态资源。</p><h3 id="方法多样性" tabindex="-1">方法多样性 <a class="header-anchor" href="#方法多样性" aria-label="Permalink to &quot;方法多样性&quot;">​</a></h3><p>HTTP 定义多种请求方法，指示操作意图：</p><ul><li>GET：获取资源 (安全、幂等)。</li><li>POST：提交数据 (非幂等，如创建资源)。</li><li>PUT：更新资源 (幂等)。</li><li>DELETE：删除资源 (幂等)。</li><li>HEAD：获取头部，无体。</li><li>OPTIONS：查询服务器支持方法。 这些方法支持 RESTful 架构，使 API 设计清晰。</li></ul><h3 id="文本到二进制演进" tabindex="-1">文本到二进制演进 <a class="header-anchor" href="#文本到二进制演进" aria-label="Permalink to &quot;文本到二进制演进&quot;">​</a></h3><p>早期 HTTP 基于文本，易调试但效率低。HTTP/2 转为二进制分帧，减少解析开销，支持多路复用：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP/1.1: 文本流，请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2（可能阻塞）</span></span>
<span class="line"><span>HTTP/2: 二进制帧，多个请求/响应交错传输，共享连接</span></span></code></pre></div><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>客户端: 帧[流1请求] + 帧[流2请求] -&gt; 服务器</span></span>
<span class="line"><span>服务器: 帧[流1响应] + 帧[流2响应] -&gt; 客户端</span></span></code></pre></div><p>这解决队头阻塞，提升并发性能。</p><h3 id="灵活性" tabindex="-1">灵活性 <a class="header-anchor" href="#灵活性" aria-label="Permalink to &quot;灵活性&quot;">​</a></h3><p>HTTP 头部字段可扩展，支持自定义元数据 (如 User-Agent、Content-Type)，适应各种应用场景。消息体格式不限 (HTML、JSON、二进制)，与 MIME 类型结合。</p><h3 id="安全增强" tabindex="-1">安全增强 <a class="header-anchor" href="#安全增强" aria-label="Permalink to &quot;安全增强&quot;">​</a></h3><p>通过 HTTPS (HTTP over TLS) 加密传输，防止窃听和篡改。HTTP/2 和 HTTP/3 内置安全特性，如强制 TLS 和 QUIC 的加密。</p><h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h2><p>HTTP 通常运行在 TCP 之上 (HTTP/3 用 UDP)，客户端 (如浏览器) 发起连接，发送请求，服务器处理并返回响应。过程如下：</p><ol><li>解析 URL，提取协议、主机和路径。</li><li>建立传输层连接 (如 TCP 三次握手)。</li><li>发送 HTTP 请求。</li><li>服务器处理请求，访问资源。</li><li>返回 HTTP 响应。</li><li>客户端解析响应，渲染或处理数据。</li><li>连接可能关闭或重用 (持久连接)。</li></ol><p>示例流程：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>客户端 -&gt; [TCP连接建立] -&gt; 发送请求 -&gt; 服务器处理 -&gt; 返回响应 -&gt; [连接关闭/保持]</span></span></code></pre></div><p>在 HTTP/1.1 中，连接可重用；HTTP/2 中，多路复用允许并行流。</p><h2 id="请求格式" tabindex="-1">请求格式 <a class="header-anchor" href="#请求格式" aria-label="Permalink to &quot;请求格式&quot;">​</a></h2><p>HTTP 请求由起始行、头部和可选消息体组成。</p><ul><li>起始行：方法、请求 URL、协议版本 (如 <code>GET /index.html HTTP/1.1</code>)。</li><li>头部：键值对，如 <code>Host: www.example.com</code>、<code>User-Agent: Mozilla/5.0</code>。</li><li>消息体：用于 POST 或 PUT，包含数据。</li></ul><p>文本示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>GET /api/data HTTP/1.1</span></span>
<span class="line"><span>Host: example.com</span></span>
<span class="line"><span>Accept: application/json</span></span>
<span class="line"><span>（空行）</span></span>
<span class="line"><span>（无消息体）</span></span></code></pre></div><p>或 POST 示例：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>POST /submit HTTP/1.1</span></span>
<span class="line"><span>Host: example.com</span></span>
<span class="line"><span>Content-Type: application/x-www-form-urlencoded</span></span>
<span class="line"><span>Content-Length: 15</span></span>
<span class="line"><span></span></span>
<span class="line"><span>name=John&amp;age=30</span></span></code></pre></div><h2 id="响应格式" tabindex="-1">响应格式 <a class="header-anchor" href="#响应格式" aria-label="Permalink to &quot;响应格式&quot;">​</a></h2><p>HTTP 响应包括状态行、头部和可选消息体。</p><ul><li>状态行：协议版本、状态码、原因短语 (如 <code>HTTP/1.1 200 OK</code>)。</li><li>头部：如 <code>Content-Type: text/html</code>、<code>Cache-Control: max-age=3600</code>。</li><li>消息体：资源数据或错误信息。</li></ul><p>文本示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP/1.1 200 OK</span></span>
<span class="line"><span>Content-Type: text/html</span></span>
<span class="line"><span>Content-Length: 1234</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;html&gt;...&lt;/html&gt;</span></span></code></pre></div><p>或错误响应：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP/1.1 404 Not Found</span></span>
<span class="line"><span>Content-Type: text/plain</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Resource not found.</span></span></code></pre></div><h2 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-label="Permalink to &quot;状态码&quot;">​</a></h2><p>状态码表示请求结果，分五类：</p><ul><li>1xx：信息性 (如 100 Continue)。</li><li>2xx：成功 (如 200 OK、201 Created)。</li><li>3xx：重定向 (如 301 Moved Permanently、304 Not Modified)。</li><li>4xx：客户端错误 (如 400 Bad Request、404 Not Found)。</li><li>5xx：服务器错误 (如 500 Internal Server Error)。</li></ul><p>常见代码示例：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>200: 请求成功</span></span>
<span class="line"><span>404: 资源未找到</span></span>
<span class="line"><span>500: 服务器内部错误</span></span></code></pre></div><p>这些代码帮助客户端处理响应，结合头部实现缓存和重定向。</p><h2 id="缓存机制" tabindex="-1">缓存机制 <a class="header-anchor" href="#缓存机制" aria-label="Permalink to &quot;缓存机制&quot;">​</a></h2><p>HTTP 缓存通过头部字段控制，减少网络流量。例如：</p><ul><li><code>Cache-Control: max-age=3600</code>：资源缓存 1 小时。</li><li><code>ETag: &quot;abc123&quot;</code>：资源标识，用于验证。 流程：</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>客户端请求 -&gt; 检查本地缓存 -&gt; 如果新鲜，直接使用；否则发送条件请求（If-None-Match） -&gt; 服务器返回304或新数据</span></span></code></pre></div><p>这提升用户体验，尤其在高延迟网络中。</p><h2 id="安全考虑" tabindex="-1">安全考虑 <a class="header-anchor" href="#安全考虑" aria-label="Permalink to &quot;安全考虑&quot;">​</a></h2><p>HTTP 默认不加密，易受中间人攻击。HTTPS 通过 TLS/SSL 加密数据，确保机密性和完整性。示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP: 明文传输 -&gt; 风险</span></span>
<span class="line"><span>HTTPS: [TLS握手] -&gt; 加密通道 -&gt; 安全传输</span></span></code></pre></div><p>现代 HTTP 版本推动全站 HTTPS，HTTP/3 的 QUIC 内置加密，进一步强化安全。</p>`,69)])])}const T=n(t,[["render",i]]);export{u as __pageData,T as default};
