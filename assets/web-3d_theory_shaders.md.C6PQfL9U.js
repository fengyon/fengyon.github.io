import{_ as a,c as n,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const d=JSON.parse('{"title":"着色器基础","description":"","frontmatter":{},"headers":[{"level":2,"title":"着色器概述","slug":"着色器概述","link":"#着色器概述","children":[]},{"level":2,"title":"GLSL 语言基础","slug":"glsl-语言基础","link":"#glsl-语言基础","children":[]},{"level":2,"title":"顶点着色器","slug":"顶点着色器","link":"#顶点着色器","children":[]},{"level":2,"title":"片段着色器","slug":"片段着色器","link":"#片段着色器","children":[]},{"level":2,"title":"着色器变量限定符","slug":"着色器变量限定符","link":"#着色器变量限定符","children":[]},{"level":2,"title":"向量和矩阵运算","slug":"向量和矩阵运算","link":"#向量和矩阵运算","children":[]},{"level":2,"title":"纹理采样","slug":"纹理采样","link":"#纹理采样","children":[]},{"level":2,"title":"光照计算","slug":"光照计算","link":"#光照计算","children":[]},{"level":2,"title":"着色器程序管理","slug":"着色器程序管理","link":"#着色器程序管理","children":[]},{"level":2,"title":"属性与统一变量","slug":"属性与统一变量","link":"#属性与统一变量","children":[]},{"level":2,"title":"着色器调试技巧","slug":"着色器调试技巧","link":"#着色器调试技巧","children":[]}],"relativePath":"web-3d/theory/shaders.md","filePath":"web-3d/theory/shaders.md"}'),o={name:"web-3d/theory/shaders.md"};function e(c,s,t,r,i,E){return l(),n("div",null,[...s[0]||(s[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /web-3d/theory/shaders.md for this page in Markdown format</div><h1 id="着色器基础" tabindex="-1">着色器基础 <a class="header-anchor" href="#着色器基础" aria-label="Permalink to &quot;着色器基础&quot;">​</a></h1><p>着色器是运行在 GPU 上的特殊程序，用于控制 3D 图形的渲染过程。在 Web 3D 开发中，着色器是实现各种视觉效果的核心技术，从简单的颜色填充到复杂的光照和材质都需要通过着色器编程来实现。</p><h2 id="着色器概述" tabindex="-1">着色器概述 <a class="header-anchor" href="#着色器概述" aria-label="Permalink to &quot;着色器概述&quot;">​</a></h2><p>着色器是使用 GLSL (OpenGL Shading Language) 编写的小程序，在图形渲染管线的特定阶段执行。现代图形管线主要包含顶点着色器和片段着色器两个可编程阶段。</p><p>特点：</p><ul><li>专为并行处理设计，同时处理大量数据</li><li>直接控制图形硬件的渲染行为</li><li>提供硬件加速的数学运算</li></ul><p>示意图 (着色器在渲染管线中的位置)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>顶点数据 → 顶点着色器 → 图元组装 → 光栅化 → 片段着色器 → 输出合并</span></span>
<span class="line"><span>              ↓                        ↓</span></span>
<span class="line"><span>         处理每个顶点            处理每个片段</span></span></code></pre></div><h2 id="glsl-语言基础" tabindex="-1">GLSL 语言基础 <a class="header-anchor" href="#glsl-语言基础" aria-label="Permalink to &quot;GLSL 语言基础&quot;">​</a></h2><p>GLSL 是类 C 的着色器编程语言，具有严格的类型系统和图形专用的数据类型。语法与 C 语言相似，但包含许多图形学特有的内置变量和函数。</p><p>特点：</p><ul><li>强类型语言，支持向量和矩阵运算</li><li>包含图形专用的内置变量 (如 gl_Position)</li><li>编译时类型检查，运行时高效执行</li></ul><p>基本数据类型：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">float</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">bool</span><span style="color:#6A737D;">        // 标量类型</span></span>
<span class="line"><span style="color:#F97583;">vec2</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">vec4</span><span style="color:#6A737D;">        // 浮点向量</span></span>
<span class="line"><span style="color:#F97583;">mat2</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">mat3</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">mat4</span><span style="color:#6A737D;">        // 矩阵类型</span></span>
<span class="line"><span style="color:#F97583;">sampler2D</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">samplerCube</span><span style="color:#6A737D;">  // 纹理采样器</span></span></code></pre></div><h2 id="顶点着色器" tabindex="-1">顶点着色器 <a class="header-anchor" href="#顶点着色器" aria-label="Permalink to &quot;顶点着色器&quot;">​</a></h2><p>顶点着色器是渲染管线的第一个可编程阶段，负责处理每个顶点的变换和属性计算。每个顶点独立执行一次顶点着色器。</p><p>特点：</p><ul><li>必须输出裁剪空间坐标到 gl_Position</li><li>可以计算和传递 varying 变量到片段着色器</li><li>常用于坐标变换和逐顶点光照</li></ul><p>示意图 (顶点着色器处理)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>输入属性 → 顶点着色器 → 输出变量</span></span>
<span class="line"><span>位置、法线     ↓       裁剪坐标</span></span>
<span class="line"><span>         模型视图投影变换</span></span>
<span class="line"><span>         法线变换</span></span>
<span class="line"><span>         纹理坐标传递</span></span></code></pre></div><p>示例顶点着色器结构：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 输入属性</span></span>
<span class="line"><span style="color:#F97583;">attribute</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> position;</span></span>
<span class="line"><span style="color:#F97583;">attribute</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> normal;</span></span>
<span class="line"><span style="color:#F97583;">attribute</span><span style="color:#F97583;"> vec2</span><span style="color:#E1E4E8;"> texCoord;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 统一变量</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> mat4</span><span style="color:#E1E4E8;"> modelViewProjection;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 输出到片段着色器</span></span>
<span class="line"><span style="color:#F97583;">varying</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> vNormal;</span></span>
<span class="line"><span style="color:#F97583;">varying</span><span style="color:#F97583;"> vec2</span><span style="color:#E1E4E8;"> vTexCoord;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    gl_Position </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> modelViewProjection </span><span style="color:#F97583;">*</span><span style="color:#B392F0;"> vec4</span><span style="color:#E1E4E8;">(position, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    vNormal </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> normal;</span></span>
<span class="line"><span style="color:#E1E4E8;">    vTexCoord </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> texCoord;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="片段着色器" tabindex="-1">片段着色器 <a class="header-anchor" href="#片段着色器" aria-label="Permalink to &quot;片段着色器&quot;">​</a></h2><p>片段着色器处理每个像素片段的颜色计算，决定最终输出到屏幕的颜色。这是实现大多数视觉效果的关键阶段。</p><p>特点：</p><ul><li>每个可见片段执行一次</li><li>必须输出颜色值 (gl_FragColor 或 out 变量)</li><li>可以进行纹理采样、光照计算、材质处理</li></ul><p>示意图 (片段着色器处理)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>输入变量 → 片段着色器 → 输出颜色</span></span>
<span class="line"><span>法线、UV     ↓         RGBA颜色</span></span>
<span class="line"><span>         纹理采样</span></span>
<span class="line"><span>         光照计算</span></span>
<span class="line"><span>         颜色混合</span></span></code></pre></div><p>示例片段着色器结构：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 从顶点着色器输入</span></span>
<span class="line"><span style="color:#F97583;">varying</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> vNormal;</span></span>
<span class="line"><span style="color:#F97583;">varying</span><span style="color:#F97583;"> vec2</span><span style="color:#E1E4E8;"> vTexCoord;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 统一变量</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> sampler2D</span><span style="color:#E1E4E8;"> diffuseMap;</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> lightDirection;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 纹理采样</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec4 diffuseColor </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> texture2D</span><span style="color:#E1E4E8;">(diffuseMap, vTexCoord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 简单光照</span></span>
<span class="line"><span style="color:#F97583;">    float</span><span style="color:#E1E4E8;"> intensity </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> max</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">dot</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">normalize</span><span style="color:#E1E4E8;">(vNormal), lightDirection), </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 输出颜色</span></span>
<span class="line"><span style="color:#E1E4E8;">    gl_FragColor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> diffuseColor </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> intensity;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="着色器变量限定符" tabindex="-1">着色器变量限定符 <a class="header-anchor" href="#着色器变量限定符" aria-label="Permalink to &quot;着色器变量限定符&quot;">​</a></h2><p>GLSL 使用变量限定符定义数据的流向和行为。主要限定符包括 attribute、uniform、varying 和 const。</p><p>特点：</p><ul><li>attribute：每个顶点不同的输入数据</li><li>uniform：所有顶点/片段共享的常量</li><li>varying：从顶点到片段传递的插值数据</li></ul><p>示意图 (变量数据流)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>CPU → uniform → 顶点着色器 → varying → 片段着色器</span></span>
<span class="line"><span>     ↓</span></span>
<span class="line"><span>   attribute → 顶点着色器</span></span></code></pre></div><h2 id="向量和矩阵运算" tabindex="-1">向量和矩阵运算 <a class="header-anchor" href="#向量和矩阵运算" aria-label="Permalink to &quot;向量和矩阵运算&quot;">​</a></h2><p>GLSL 内置了丰富的向量和矩阵运算支持，这些操作在硬件层面高度优化，非常适合图形计算。</p><p>特点：</p><ul><li>分量访问 (。x， 。y， 。z， 。w 或。r， 。g， 。b， 。a)</li><li>逐分量运算和向量化函数</li><li>矩阵乘法符合线性代数规则</li></ul><p>向量运算示例：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">4.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">5.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">6.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 逐分量加法</span></span>
<span class="line"><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b;</span><span style="color:#6A737D;">  // (5.0, 7.0, 9.0)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 点积</span></span>
<span class="line"><span style="color:#F97583;">float</span><span style="color:#E1E4E8;"> dotProduct </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> dot</span><span style="color:#E1E4E8;">(a, b);</span><span style="color:#6A737D;">  // 32.0</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 叉积</span></span>
<span class="line"><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;"> crossProduct </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> cross</span><span style="color:#E1E4E8;">(a, b);</span><span style="color:#6A737D;">  // (-3.0, 6.0, -3.0)</span></span></code></pre></div><p>矩阵变换示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>局部坐标 → 模型矩阵 → 世界坐标 → 视图矩阵 → 视图坐标</span></span>
<span class="line"><span>  (x,y,z)    ↓        (x&#39;,y&#39;,z&#39;)   ↓       (x&#39;&#39;,y&#39;&#39;,z&#39;&#39;)</span></span>
<span class="line"><span>        mat4 model        mat4 view</span></span></code></pre></div><h2 id="纹理采样" tabindex="-1">纹理采样 <a class="header-anchor" href="#纹理采样" aria-label="Permalink to &quot;纹理采样&quot;">​</a></h2><p>纹理采样是片段着色器中的重要操作，通过纹理坐标从纹理图像中获取颜色值。支持多种滤波和寻址模式。</p><p>特点：</p><ul><li>使用 sampler2D 类型和 texture2D 函数</li><li>纹理坐标通常范围 [0,1]</li><li>支持多种滤波模式 (最近邻、线性)</li></ul><p>纹理采样示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>纹理坐标 → 纹理采样 → 颜色值</span></span>
<span class="line"><span>  (u,v)       ↓        (r,g,b,a)</span></span>
<span class="line"><span>          纹理图像</span></span>
<span class="line"><span>          +-------+</span></span>
<span class="line"><span>          |#######|</span></span>
<span class="line"><span>          |#######|</span></span>
<span class="line"><span>          +-------+</span></span></code></pre></div><p>纹理采样代码：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> sampler2D</span><span style="color:#E1E4E8;"> diffuseTexture;</span></span>
<span class="line"><span style="color:#F97583;">varying</span><span style="color:#F97583;"> vec2</span><span style="color:#E1E4E8;"> vTexCoord;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 基本纹理采样</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec4 color </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> texture2D</span><span style="color:#E1E4E8;">(diffuseTexture, vTexCoord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 带偏移的采样</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec4 offsetColor </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> texture2D</span><span style="color:#E1E4E8;">(diffuseTexture, vTexCoord </span><span style="color:#F97583;">+</span><span style="color:#B392F0;"> vec2</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0.01</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    gl_FragColor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> color;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="光照计算" tabindex="-1">光照计算 <a class="header-anchor" href="#光照计算" aria-label="Permalink to &quot;光照计算&quot;">​</a></h2><p>着色器中的光照计算模拟光线与表面的交互，常见模型包括漫反射、镜面反射和环境光。</p><p>特点：</p><ul><li>漫反射：Lambert 余弦定律</li><li>镜面反射：Phong 或 Blinn-Phong 模型</li><li>可以逐顶点或逐片段计算</li></ul><p>漫反射示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>表面法线  光线方向</span></span>
<span class="line"><span>   ↑       ↗</span></span>
<span class="line"><span>   |      /</span></span>
<span class="line"><span>   |     /</span></span>
<span class="line"><span>   |    /</span></span>
<span class="line"><span>   | θ /</span></span>
<span class="line"><span>表面-------</span></span>
<span class="line"><span>cos(θ) = 点积(法线, 光线)</span></span></code></pre></div><p>光照计算示例：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">varying</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> vNormal;</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> lightDirection;</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> lightColor;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 归一化法线</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 normal </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> normalize</span><span style="color:#E1E4E8;">(vNormal);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 漫反射强度（Lambert）</span></span>
<span class="line"><span style="color:#F97583;">    float</span><span style="color:#E1E4E8;"> diffuse </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> max</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">dot</span><span style="color:#E1E4E8;">(normal, lightDirection), </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 最终颜色</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 color </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> lightColor </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> diffuse;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    gl_FragColor </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> vec4</span><span style="color:#E1E4E8;">(color, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="着色器程序管理" tabindex="-1">着色器程序管理 <a class="header-anchor" href="#着色器程序管理" aria-label="Permalink to &quot;着色器程序管理&quot;">​</a></h2><p>在 WebGL 中，着色器需要编译、链接成程序对象后才能使用。这个过程包括源代码编译、错误检查和程序链接。</p><p>特点：</p><ul><li>顶点和片段着色器必须成对使用</li><li>编译错误需要手动检查和处理</li><li>程序对象可以重复使用</li></ul><p>示意图 (着色器程序创建流程)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>创建着色器 → 指定源码 → 编译 → 检查错误</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>创建程序 → 附加着色器 → 链接 → 检查错误 → 使用程序</span></span></code></pre></div><p>WebGL 着色器管理代码结构：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建着色器程序</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> createShaderProgram</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">gl</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">vertexSrc</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">fragmentSrc</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> vertexShader</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> compileShader</span><span style="color:#E1E4E8;">(gl, gl.</span><span style="color:#79B8FF;">VERTEX_SHADER</span><span style="color:#E1E4E8;">, vertexSrc);</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> fragmentShader</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> compileShader</span><span style="color:#E1E4E8;">(gl, gl.</span><span style="color:#79B8FF;">FRAGMENT_SHADER</span><span style="color:#E1E4E8;">, fragmentSrc);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> program</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> gl.</span><span style="color:#B392F0;">createProgram</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    gl.</span><span style="color:#B392F0;">attachShader</span><span style="color:#E1E4E8;">(program, vertexShader);</span></span>
<span class="line"><span style="color:#E1E4E8;">    gl.</span><span style="color:#B392F0;">attachShader</span><span style="color:#E1E4E8;">(program, fragmentShader);</span></span>
<span class="line"><span style="color:#E1E4E8;">    gl.</span><span style="color:#B392F0;">linkProgram</span><span style="color:#E1E4E8;">(program);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">getProgramParameter</span><span style="color:#E1E4E8;">(program, gl.</span><span style="color:#79B8FF;">LINK_STATUS</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;链接错误:&#39;</span><span style="color:#E1E4E8;">, gl.</span><span style="color:#B392F0;">getProgramInfoLog</span><span style="color:#E1E4E8;">(program));</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> program;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="属性与统一变量" tabindex="-1">属性与统一变量 <a class="header-anchor" href="#属性与统一变量" aria-label="Permalink to &quot;属性与统一变量&quot;">​</a></h2><p>属性 (attribute) 和统一变量 (uniform) 是 CPU 与 GPU 通信的主要方式，用于传递顶点数据和渲染参数。</p><p>特点：</p><ul><li>attribute：每个顶点不同的数据 (位置、法线、颜色等)</li><li>uniform：绘制调用中保持不变的数据 (矩阵、颜色、时间等)</li></ul><p>数据传递示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>JavaScript → 缓冲区 → attribute → 顶点着色器</span></span>
<span class="line"><span>         ↓</span></span>
<span class="line"><span>        uniform → 顶点/片段着色器</span></span></code></pre></div><p>属性设置示例：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 设置顶点属性</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> positionLocation</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> gl.</span><span style="color:#B392F0;">getAttribLocation</span><span style="color:#E1E4E8;">(program, </span><span style="color:#9ECBFF;">&#39;position&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">enableVertexAttribArray</span><span style="color:#E1E4E8;">(positionLocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">vertexAttribPointer</span><span style="color:#E1E4E8;">(positionLocation, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, gl.</span><span style="color:#79B8FF;">FLOAT</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 设置统一变量</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> matrixLocation</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> gl.</span><span style="color:#B392F0;">getUniformLocation</span><span style="color:#E1E4E8;">(program, </span><span style="color:#9ECBFF;">&#39;modelViewProjection&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">uniformMatrix4fv</span><span style="color:#E1E4E8;">(matrixLocation, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, matrix);</span></span></code></pre></div><h2 id="着色器调试技巧" tabindex="-1">着色器调试技巧 <a class="header-anchor" href="#着色器调试技巧" aria-label="Permalink to &quot;着色器调试技巧&quot;">​</a></h2><p>着色器调试相对困难，常用的技巧包括使用颜色输出调试、简化测试和逐步完善的方法。</p><p>特点：</p><ul><li>使用颜色编码显示中间值</li><li>从简单着色器开始逐步添加功能</li><li>利用浏览器开发者工具</li></ul><p>调试颜色编码示例：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 用法线作为颜色（调试用）</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 normal </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> normalize</span><span style="color:#E1E4E8;">(vNormal);</span></span>
<span class="line"><span style="color:#E1E4E8;">    gl_FragColor </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> vec4</span><span style="color:#E1E4E8;">(normal </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> 0.5</span><span style="color:#F97583;"> +</span><span style="color:#79B8FF;"> 0.5</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 或用纹理坐标作为颜色</span></span>
<span class="line"><span style="color:#6A737D;">    // gl_FragColor = vec4(vTexCoord, 0.0, 1.0);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>调试示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>正常渲染 → 问题出现 → 简化测试 → 颜色调试 → 定位问题</span></span>
<span class="line"><span>复杂场景    效果异常    简单几何    显示法线     修复代码</span></span></code></pre></div>`,85)])])}const F=a(o,[["render",e]]);export{d as __pageData,F as default};
