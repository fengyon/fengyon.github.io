import{_ as s,c as n,o as l,b as e}from"./chunks/framework.CMLuPXeo.js";const g=JSON.parse('{"title":"WASM 垃圾回收提案","description":"","frontmatter":{},"headers":[{"level":2,"title":"提案背景与意义","slug":"提案背景与意义","link":"#提案背景与意义","children":[]},{"level":2,"title":"核心机制与类型系统","slug":"核心机制与类型系统","link":"#核心机制与类型系统","children":[{"level":3,"title":"类型系统革新","slug":"类型系统革新","link":"#类型系统革新","children":[]},{"level":3,"title":"结构化数据类型","slug":"结构化数据类型","link":"#结构化数据类型","children":[]},{"level":3,"title":"递归类型与等价性处理","slug":"递归类型与等价性处理","link":"#递归类型与等价性处理","children":[]}]},{"level":2,"title":"垃圾回收工作原理","slug":"垃圾回收工作原理","link":"#垃圾回收工作原理","children":[{"level":3,"title":"内存管理模型","slug":"内存管理模型","link":"#内存管理模型","children":[]},{"level":3,"title":"标记-清除算法","slug":"标记-清除算法","link":"#标记-清除算法","children":[]},{"level":3,"title":"类型化引用与安全调用","slug":"类型化引用与安全调用","link":"#类型化引用与安全调用","children":[]}]},{"level":2,"title":"性能优化策略","slug":"性能优化策略","link":"#性能优化策略","children":[{"level":3,"title":"静态类型优势","slug":"静态类型优势","link":"#静态类型优势","children":[]},{"level":3,"title":"规范化技术","slug":"规范化技术","link":"#规范化技术","children":[]},{"level":3,"title":"确定性执行支持","slug":"确定性执行支持","link":"#确定性执行支持","children":[]}]},{"level":2,"title":"与宿主环境集成","slug":"与宿主环境集成","link":"#与宿主环境集成","children":[{"level":3,"title":"JavaScript 交互优化","slug":"javascript-交互优化","link":"#javascript-交互优化","children":[]},{"level":3,"title":"跨语言内存管理","slug":"跨语言内存管理","link":"#跨语言内存管理","children":[]}]},{"level":2,"title":"工具链与生态支持","slug":"工具链与生态支持","link":"#工具链与生态支持","children":[{"level":3,"title":"编译器工具链进展","slug":"编译器工具链进展","link":"#编译器工具链进展","children":[]},{"level":3,"title":"多语言支持","slug":"多语言支持","link":"#多语言支持","children":[]}]},{"level":2,"title":"应用场景与未来展望","slug":"应用场景与未来展望","link":"#应用场景与未来展望","children":[{"level":3,"title":"实际应用场景","slug":"实际应用场景","link":"#实际应用场景","children":[]},{"level":3,"title":"技术展望","slug":"技术展望","link":"#技术展望","children":[]}]}],"relativePath":"leading/webassembly/future.md","filePath":"leading/webassembly/future.md"}'),t={name:"leading/webassembly/future.md"};function o(r,a,p,i,c,d){return l(),n("div",null,[...a[0]||(a[0]=[e(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /leading/webassembly/future.md for this page in Markdown format</div><h1 id="wasm-垃圾回收提案" tabindex="-1">WASM 垃圾回收提案 <a class="header-anchor" href="#wasm-垃圾回收提案" aria-label="Permalink to &quot;WASM 垃圾回收提案&quot;">​</a></h1><h2 id="提案背景与意义" tabindex="-1">提案背景与意义 <a class="header-anchor" href="#提案背景与意义" aria-label="Permalink to &quot;提案背景与意义&quot;">​</a></h2><p>WebAssembly (Wasm) 最初设计为低级的二进制指令格式，主要面向<strong>数值计算密集型任务</strong>，缺乏对高级语言垃圾回收 (GC) 的原生支持。这意味着 Java、C#、Kotlin、Dart、Scala 或 OCaml 等具有垃圾回收机制的语言在编译到 Wasm 时，必须携带自己的 GC 系统，导致<strong>模块体积膨胀</strong>和<strong>性能开销增加</strong>。</p><p>WasmGC 提案通过引入原生垃圾回收机制，旨在为这些<strong>托管语言提供更自然的编译目标</strong>。它使 Wasm 能够更高效地支持高级语言，减少手动内存管理的负担，同时避免通过模拟 GC 带来的性能开销。</p><h2 id="核心机制与类型系统" tabindex="-1">核心机制与类型系统 <a class="header-anchor" href="#核心机制与类型系统" aria-label="Permalink to &quot;核心机制与类型系统&quot;">​</a></h2><h3 id="类型系统革新" tabindex="-1">类型系统革新 <a class="header-anchor" href="#类型系统革新" aria-label="Permalink to &quot;类型系统革新&quot;">​</a></h3><p>WebAssembly 3.0 引入了一套全新的垃圾回收类型系统，建立在两种基本关系之上：</p><ol><li><strong>子类型关系</strong>：使用 <code>(sub [final] [type-id] (...))</code> 语法定义，类似于面向对象编程中的基类-派生类关系。</li><li><strong>类型等价关系</strong>：处理递归类型定义时的复杂等价性判定。</li></ol><p><strong>类型系统示意图：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>类型关系</span></span>
<span class="line"><span>├── 子类型关系 (sub &lt;final&gt; &lt;type-id&gt; ...)</span></span>
<span class="line"><span>└── 类型等价关系</span></span>
<span class="line"><span>    ├── 递归类型块 (rec ...)</span></span>
<span class="line"><span>    ├── 内部引用 → (rec.i) 相对引用</span></span>
<span class="line"><span>    └── 外部引用 → 绝对引用</span></span></code></pre></div><h3 id="结构化数据类型" tabindex="-1">结构化数据类型 <a class="header-anchor" href="#结构化数据类型" aria-label="Permalink to &quot;结构化数据类型&quot;">​</a></h3><p>WasmGC 通过扩展 Wasm 的类型系统和指令集，支持<strong>结构体 (struct)</strong> 和<strong>数组 (array)</strong> 等高级数据类型。这使得编译器可以直接定义数据布局，而由 Wasm 引擎负责内存的分配和回收。</p><p><strong>结构化数据示例：</strong></p><div class="language-wasm"><button title="Copy Code" class="copy"></button><span class="lang">wasm</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">module</span></span>
<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#B392F0;">type</span><span style="color:#79B8FF;"> $Person</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">struct</span></span>
<span class="line"><span style="color:#E1E4E8;">    (</span><span style="color:#B392F0;">field</span><span style="color:#E1E4E8;"> $name (</span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;"> string))</span></span>
<span class="line"><span style="color:#E1E4E8;">    (</span><span style="color:#B392F0;">field</span><span style="color:#E1E4E8;"> $age </span><span style="color:#B392F0;">i32</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  ))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#B392F0;">func</span><span style="color:#B392F0;"> $createPerson</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">param</span><span style="color:#E1E4E8;"> $name (</span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;"> string)) (</span><span style="color:#F97583;">param</span><span style="color:#E1E4E8;"> $age </span><span style="color:#B392F0;">i32</span><span style="color:#E1E4E8;">) (</span><span style="color:#F97583;">result</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;"> $Person))</span></span>
<span class="line"><span style="color:#E1E4E8;">    (struct.new $Person</span></span>
<span class="line"><span style="color:#E1E4E8;">      (</span><span style="color:#79B8FF;">local</span><span style="color:#F97583;">.get</span><span style="color:#E1E4E8;"> $name)</span></span>
<span class="line"><span style="color:#E1E4E8;">      (</span><span style="color:#79B8FF;">local</span><span style="color:#F97583;">.get</span><span style="color:#E1E4E8;"> $age)</span></span>
<span class="line"><span style="color:#E1E4E8;">    )</span></span>
<span class="line"><span style="color:#E1E4E8;">  )</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#B392F0;">func</span><span style="color:#B392F0;"> $getAge</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">param</span><span style="color:#E1E4E8;"> $person (</span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;"> $Person)) (</span><span style="color:#F97583;">result</span><span style="color:#B392F0;"> i32</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    (</span><span style="color:#79B8FF;">struct</span><span style="color:#F97583;">.get</span><span style="color:#E1E4E8;"> $Person $age (</span><span style="color:#79B8FF;">local</span><span style="color:#F97583;">.get</span><span style="color:#E1E4E8;"> $person))</span></span>
<span class="line"><span style="color:#E1E4E8;">  )</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span></span></code></pre></div><p><em>代码来源：</em></p><h3 id="递归类型与等价性处理" tabindex="-1">递归类型与等价性处理 <a class="header-anchor" href="#递归类型与等价性处理" aria-label="Permalink to &quot;递归类型与等价性处理&quot;">​</a></h3><p>递归类型块 <code>(rec ...)</code> 是类型系统的重要特性。在类型检查过程中：</p><ul><li>内部引用会被替换为 <code>(rec.i)</code> 形式的相对引用。</li><li>外部引用则保持为绝对引用。</li><li>类型等价性的判定规则要求：两个类型在各自递归块中的相对引用相同，且所在递归块相等时，它们才等价。</li></ul><h2 id="垃圾回收工作原理" tabindex="-1">垃圾回收工作原理 <a class="header-anchor" href="#垃圾回收工作原理" aria-label="Permalink to &quot;垃圾回收工作原理&quot;">​</a></h2><h3 id="内存管理模型" tabindex="-1">内存管理模型 <a class="header-anchor" href="#内存管理模型" aria-label="Permalink to &quot;内存管理模型&quot;">​</a></h3><p>WasmGC 引入了<strong>自动内存管理</strong>机制，通过垃圾回收算法自动回收无用内存。与传统的线性内存模型不同，GC 内存由 Wasm 运行时自动管理，无需开发者手动分配和释放。</p><p><strong>内存划分示意图：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>WasmGC 内存空间</span></span>
<span class="line"><span>├── 栈内存 (存储局部变量和函数调用上下文)</span></span>
<span class="line"><span>└── 堆内存 (动态分配)</span></span>
<span class="line"><span>    ├── 存活对象 (被根对象或其它对象引用)</span></span>
<span class="line"><span>    └── 垃圾对象 (无法被访问，等待回收)</span></span></code></pre></div><h3 id="标记-清除算法" tabindex="-1">标记-清除算法 <a class="header-anchor" href="#标记-清除算法" aria-label="Permalink to &quot;标记-清除算法&quot;">​</a></h3><p>WasmGC 采用<strong>标记-清除算法</strong>进行垃圾回收。该过程分为两个阶段：</p><ol><li><strong>标记阶段</strong>：遍历所有从<strong>根对象</strong> (如全局变量、当前函数调用栈中的局部变量等) 出发可达的对象，并标记它们为存活。</li><li><strong>清除阶段</strong>：回收所有未被标记的对象占用的内存，并将其返回给空闲内存池。</li></ol><p><strong>对象回收示意图：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>标记前: [对象A]→[对象B]→[对象C]→[对象D]   (根引用A和C)</span></span>
<span class="line"><span>标记后: [对象A*]→[对象B*]  [对象C*]→[对象D]  (*表示存活)</span></span>
<span class="line"><span>清除后: [对象A]→[对象B]  [对象C]          (D被回收)</span></span></code></pre></div><h3 id="类型化引用与安全调用" tabindex="-1">类型化引用与安全调用 <a class="header-anchor" href="#类型化引用与安全调用" aria-label="Permalink to &quot;类型化引用与安全调用&quot;">​</a></h3><p>作为 GC 的基础，Wasm 的类型系统得到了显著增强。<strong>类型化引用</strong>可以精确描述其所指向的堆值的结构，从而避免了运行时的安全检查。通过新的 <code>call_ref</code> 指令，可以实现完全<strong>类型安全且无开销的间接函数调用</strong>。</p><h2 id="性能优化策略" tabindex="-1">性能优化策略 <a class="header-anchor" href="#性能优化策略" aria-label="Permalink to &quot;性能优化策略&quot;">​</a></h2><h3 id="静态类型优势" tabindex="-1">静态类型优势 <a class="header-anchor" href="#静态类型优势" aria-label="Permalink to &quot;静态类型优势&quot;">​</a></h3><p>WasmGC 的设计注重性能，通过<strong>静态类型信息</strong>在编译时已知对象布局，避免运行时类型查询，从而减少 GC 开销。</p><h3 id="规范化技术" tabindex="-1">规范化技术 <a class="header-anchor" href="#规范化技术" aria-label="Permalink to &quot;规范化技术&quot;">​</a></h3><p>为了提高性能，WebAssembly 实现通常采用“<strong>规范化</strong>”技术：</p><ul><li>将所有内部引用替换为 <code>(rec.i)</code> 形式。</li><li>将所有外部引用替换为其指向的规范化类型。</li><li>通过<strong>哈希一致化技术</strong>优化存储。</li><li>在规范化后的类型上，等价性检查简化为指针比较。</li></ul><h3 id="确定性执行支持" tabindex="-1">确定性执行支持 <a class="header-anchor" href="#确定性执行支持" aria-label="Permalink to &quot;确定性执行支持&quot;">​</a></h3><p>为了满足区块链、可重现系统等场景对确定性执行的需求，Wasm 标准定义了<strong>确定性配置文件</strong>。它为浮点数运算和松弛向量指令规定了统一的默认行为，确保了在遵循该配置文件的平台之间，Wasm 程序是完全可移植且可复现的。</p><h2 id="与宿主环境集成" tabindex="-1">与宿主环境集成 <a class="header-anchor" href="#与宿主环境集成" aria-label="Permalink to &quot;与宿主环境集成&quot;">​</a></h2><h3 id="javascript-交互优化" tabindex="-1">JavaScript 交互优化 <a class="header-anchor" href="#javascript-交互优化" aria-label="Permalink to &quot;JavaScript 交互优化&quot;">​</a></h3><p>针对 JavaScript 环境，Wasm 3.0 新增了 <strong>JS 字符串内建函数</strong>。Wasm 模块可以导入一组新的内建函数，用于直接在 Wasm 代码内部操作作为 <code>externref</code> 传入的 JavaScript 字符串，提升了与宿主环境的交互效率。</p><h3 id="跨语言内存管理" tabindex="-1">跨语言内存管理 <a class="header-anchor" href="#跨语言内存管理" aria-label="Permalink to &quot;跨语言内存管理&quot;">​</a></h3><p>WasmGC 允许与 JavaScript 的 GC 协作，避免<strong>跨语言内存泄漏</strong>。通过定义清晰的接口和引用规则，确保 Wasm 模块与宿主环境之间的对象引用得到正确管理。</p><p><strong>跨语言引用示意图：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>JavaScript 环境</span></span>
<span class="line"><span>    ↓ 引用</span></span>
<span class="line"><span>WasmGC 对象 ←→ 宿主环境 GC</span></span>
<span class="line"><span>    ↓ 协作</span></span>
<span class="line"><span>统一的内存管理</span></span></code></pre></div><h2 id="工具链与生态支持" tabindex="-1">工具链与生态支持 <a class="header-anchor" href="#工具链与生态支持" aria-label="Permalink to &quot;工具链与生态支持&quot;">​</a></h2><h3 id="编译器工具链进展" tabindex="-1">编译器工具链进展 <a class="header-anchor" href="#编译器工具链进展" aria-label="Permalink to &quot;编译器工具链进展&quot;">​</a></h3><p>WebAssembly 生态系统正在积极适应 GC 提案。<strong>Wasm-tools</strong> 项目在 1.233.0 版本增强了对组件模型中更多类型的 GC 支持，为<strong>变体、选项和结果</strong>等高级类型添加了 GC 降低支持。</p><p>同时，新的 <strong>MLIR-based Wasm 编译器管道</strong>解决了现有编译器对高级功能支持不足的问题。通过引入 MLIR Wasm 方言，支持更高效地编译具有高级语言特性的代码。</p><h3 id="多语言支持" tabindex="-1">多语言支持 <a class="header-anchor" href="#多语言支持" aria-label="Permalink to &quot;多语言支持&quot;">​</a></h3><p>WasmGC 使多种编程语言能够更有效地编译到 WebAssembly：</p><ul><li><strong>Java/Kotlin</strong>：无需携带完整的 JVM 运行时。</li><li><strong>OCaml</strong>：利用 WasmGC 的类型系统表达 OCaml 的 ADT。</li><li><strong>Dart</strong>：减少生成的 Wasm 模块大小。</li><li><strong>Python</strong>：通过 Pyodide 项目在浏览器中高效运行。</li></ul><h2 id="应用场景与未来展望" tabindex="-1">应用场景与未来展望 <a class="header-anchor" href="#应用场景与未来展望" aria-label="Permalink to &quot;应用场景与未来展望&quot;">​</a></h2><h3 id="实际应用场景" tabindex="-1">实际应用场景 <a class="header-anchor" href="#实际应用场景" aria-label="Permalink to &quot;实际应用场景&quot;">​</a></h3><p>WasmGC 为多种应用场景带来了改进：</p><ol><li><strong>影音处理与游戏</strong>：通过 GC、例外处理与 SIMD 的改善获得更佳体验。</li><li><strong>科学计算</strong>：处理更大数据集，得益于 64 位地址空间和多内存支持。</li><li><strong>前端编辑器</strong>：更快的启动速度和更小的模块体积。</li><li><strong>服务器端应用</strong>：在非 Web 环境中处理海量数据。</li></ol><h3 id="技术展望" tabindex="-1">技术展望 <a class="header-anchor" href="#技术展望" aria-label="Permalink to &quot;技术展望&quot;">​</a></h3><p>随着 WebAssembly GC 在 2022 年 12 月达到 Stage 4 阶段，该技术已趋于成熟并具备了广泛应用的基础。未来，随着更多工具和优化技术的出现，开发者将能够更高效地管理 Wasm 的内存和进行垃圾回收。</p>`,59)])])}const u=s(t,[["render",o]]);export{g as __pageData,u as default};
