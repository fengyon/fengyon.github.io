import{_ as n,c as a,o as e,b as o}from"./chunks/framework.CMLuPXeo.js";const d=JSON.parse('{"title":"IntersectionObserver","description":"","frontmatter":{},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"IntersectionObserver.observe()","slug":"intersectionobserver-observe","link":"#intersectionobserver-observe","children":[{"level":3,"title":"callback 参数","slug":"callback-参数","link":"#callback-参数","children":[]},{"level":3,"title":"IntersectionObserverEntry 对象","slug":"intersectionobserverentry-对象","link":"#intersectionobserverentry-对象","children":[]},{"level":3,"title":"Option 对象","slug":"option-对象","link":"#option-对象","children":[]}]},{"level":2,"title":"实例","slug":"实例","link":"#实例","children":[{"level":3,"title":"惰性加载 (lazy load)","slug":"惰性加载-lazy-load","link":"#惰性加载-lazy-load","children":[]},{"level":3,"title":"无限滚动","slug":"无限滚动","link":"#无限滚动","children":[]},{"level":3,"title":"视频自动播放","slug":"视频自动播放","link":"#视频自动播放","children":[]}]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"relativePath":"basic/bom/intersectionObserver.md","filePath":"basic/bom/intersectionObserver.md"}'),l={name:"basic/bom/intersectionObserver.md"};function p(t,s,r,c,E,i){return e(),a("div",null,[...s[0]||(s[0]=[o(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /basic/bom/intersectionObserver.md for this page in Markdown format</div><h1 id="intersectionobserver" tabindex="-1">IntersectionObserver <a class="header-anchor" href="#intersectionobserver" aria-label="Permalink to &quot;IntersectionObserver&quot;">​</a></h1><p>网页开发时，常常需要了解某个元素是否进入了“视口”(viewport)，即用户能不能看到它。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016110201.gif" alt=""></p><p>上图的绿色方块不断滚动，顶部会提示它的可见性。</p><p>传统的实现方法是，监听到 <code>scroll</code> 事件后，调用目标元素 (绿色方块) 的 <a href="https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noreferrer"><code>getBoundingClientRect()</code></a> 方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于 <code>scroll</code> 事件密集发生，计算量很大，容易造成<a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noreferrer">性能问题</a>。</p><p><a href="https://wicg.github.io/IntersectionObserver/" target="_blank" rel="noreferrer">IntersectionObserver API</a>，可以自动“观察”元素是否可见，Chrome 51+ 已经支持。由于可见 (visible) 的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做“交叉观察器”(intersection oberserver)。</p><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>IntersectionObserver API 的用法，简单来说就是两行。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> observer </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> IntersectionObserver</span><span style="color:#E1E4E8;">(callback, options);</span></span>
<span class="line"><span style="color:#E1E4E8;">observer.</span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(target);</span></span></code></pre></div><p>上面代码中，<code>IntersectionObserver</code> 是浏览器原生提供的构造函数，接受两个参数：<code>callback</code> 是可见性变化时的回调函数，<code>option</code> 是配置对象 (该参数可选)。</p><p><code>IntersectionObserver()</code> 的返回值是一个观察器实例。实例的 <code>observe()</code> 方法可以指定观察哪个 DOM 节点。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 开始观察</span></span>
<span class="line"><span style="color:#E1E4E8;">observer.</span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;example&#39;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 停止观察</span></span>
<span class="line"><span style="color:#E1E4E8;">observer.</span><span style="color:#B392F0;">unobserve</span><span style="color:#E1E4E8;">(element);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 关闭观察器</span></span>
<span class="line"><span style="color:#E1E4E8;">observer.</span><span style="color:#B392F0;">disconnect</span><span style="color:#E1E4E8;">();</span></span></code></pre></div><p>上面代码中，<code>observe()</code> 的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">observer.</span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(elementA);</span></span>
<span class="line"><span style="color:#E1E4E8;">observer.</span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(elementB);</span></span></code></pre></div><p>注意，IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。规格写明，<code>IntersectionObserver</code> 的实现，应该采用 <code>requestIdleCallback()</code>，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p><h2 id="intersectionobserver-observe" tabindex="-1">IntersectionObserver.observe() <a class="header-anchor" href="#intersectionobserver-observe" aria-label="Permalink to &quot;IntersectionObserver.observe()&quot;">​</a></h2><p>IntersectionObserver 实例的 <code>observe()</code> 方法用来启动对一个 DOM 元素的观察。该方法接受两个参数：回调函数 <code>callback</code> 和配置对象 <code>options</code>。</p><h3 id="callback-参数" tabindex="-1">callback 参数 <a class="header-anchor" href="#callback-参数" aria-label="Permalink to &quot;callback 参数&quot;">​</a></h3><p>目标元素的可见性变化时，就会调用观察器的回调函数 <code>callback</code>。</p><p><code>callback</code> 会触发两次。一次是目标元素刚刚进入视口 (开始可见)，另一次是完全离开视口 (开始不可见)。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> observer </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> IntersectionObserver</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#FFAB70;">entries</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">observer</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(entries);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>上面代码中，回调函数采用的是<a href="http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" target="_blank" rel="noreferrer">箭头函数</a>的写法。<code>callback</code> 函数的参数 (<code>entries</code>) 是一个数组，每个成员都是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry" target="_blank" rel="noreferrer"><code>IntersectionObserverEntry</code></a> 对象 (详见下文)。举例来说，如果同时有两个被观察的对象的可见性发生变化，<code>entries</code> 数组就会有两个成员。</p><h3 id="intersectionobserverentry-对象" tabindex="-1">IntersectionObserverEntry 对象 <a class="header-anchor" href="#intersectionobserverentry-对象" aria-label="Permalink to &quot;IntersectionObserverEntry 对象&quot;">​</a></h3><p><code>IntersectionObserverEntry</code> 对象提供目标元素的信息，一共有六个属性。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#B392F0;">  time</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">3893.92</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">  rootBounds</span><span style="color:#E1E4E8;">: ClientRect {</span></span>
<span class="line"><span style="color:#B392F0;">    bottom</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">920</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">    height</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">    left</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">    right</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">    top</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">    width</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">920</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#B392F0;">  boundingClientRect</span><span style="color:#E1E4E8;">: ClientRect {</span></span>
<span class="line"><span style="color:#6A737D;">     // ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#B392F0;">  intersectionRect</span><span style="color:#E1E4E8;">: ClientRect {</span></span>
<span class="line"><span style="color:#6A737D;">    // ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#B392F0;">  intersectionRatio</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">0.54</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#B392F0;">  target</span><span style="color:#E1E4E8;">: element</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>每个属性的含义如下。</p><blockquote><ul><li><code>time</code>：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li><li><code>target</code>：被观察的目标元素，是一个 DOM 节点对象</li><li><code>rootBounds</code>：容器元素的矩形区域的信息，<code>getBoundingClientRect()</code> 方法的返回值，如果没有容器元素 (即直接相对于视口滚动)，则返回 <code>null</code></li><li><code>boundingClientRect</code>：目标元素的矩形区域的信息</li><li><code>intersectionRect</code>：目标元素与视口 (或容器元素) 的交叉区域的信息</li><li><code>intersectionRatio</code>：目标元素的可见比例，即 <code>intersectionRect</code> 占 <code>boundingClientRect</code> 的比例，完全可见时为 <code>1</code>，完全不可见时小于等于 <code>0</code></li></ul></blockquote><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016110202.png" alt=""></p><p>上图中，灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的 <code>intersectionRatio</code> 图中都已经注明。</p><p>我写了一个 <a href="http://jsbin.com/canuze/edit?js,console,output" target="_blank" rel="noreferrer">Demo</a>，演示 <code>IntersectionObserverEntry</code> 对象。注意，这个 Demo 只能在 Chrome 51+ 运行。</p><h3 id="option-对象" tabindex="-1">Option 对象 <a class="header-anchor" href="#option-对象" aria-label="Permalink to &quot;Option 对象&quot;">​</a></h3><p><code>IntersectionObserver</code> 构造函数的第二个参数是一个配置对象。它可以设置以下属性。</p><p><strong>(1) threshold 属性</strong></p><p><code>threshold</code> 属性决定了什么时候触发回调函数，即元素进入视口 (或者容器元素) 多少比例时，执行回调函数。它是一个数组，每个成员都是一个门槛值，默认为 <code>[0]</code>，即交叉比例 (<code>intersectionRatio</code>) 达到 <code>0</code> 时触发回调函数。</p><p>如果 <code>threshold</code> 属性是 0.5，当元素进入视口 50%时，触发回调函数。如果值为 <code>[0.3, 0.6]</code>，则当元素进入 30％ 和 60％ 是触发回调函数。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">new</span><span style="color:#B392F0;"> IntersectionObserver</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#FFAB70;">  entries</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> {</span><span style="color:#6A737D;">/* … */</span><span style="color:#E1E4E8;">},</span></span>
<span class="line"><span style="color:#E1E4E8;">  {</span></span>
<span class="line"><span style="color:#E1E4E8;">    threshold: [</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.25</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.75</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>用户可以自定义这个数组。比如，上例的 <code>[0, 0.25, 0.5, 0.75, 1]</code> 就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016110202.gif" alt=""></p><p><strong>(2) root 属性，rootMargin 属性</strong></p><p><code>IntersectionObserver</code> 不仅可以观察元素相对于视口的可见性，还可以观察元素相对于其所在容器的可见性。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。</p><p>IntersectionObserver API 支持容器内滚动。<code>root</code> 属性指定目标元素所在的容器节点。注意，容器元素必须是目标元素的祖先节点。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> opts </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  root: document.</span><span style="color:#B392F0;">querySelector</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;.container&#39;</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#E1E4E8;">  rootMargin: </span><span style="color:#9ECBFF;">&#39;0px 0px -200px 0px&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> observer </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> IntersectionObserver</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  callback,</span></span>
<span class="line"><span style="color:#E1E4E8;">  opts</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>上面代码中，除了 <code>root</code> 属性，还有 <a href="https://wicg.github.io/IntersectionObserver/#dom-intersectionobserverinit-rootmargin" target="_blank" rel="noreferrer"><code>rootMargin</code></a> 属性。该属性用来扩展或缩小 <code>rootBounds</code> 这个矩形的大小，从而影响 <code>intersectionRect</code> 交叉区域的大小。它的写法类似于 CSS 的 <code>margin</code> 属性，比如 <code>0px 0px 0px 0px</code>，依次表示 top、right、bottom 和 left 四个方向的值。</p><p>上例的 <code>0px 0px -200px 0px</code>，表示容器的下边缘向上收缩 200 像素，导致页面向下滚动时，目标元素的顶部进入可视区域 200 像素以后，才会触发回调函数。</p><p>这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p><h2 id="实例" tabindex="-1">实例 <a class="header-anchor" href="#实例" aria-label="Permalink to &quot;实例&quot;">​</a></h2><h3 id="惰性加载-lazy-load" tabindex="-1">惰性加载 (lazy load) <a class="header-anchor" href="#惰性加载-lazy-load" aria-label="Permalink to &quot;惰性加载 (lazy load)&quot;">​</a></h3><p>有时，我们希望某些静态资源 (比如图片)，只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。这就叫做“惰性加载”。</p><p>有了 IntersectionObserver API，实现起来就很容易了。图像的 HTML 代码可以写成下面这样。</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">img</span><span style="color:#B392F0;"> src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;placeholder.png&quot;</span><span style="color:#B392F0;"> data-src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;img-1.jpg&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">img</span><span style="color:#B392F0;"> src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;placeholder.png&quot;</span><span style="color:#B392F0;"> data-src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;img-2.jpg&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">img</span><span style="color:#B392F0;"> src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;placeholder.png&quot;</span><span style="color:#B392F0;"> data-src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;img-3.jpg&quot;</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>上面代码中，图像默认显示一个占位符，<code>data-src</code> 属性是惰性加载的真正图像。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> query</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">selector</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> Array.</span><span style="color:#B392F0;">from</span><span style="color:#E1E4E8;">(document.</span><span style="color:#B392F0;">querySelectorAll</span><span style="color:#E1E4E8;">(selector));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> observer </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> IntersectionObserver</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#F97583;">  function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">entries</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    entries.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">entry</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      entry.target.src </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> entry.target.dataset.src;</span></span>
<span class="line"><span style="color:#E1E4E8;">      observer.</span><span style="color:#B392F0;">unobserve</span><span style="color:#E1E4E8;">(entry.target);</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">query</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;.lazy-loaded&#39;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">item</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  observer.</span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(item);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p>上面代码中，只有图像开始可见时，才会加载真正的图像文件。</p><h3 id="无限滚动" tabindex="-1">无限滚动 <a class="header-anchor" href="#无限滚动" aria-label="Permalink to &quot;无限滚动&quot;">​</a></h3><p>无限滚动 (infinite scroll) 指的是，随着网页滚动到底部，不断加载新的内容到页面，它的实现也很简单。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> intersectionObserver </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> IntersectionObserver</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#F97583;">  function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">entries</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 如果不可见，就返回</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (entries[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">].intersectionRatio </span><span style="color:#F97583;">&lt;=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#B392F0;">    loadItems</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Loaded new items&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 开始观察</span></span>
<span class="line"><span style="color:#E1E4E8;">intersectionObserver.</span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  document.</span><span style="color:#B392F0;">querySelector</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;.scrollerFooter&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>无限滚动时，最好像上例那样，页面底部有一个页尾栏 (又称 <code>sentinels</code>，上例是 <code>.scrollerFooter</code>)。一旦页尾栏可见，就表示用户到达了页面底部，从而加载新的条目放在页尾栏前面。否则就需要每一次页面加入新内容时，都调用 <code>observe()</code> 方法，对新增内容的底部建立观察。</p><h3 id="视频自动播放" tabindex="-1">视频自动播放 <a class="header-anchor" href="#视频自动播放" aria-label="Permalink to &quot;视频自动播放&quot;">​</a></h3><p>下面是一个视频元素，希望它完全进入视口的时候自动播放，离开视口的时候自动暂停。</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">video</span><span style="color:#B392F0;"> src</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;foo.mp4&quot;</span><span style="color:#B392F0;"> controls</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">&gt;&lt;/</span><span style="color:#85E89D;">video</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>下面是 JS 代码。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> video </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">querySelector</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;video&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> isPaused </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> observer </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> IntersectionObserver</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">entries</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">observer</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  entries.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">entry</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (entry.intersectionRatio </span><span style="color:#F97583;">!=</span><span style="color:#79B8FF;"> 1</span><span style="color:#F97583;">  &amp;&amp;</span><span style="color:#F97583;"> !</span><span style="color:#E1E4E8;">video.paused) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      video.</span><span style="color:#B392F0;">pause</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      isPaused </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#F97583;"> if</span><span style="color:#E1E4E8;"> (isPaused) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      video.</span><span style="color:#B392F0;">play</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      isPaused</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#E1E4E8;">}, {threshold: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">observer.</span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(video);</span></span></code></pre></div><p>上面代码中，<code>IntersectionObserver()</code> 的第二个参数是配置对象，它的 <code>threshold</code> 属性等于 <code>1</code>，即目标元素完全可见时触发回调函数。</p><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://developers.google.com/web/updates/2016/04/intersectionobserver" target="_blank" rel="noreferrer">IntersectionObserver’s Coming into View</a></li><li><a href="https://github.com/WICG/IntersectionObserver/blob/gh-pages/explainer.md" target="_blank" rel="noreferrer">Intersection Observers Explained</a></li><li><a href="https://css-tricks.com/a-few-functional-uses-for-intersection-observer-to-know-when-an-element-is-in-view/" target="_blank" rel="noreferrer">A Few Functional Uses for Intersection Observer to Know When an Element is in View</a>, Preethi</li></ul>`,66)])])}const b=n(l,[["render",p]]);export{d as __pageData,b as default};
