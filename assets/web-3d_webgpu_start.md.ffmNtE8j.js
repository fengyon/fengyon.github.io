import{_ as a,c as n,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const d=JSON.parse('{"title":"WebGPU 入门","description":"","frontmatter":{},"headers":[{"level":2,"title":"WebGPU 概述","slug":"webgpu-概述","link":"#webgpu-概述","children":[]},{"level":2,"title":"核心架构与基本概念","slug":"核心架构与基本概念","link":"#核心架构与基本概念","children":[{"level":3,"title":"环境架构","slug":"环境架构","link":"#环境架构","children":[]},{"level":3,"title":"适配器与设备","slug":"适配器与设备","link":"#适配器与设备","children":[]},{"level":3,"title":"坐标系系统","slug":"坐标系系统","link":"#坐标系系统","children":[]}]},{"level":2,"title":"初始化与设置","slug":"初始化与设置","link":"#初始化与设置","children":[{"level":3,"title":"画布配置","slug":"画布配置","link":"#画布配置","children":[]},{"level":3,"title":"扩展功能","slug":"扩展功能","link":"#扩展功能","children":[]}]},{"level":2,"title":"着色器编程","slug":"着色器编程","link":"#着色器编程","children":[{"level":3,"title":"WGSL 概述","slug":"wgsl-概述","link":"#wgsl-概述","children":[]},{"level":3,"title":"着色器示例","slug":"着色器示例","link":"#着色器示例","children":[]},{"level":3,"title":"计算着色器","slug":"计算着色器","link":"#计算着色器","children":[]}]},{"level":2,"title":"资源管理","slug":"资源管理","link":"#资源管理","children":[{"level":3,"title":"缓冲区","slug":"缓冲区","link":"#缓冲区","children":[]},{"level":3,"title":"纹理","slug":"纹理","link":"#纹理","children":[]},{"level":3,"title":"绑定组与布局","slug":"绑定组与布局","link":"#绑定组与布局","children":[]}]},{"level":2,"title":"渲染流程","slug":"渲染流程","link":"#渲染流程","children":[{"level":3,"title":"渲染管道","slug":"渲染管道","link":"#渲染管道","children":[]},{"level":3,"title":"编码器与命令提交","slug":"编码器与命令提交","link":"#编码器与命令提交","children":[]}]},{"level":2,"title":"性能优化","slug":"性能优化","link":"#性能优化","children":[{"level":3,"title":"内存管理","slug":"内存管理","link":"#内存管理","children":[]},{"level":3,"title":"异步操作","slug":"异步操作","link":"#异步操作","children":[]}]},{"level":2,"title":"错误处理与调试","slug":"错误处理与调试","link":"#错误处理与调试","children":[]},{"level":2,"title":"跨平台考虑","slug":"跨平台考虑","link":"#跨平台考虑","children":[]},{"level":2,"title":"现代图形功能","slug":"现代图形功能","link":"#现代图形功能","children":[]}],"relativePath":"web-3d/webgpu/start.md","filePath":"web-3d/webgpu/start.md"}'),e={name:"web-3d/webgpu/start.md"};function o(t,s,c,r,E,i){return l(),n("div",null,[...s[0]||(s[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /web-3d/webgpu/start.md for this page in Markdown format</div><h1 id="webgpu-入门" tabindex="-1">WebGPU 入门 <a class="header-anchor" href="#webgpu-入门" aria-label="Permalink to &quot;WebGPU 入门&quot;">​</a></h1><p>WebGPU 是一种全新的 Web 图形 API，它被设计为 WebGL 的继承者，为现代 GPU 编程提供了更高效、更安全的访问方式。与基于 OpenGL 的 WebGL 不同，WebGPU 完全从头开始设计，更接近 Vulkan、Metal 和 Direct3D 等现代图形 API。它不仅在图形渲染方面表现出色，还首次在浏览器中引入了通用 GPU 计算能力。</p><h2 id="webgpu-概述" tabindex="-1">WebGPU 概述 <a class="header-anchor" href="#webgpu-概述" aria-label="Permalink to &quot;WebGPU 概述&quot;">​</a></h2><p>WebGPU 是一个低级别 API，它让开发者能够更直接地控制 GPU 的操作。这种设计虽然增加了编程的复杂性，但换来了更高的性能和效率。WebGPU 的着色器使用 WGSL (WebGPU Shading Language) 编写，这是一种为 Web 环境设计的安全的着色语言。</p><p><strong>WebGPU 与 WebGL 的关键差异</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>WebGL (基于 OpenGL ES)：</span></span>
<span class="line"><span>    ↑</span></span>
<span class="line"><span>高层级API ← 驱动程序 ← GPU</span></span>
<span class="line"><span></span></span>
<span class="line"><span>WebGPU (类似 Vulkan/Metal)：</span></span>
<span class="line"><span>    ↑</span></span>
<span class="line"><span>低级别API ← 通用接口 ← 适配器 ← 实际GPU硬件</span></span></code></pre></div><p>与主要用于绘图的 WebGL 不同，WebGPU 在设计之初就同时考虑了图形渲染和通用计算两大功能。这使得它在处理复杂图形和大规模数据计算时具有更高的性能和灵活性。</p><h2 id="核心架构与基本概念" tabindex="-1">核心架构与基本概念 <a class="header-anchor" href="#核心架构与基本概念" aria-label="Permalink to &quot;核心架构与基本概念&quot;">​</a></h2><h3 id="环境架构" tabindex="-1">环境架构 <a class="header-anchor" href="#环境架构" aria-label="Permalink to &quot;环境架构&quot;">​</a></h3><p>WebGPU 应用程序环境包含两个主要部分：JavaScript 端和 GPU 端。JavaScript 端在 CPU 上执行，而 WebGPU 的计算和渲染操作则在 GPU 上执行。这两种处理器拥有各自专用的内存，但也通过一些共享内存来进行数据交换和消息传递。</p><p>示意图 (WebGPU 架构)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>JavaScript应用 (CPU端)</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>    WebGPU API</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>    适配器/设备</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>  着色器模块(WGSL)</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>   GPU执行 (GPU端)</span></span></code></pre></div><h3 id="适配器与设备" tabindex="-1">适配器与设备 <a class="header-anchor" href="#适配器与设备" aria-label="Permalink to &quot;适配器与设备&quot;">​</a></h3><p>在 WebGPU 中，<strong>适配器</strong> (Adapter) 代表了物理 GPU 硬件的抽象，而<strong>设备</strong> (Device) 则是开发者与 GPU 功能交互的主要接口。这种层级结构让 WebGPU 能够适应不同的硬件配置。</p><p>获取适配器和设备的典型代码流程：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> initWebGPU</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">navigator.gpu) {</span></span>
<span class="line"><span style="color:#F97583;">        throw</span><span style="color:#B392F0;"> Error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;WebGPU 不支持&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 获取适配器</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> adapter </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> navigator.gpu.</span><span style="color:#B392F0;">requestAdapter</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">adapter) {</span></span>
<span class="line"><span style="color:#F97583;">        throw</span><span style="color:#B392F0;"> Error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;无法获取 WebGPU 适配器&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#6A737D;">    // 获取设备</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> device </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> adapter.</span><span style="color:#B392F0;">requestDevice</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> device;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="坐标系系统" tabindex="-1">坐标系系统 <a class="header-anchor" href="#坐标系系统" aria-label="Permalink to &quot;坐标系系统&quot;">​</a></h3><p>WebGPU 使用与传统图形 API 相似的标准化设备坐标系统，X、Y、Z 坐标范围通常为 [-1，1]。与 WebGL 不同的是，WebGPU 的 Y 轴在标准化设备坐标中向上为正，在纹理坐标中向下为正。</p><h2 id="初始化与设置" tabindex="-1">初始化与设置 <a class="header-anchor" href="#初始化与设置" aria-label="Permalink to &quot;初始化与设置&quot;">​</a></h2><h3 id="画布配置" tabindex="-1">画布配置 <a class="header-anchor" href="#画布配置" aria-label="Permalink to &quot;画布配置&quot;">​</a></h3><p>要在页面上显示图形，需要将 WebGPU 与 HTML 画布元素关联起来：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> canvas</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;webgpu-canvas&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> context</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> canvas.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;webgpu&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 配置画布上下文</span></span>
<span class="line"><span style="color:#E1E4E8;">context.</span><span style="color:#B392F0;">configure</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    device: device,</span></span>
<span class="line"><span style="color:#E1E4E8;">    format: navigator.gpu.</span><span style="color:#B392F0;">getPreferredCanvasFormat</span><span style="color:#E1E4E8;">(),</span></span>
<span class="line"><span style="color:#E1E4E8;">    alphaMode: </span><span style="color:#9ECBFF;">&#39;premultiplied&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h3 id="扩展功能" tabindex="-1">扩展功能 <a class="header-anchor" href="#扩展功能" aria-label="Permalink to &quot;扩展功能&quot;">​</a></h3><p>WebGPU 支持多种扩展，如 <code>shader-f16</code> 扩展允许使用半精度浮点数，通过减少内存带宽来提高性能。虽然所有 Apple 设备都支持这个扩展，但在其他平台上使用前需要检查支持情况。</p><h2 id="着色器编程" tabindex="-1">着色器编程 <a class="header-anchor" href="#着色器编程" aria-label="Permalink to &quot;着色器编程&quot;">​</a></h2><h3 id="wgsl-概述" tabindex="-1">WGSL 概述 <a class="header-anchor" href="#wgsl-概述" aria-label="Permalink to &quot;WGSL 概述&quot;">​</a></h3><p>WGSL (WebGPU Shading Language) 是 WebGPU 的着色器语言，从构建之初就考虑了网页安全性。WGSL 支持三种类型的程序：顶点程序、片段程序和计算程序。</p><p><strong>WGSL 与 GLSL 对比</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>GLSL (WebGL):</span></span>
<span class="line"><span>    attribute, uniform, varying</span></span>
<span class="line"><span>    GLSL ES 语法</span></span>
<span class="line"><span></span></span>
<span class="line"><span>WGSL (WebGPU):</span></span>
<span class="line"><span>    @location, @binding</span></span>
<span class="line"><span>    现代着色语言设计</span></span>
<span class="line"><span>    更强的类型安全</span></span></code></pre></div><h3 id="着色器示例" tabindex="-1">着色器示例 <a class="header-anchor" href="#着色器示例" aria-label="Permalink to &quot;着色器示例&quot;">​</a></h3><p>一个简单的顶点着色器示例：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 顶点着色器</span></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">vertex</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> vs_main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">@</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(vertex_index) in_vertex_index: </span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">-&gt;</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(position) </span><span style="color:#F97583;">vec4</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#F97583;">    var</span><span style="color:#E1E4E8;"> pos </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> array</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">vec2</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="color:#F97583;">        vec2</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#F97583;">        vec2</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#F97583;">        vec2</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    );</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#F97583;"> vec4</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;(pos[in_vertex_index], </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 片段着色器</span></span>
<span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">fragment</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> fs_main</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-&gt;</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">location</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">vec4</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#F97583;"> vec4</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">f32</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;"> // 红色</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="计算着色器" tabindex="-1">计算着色器 <a class="header-anchor" href="#计算着色器" aria-label="Permalink to &quot;计算着色器&quot;">​</a></h3><p>WebGPU 的一个关键优势是支持计算着色器，这是 WebGL 所不具备的。计算着色器允许执行通用计算任务，将结果存储在缓冲区中，然后读回 JavaScript 代码，且不一定需要可视化输出。</p><p>计算着色器示例：</p><div class="language-wgsl"><button title="Copy Code" class="copy"></button><span class="lang">wgsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">@</span><span style="color:#B392F0;">compute</span><span style="color:#F97583;"> @</span><span style="color:#B392F0;">workgroup_size</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> cs_main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">@</span><span style="color:#B392F0;">builtin</span><span style="color:#E1E4E8;">(global_invocation_id) global_id: </span><span style="color:#F97583;">vec3</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">u32</span><span style="color:#E1E4E8;">&gt;) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 执行并行计算</span></span>
<span class="line"><span style="color:#6A737D;">    // 应用重力、速度和经过时间等物理模拟</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="资源管理" tabindex="-1">资源管理 <a class="header-anchor" href="#资源管理" aria-label="Permalink to &quot;资源管理&quot;">​</a></h2><h3 id="缓冲区" tabindex="-1">缓冲区 <a class="header-anchor" href="#缓冲区" aria-label="Permalink to &quot;缓冲区&quot;">​</a></h3><p>缓冲区是 WebGPU 中灵活的内存块，可用于存储各种数据，从简单的浮点向量到复杂的自定义数据结构。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建缓冲区</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> buffer</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createBuffer</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    size: </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 字节大小</span></span>
<span class="line"><span style="color:#E1E4E8;">    usage: GPUBufferUsage.</span><span style="color:#79B8FF;">VERTEX</span><span style="color:#F97583;"> |</span><span style="color:#E1E4E8;"> GPUBufferUsage.</span><span style="color:#79B8FF;">COPY_DST</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    mappedAtCreation: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 填充缓冲区数据</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bufferData</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Float32Array</span><span style="color:#E1E4E8;">(buffer.</span><span style="color:#B392F0;">getMappedRange</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">bufferData.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">([</span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">0.5</span><span style="color:#E1E4E8;">]);</span></span>
<span class="line"><span style="color:#E1E4E8;">buffer.</span><span style="color:#B392F0;">unmap</span><span style="color:#E1E4E8;">();</span></span></code></pre></div><h3 id="纹理" tabindex="-1">纹理 <a class="header-anchor" href="#纹理" aria-label="Permalink to &quot;纹理&quot;">​</a></h3><p>纹理表示图像数据，支持 1D、2D、2D 数组、立方体贴图和 3D 纹理。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建纹理</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> texture</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createTexture</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    size: [</span><span style="color:#79B8FF;">512</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">512</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    format: </span><span style="color:#9ECBFF;">&#39;rgba8unorm&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    usage: GPUTextureUsage.</span><span style="color:#79B8FF;">TEXTURE_BINDING</span><span style="color:#F97583;"> |</span><span style="color:#E1E4E8;"> GPUTextureUsage.</span><span style="color:#79B8FF;">COPY_DST</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 从图像加载纹理数据</span></span>
<span class="line"><span style="color:#E1E4E8;">device.queue.</span><span style="color:#B392F0;">copyExternalImageToTexture</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    { source: imageBitmap },</span></span>
<span class="line"><span style="color:#E1E4E8;">    { texture: texture },</span></span>
<span class="line"><span style="color:#E1E4E8;">    [imageBitmap.width, imageBitmap.height]</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre></div><h3 id="绑定组与布局" tabindex="-1">绑定组与布局 <a class="header-anchor" href="#绑定组与布局" aria-label="Permalink to &quot;绑定组与布局&quot;">​</a></h3><p>绑定组将相关资源 (如缓冲区、纹理和采样器) 分组在一起，以便 GPU 能够高效使用它们。布局则定义了资源从 API 传递到 GPU 程序的结构化方式。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建绑定组布局</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bindGroupLayout</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createBindGroupLayout</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    entries: [</span></span>
<span class="line"><span style="color:#E1E4E8;">        {</span></span>
<span class="line"><span style="color:#E1E4E8;">            binding: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            visibility: GPUShaderStage.</span><span style="color:#79B8FF;">VERTEX</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            buffer: { type: </span><span style="color:#9ECBFF;">&#39;uniform&#39;</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    ]</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 创建绑定组</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bindGroup</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createBindGroup</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    layout: bindGroupLayout,</span></span>
<span class="line"><span style="color:#E1E4E8;">    entries: [</span></span>
<span class="line"><span style="color:#E1E4E8;">        {</span></span>
<span class="line"><span style="color:#E1E4E8;">            binding: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            resource: { buffer: uniformBuffer }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    ]</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h2 id="渲染流程" tabindex="-1">渲染流程 <a class="header-anchor" href="#渲染流程" aria-label="Permalink to &quot;渲染流程&quot;">​</a></h2><h3 id="渲染管道" tabindex="-1">渲染管道 <a class="header-anchor" href="#渲染管道" aria-label="Permalink to &quot;渲染管道&quot;">​</a></h3><p>管道指定了 GPU 上将如何使用纹理和缓冲区。WebGPU 有两种主要管道类型：渲染管道和计算管道。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建渲染管道</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> renderPipeline</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createRenderPipeline</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    vertex: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        module: shaderModule,</span></span>
<span class="line"><span style="color:#E1E4E8;">        entryPoint: </span><span style="color:#9ECBFF;">&#39;vs_main&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">    fragment: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        module: shaderModule,</span></span>
<span class="line"><span style="color:#E1E4E8;">        entryPoint: </span><span style="color:#9ECBFF;">&#39;fs_main&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">        targets: [{ format: </span><span style="color:#9ECBFF;">&#39;rgba8unorm&#39;</span><span style="color:#E1E4E8;"> }]</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">    primitive: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        topology: </span><span style="color:#9ECBFF;">&#39;triangle-list&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">    layout: pipelineLayout</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h3 id="编码器与命令提交" tabindex="-1">编码器与命令提交 <a class="header-anchor" href="#编码器与命令提交" aria-label="Permalink to &quot;编码器与命令提交&quot;">​</a></h3><p>WebGPU 使用命令编码器来记录和提交 GPU 命令：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建命令编码器</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> commandEncoder</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createCommandEncoder</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 开始渲染通道</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> renderPass</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> commandEncoder.</span><span style="color:#B392F0;">beginRenderPass</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    colorAttachments: [</span></span>
<span class="line"><span style="color:#E1E4E8;">        {</span></span>
<span class="line"><span style="color:#E1E4E8;">            view: context.</span><span style="color:#B392F0;">getCurrentTexture</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">createView</span><span style="color:#E1E4E8;">(),</span></span>
<span class="line"><span style="color:#E1E4E8;">            loadOp: </span><span style="color:#9ECBFF;">&#39;clear&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            storeOp: </span><span style="color:#9ECBFF;">&#39;store&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">            clearValue: [</span><span style="color:#79B8FF;">0.1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0.3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">] </span><span style="color:#6A737D;">// RGBA</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    ]</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 设置管道和资源</span></span>
<span class="line"><span style="color:#E1E4E8;">renderPass.</span><span style="color:#B392F0;">setPipeline</span><span style="color:#E1E4E8;">(renderPipeline);</span></span>
<span class="line"><span style="color:#E1E4E8;">renderPass.</span><span style="color:#B392F0;">setBindGroup</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, bindGroup);</span></span>
<span class="line"><span style="color:#E1E4E8;">renderPass.</span><span style="color:#B392F0;">draw</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 绘制3个顶点</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 结束渲染通道并提交命令</span></span>
<span class="line"><span style="color:#E1E4E8;">renderPass.</span><span style="color:#B392F0;">end</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> commandBuffer</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> commandEncoder.</span><span style="color:#B392F0;">finish</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">device.queue.</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">([commandBuffer]);</span></span></code></pre></div><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><h3 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h3><p>WebGPU 设计强调提高 GPU 数据访问效率，减少 CPU 到 GPU 的数据传输过程。合理使用缓冲区和纹理的使用标志可以显著提高性能。</p><p><strong>缓冲区使用模式</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;map-write&quot;：    CPU写入，GPU读取</span></span>
<span class="line"><span>&quot;copy-src&quot;：     作为复制源</span></span>
<span class="line"><span>&quot;copy-dst&quot;:      作为复制目标</span></span>
<span class="line"><span>&quot;uniform&quot;:       统一缓冲区</span></span>
<span class="line"><span>&quot;storage&quot;:       存储缓冲区</span></span></code></pre></div><h3 id="异步操作" tabindex="-1">异步操作 <a class="header-anchor" href="#异步操作" aria-label="Permalink to &quot;异步操作&quot;">​</a></h3><p>WebGPU 广泛使用异步操作来处理资源创建和数据传输：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 异步映射缓冲区</span></span>
<span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> updateBufferData</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">device</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">buffer</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    await</span><span style="color:#E1E4E8;"> device.queue.</span><span style="color:#B392F0;">onSubmittedWorkDone</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> writeBuffer</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createBuffer</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">        size: data.byteLength,</span></span>
<span class="line"><span style="color:#E1E4E8;">        usage: GPUBufferUsage.</span><span style="color:#79B8FF;">COPY_SRC</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">        mappedAtCreation: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    new</span><span style="color:#B392F0;"> Float32Array</span><span style="color:#E1E4E8;">(writeBuffer.</span><span style="color:#B392F0;">getMappedRange</span><span style="color:#E1E4E8;">()).</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(data);</span></span>
<span class="line"><span style="color:#E1E4E8;">    writeBuffer.</span><span style="color:#B392F0;">unmap</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> commandEncoder</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createCommandEncoder</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    commandEncoder.</span><span style="color:#B392F0;">copyBufferToBuffer</span><span style="color:#E1E4E8;">(writeBuffer, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, buffer, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, data.byteLength);</span></span>
<span class="line"><span style="color:#E1E4E8;">    device.queue.</span><span style="color:#B392F0;">submit</span><span style="color:#E1E4E8;">([commandEncoder.</span><span style="color:#B392F0;">finish</span><span style="color:#E1E4E8;">()]);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="错误处理与调试" tabindex="-1">错误处理与调试 <a class="header-anchor" href="#错误处理与调试" aria-label="Permalink to &quot;错误处理与调试&quot;">​</a></h2><p>WebGPU 提供了强大的调试工具，包括错误范围和调试组：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建设备时启用错误处理</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> device</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> adapter.</span><span style="color:#B392F0;">requestDevice</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">    defaultQueue: { label: </span><span style="color:#9ECBFF;">&quot;defaultQueue&quot;</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用推入/弹出调试组</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> commandEncoder</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> device.</span><span style="color:#B392F0;">createCommandEncoder</span><span style="color:#E1E4E8;">({ label: </span><span style="color:#9ECBFF;">&quot;mainEncoder&quot;</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"><span style="color:#E1E4E8;">commandEncoder.</span><span style="color:#B392F0;">pushDebugGroup</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;渲染三角形&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// ... 渲染命令</span></span>
<span class="line"><span style="color:#E1E4E8;">commandEncoder.</span><span style="color:#B392F0;">popDebugGroup</span><span style="color:#E1E4E8;">();</span></span></code></pre></div><h2 id="跨平台考虑" tabindex="-1">跨平台考虑 <a class="header-anchor" href="#跨平台考虑" aria-label="Permalink to &quot;跨平台考虑&quot;">​</a></h2><p>WebGPU 设计为跨平台 API，在 macOS 上通过 Metal 实现，在 Windows 上通过 Direct3D 12 或 Vulkan 实现，在 Linux 上通过 Vulkan 实现。这种多后端支持使得 WebGPU 能够在不同平台上提供一致的编程体验。</p><p><strong>平台支持矩阵</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>Apple平台:    Metal (完全支持)</span></span>
<span class="line"><span>Windows:      Direct3D 12 / Vulkan</span></span>
<span class="line"><span>Linux:        Vulkan</span></span>
<span class="line"><span>Android:      Vulkan</span></span>
<span class="line"><span>ChromeOS:     Vulkan</span></span></code></pre></div><h2 id="现代图形功能" tabindex="-1">现代图形功能 <a class="header-anchor" href="#现代图形功能" aria-label="Permalink to &quot;现代图形功能&quot;">​</a></h2><p>WebGPU 支持许多现代图形功能，包括：</p><ul><li><strong>计算着色器</strong>：用于通用目的并行计算</li><li><strong>存储缓冲区</strong>：支持随机读写的缓冲区</li><li><strong>原子操作</strong>：用于并行算法中的同步</li><li><strong>多重采样抗锯齿</strong>：改善图像质量</li><li><strong>深度测试和模板测试</strong>：高级渲染效果</li></ul><p>这些功能使得 WebGPU 不仅适用于图形渲染，也适用于机器学习、科学计算和物理模拟等领域。</p>`,73)])])}const F=a(e,[["render",o]]);export{d as __pageData,F as default};
