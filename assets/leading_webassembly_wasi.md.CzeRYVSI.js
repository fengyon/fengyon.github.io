import{_ as a,c as n,o as l,b as e}from"./chunks/framework.CMLuPXeo.js";const u=JSON.parse('{"title":"WASM 系统接口 (WASI)","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是 WASI？","slug":"什么是-wasi","link":"#什么是-wasi","children":[]},{"level":2,"title":"设计理念与特点","slug":"设计理念与特点","link":"#设计理念与特点","children":[{"level":3,"title":"安全优先的设计","slug":"安全优先的设计","link":"#安全优先的设计","children":[]},{"level":3,"title":"虚拟操作系统架构","slug":"虚拟操作系统架构","link":"#虚拟操作系统架构","children":[]}]},{"level":2,"title":"核心架构组件","slug":"核心架构组件","link":"#核心架构组件","children":[{"level":3,"title":"标准化系统接口","slug":"标准化系统接口","link":"#标准化系统接口","children":[]},{"level":3,"title":"组件模型","slug":"组件模型","link":"#组件模型","children":[]}]},{"level":2,"title":"应用场景与生态系统","slug":"应用场景与生态系统","link":"#应用场景与生态系统","children":[{"level":3,"title":"浏览器中的 WASI","slug":"浏览器中的-wasi","link":"#浏览器中的-wasi","children":[]},{"level":3,"title":"超越浏览器的应用","slug":"超越浏览器的应用","link":"#超越浏览器的应用","children":[]},{"level":3,"title":"网络能力","slug":"网络能力","link":"#网络能力","children":[]}]},{"level":2,"title":"开发实践","slug":"开发实践","link":"#开发实践","children":[{"level":3,"title":"支持的语言与工具链","slug":"支持的语言与工具链","link":"#支持的语言与工具链","children":[]},{"level":3,"title":"运行时生态","slug":"运行时生态","link":"#运行时生态","children":[]}]},{"level":2,"title":"版本演进","slug":"版本演进","link":"#版本演进","children":[]},{"level":2,"title":"安全性与可移植性优势","slug":"安全性与可移植性优势","link":"#安全性与可移植性优势","children":[{"level":3,"title":"细粒度的安全控制","slug":"细粒度的安全控制","link":"#细粒度的安全控制","children":[]},{"level":3,"title":"真正的二进制兼容性","slug":"真正的二进制兼容性","link":"#真正的二进制兼容性","children":[]}]}],"relativePath":"leading/webassembly/wasi.md","filePath":"leading/webassembly/wasi.md"}'),p={name:"leading/webassembly/wasi.md"};function o(t,s,i,r,c,d){return l(),n("div",null,[...s[0]||(s[0]=[e(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /leading/webassembly/wasi.md for this page in Markdown format</div><h1 id="wasm-系统接口-wasi" tabindex="-1">WASM 系统接口 (WASI) <a class="header-anchor" href="#wasm-系统接口-wasi" aria-label="Permalink to &quot;WASM 系统接口 (WASI)&quot;">​</a></h1><h2 id="什么是-wasi" tabindex="-1">什么是 WASI？ <a class="header-anchor" href="#什么是-wasi" aria-label="Permalink to &quot;什么是 WASI？&quot;">​</a></h2><p>WebAssembly 系统接口 (WASI) 是一组为 WebAssembly (Wasm) 编译的软件标准 API 规范。WASI 旨在为可从任何语言编译成 Wasm 的应用程序提供<strong>安全的标准接口</strong>，这些应用程序可以在任何地方运行——从浏览器到云到嵌入式设备。</p><p><strong>核心定位：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>WebAssembly 模块 → 需要访问系统资源</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>WASI 标准接口 ← 提供安全、可移植的系统调用</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>各种运行环境 (浏览器/云/边缘/嵌入式)</span></span></code></pre></div><h2 id="设计理念与特点" tabindex="-1">设计理念与特点 <a class="header-anchor" href="#设计理念与特点" aria-label="Permalink to &quot;设计理念与特点&quot;">​</a></h2><h3 id="安全优先的设计" tabindex="-1">安全优先的设计 <a class="header-anchor" href="#安全优先的设计" aria-label="Permalink to &quot;安全优先的设计&quot;">​</a></h3><p>WASI 采用基于<strong>能力的安全模型</strong> (Capability-based Security Model)，这是一种比简单沙箱更安全的机制。在这种模型中，WASI 运行时可以将“打开”系统调用的实例传递到沙箱中，该实例只能打开运行时本身预先选定的特定文件或文件夹。</p><p><strong>传统安全模型 vs WASI 能力模型：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>传统权限模型:</span></span>
<span class="line"><span>程序请求: &quot;打开文件 /etc/passwd&quot;</span></span>
<span class="line"><span>系统检查: 进程是否有读取权限 → 是/否</span></span>
<span class="line"><span></span></span>
<span class="line"><span>WASI 能力模型:</span></span>
<span class="line"><span>程序持有: 特定文件的能力令牌</span></span>
<span class="line"><span>系统检查: 令牌是否有效 → 是/否</span></span></code></pre></div><h3 id="虚拟操作系统架构" tabindex="-1">虚拟操作系统架构 <a class="header-anchor" href="#虚拟操作系统架构" aria-label="Permalink to &quot;虚拟操作系统架构&quot;">​</a></h3><p>WASI 本质上是一个<strong>虚拟操作系统接口</strong>，它为所有编程语言提供统一的系统调用集，同时给所有 Wasm 运行时开发者提供单一的操作系统来模拟。</p><p><strong>架构示意图：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>不同语言应用 (Rust/C/C++/Go...)</span></span>
<span class="line"><span>    ↓ 编译为统一目标</span></span>
<span class="line"><span>WASM 模块 + WASI 调用</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>各种 WASI 运行时 (Wasmtime/WasmEdge/Wasmer...)</span></span>
<span class="line"><span>    ↓ 适配不同平台</span></span>
<span class="line"><span>宿主操作系统 (Linux/Windows/macOS...)</span></span></code></pre></div><h2 id="核心架构组件" tabindex="-1">核心架构组件 <a class="header-anchor" href="#核心架构组件" aria-label="Permalink to &quot;核心架构组件&quot;">​</a></h2><h3 id="标准化系统接口" tabindex="-1">标准化系统接口 <a class="header-anchor" href="#标准化系统接口" aria-label="Permalink to &quot;标准化系统接口&quot;">​</a></h3><p>WASI 将几乎每个程序都需要的基本管理功能 (如文件、文件夹、网络连接或时间) 设计成相应的接口，这些接口尽可能类似于它们的 POSIX 对应物，并全部打包到“WASI-core”模块中。</p><p><strong>WASI-core 主要功能域：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>文件系统操作 (文件读写、目录管理)</span></span>
<span class="line"><span>网络通信 (套接字、HTTP)</span></span>
<span class="line"><span>时间管理 (系统时钟、定时器)</span></span>
<span class="line"><span>随机数生成</span></span>
<span class="line"><span>环境变量与参数</span></span></code></pre></div><h3 id="组件模型" tabindex="-1">组件模型 <a class="header-anchor" href="#组件模型" aria-label="Permalink to &quot;组件模型&quot;">​</a></h3><p>WASI 可以同时被核心 Wasm 模块和根据<strong>组件模型</strong>构建的应用程序使用，该规范使 Wasm 应用程序能够互操作和组合。这种设计支持将软件编写在不同语言中的程序组合起来，而无需像基于 HTTP 的微服务那样昂贵且笨重的接口系统。</p><h2 id="应用场景与生态系统" tabindex="-1">应用场景与生态系统 <a class="header-anchor" href="#应用场景与生态系统" aria-label="Permalink to &quot;应用场景与生态系统&quot;">​</a></h2><h3 id="浏览器中的-wasi" tabindex="-1">浏览器中的 WASI <a class="header-anchor" href="#浏览器中的-wasi" aria-label="Permalink to &quot;浏览器中的 WASI&quot;">​</a></h3><p>在浏览器中，通过 WASI，WebAssembly 程序可以调用系统 API，从而执行一些原本无法通过纯 Web 技术实现的功能。例如，使用 WASI，WebAssembly 程序可以访问文件系统、网络资源等。</p><p><strong>浏览器集成模式：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>Web 应用 ← JavaScript 胶水代码 ← WASI 填充程序 ← WASM 模块</span></span></code></pre></div><h3 id="超越浏览器的应用" tabindex="-1">超越浏览器的应用 <a class="header-anchor" href="#超越浏览器的应用" aria-label="Permalink to &quot;超越浏览器的应用&quot;">​</a></h3><p>WASI 使 WebAssembly 能够广泛应用于各种环境：</p><ul><li><strong>云原生与边缘计算</strong>：轻量级、安全的函数执行</li><li><strong>物联网设备</strong>：资源受限环境中的可移植代码</li><li><strong>移动设备</strong>：跨平台原生性能</li><li><strong>插件系统</strong>：任何带有插件模型的项目都应该使用 WASI</li></ul><h3 id="网络能力" tabindex="-1">网络能力 <a class="header-anchor" href="#网络能力" aria-label="Permalink to &quot;网络能力&quot;">​</a></h3><p>WASI 的网络功能是其在浏览器应用中的一大亮点。通过 WASI，WebAssembly 程序可以直接与网络进行交互，而无需经过 JavaScript 或 Web API 的中转。这大大提高了网络通信的效率和安全性。</p><p><strong>网络架构：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>WASM 模块 → WASI Socket API → 主机网络栈</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>直接 TCP/UDP 通信，无需 JS 中介</span></span></code></pre></div><h2 id="开发实践" tabindex="-1">开发实践 <a class="header-anchor" href="#开发实践" aria-label="Permalink to &quot;开发实践&quot;">​</a></h2><h3 id="支持的语言与工具链" tabindex="-1">支持的语言与工具链 <a class="header-anchor" href="#支持的语言与工具链" aria-label="Permalink to &quot;支持的语言与工具链&quot;">​</a></h3><p>几乎所有主流的编程语言现在都支持以 WASI 为目标进行编译：</p><p><strong>C/C++ 开发流程：</strong></p><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">#include</span><span style="color:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    FILE</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> file </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> fopen</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;data.txt&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;r&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (file) {</span></span>
<span class="line"><span style="color:#F97583;">        char</span><span style="color:#FFAB70;"> buffer</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#B392F0;">        fgets</span><span style="color:#E1E4E8;">(buffer, </span><span style="color:#F97583;">sizeof</span><span style="color:#E1E4E8;">(buffer), file);</span></span>
<span class="line"><span style="color:#B392F0;">        printf</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;文件内容: </span><span style="color:#79B8FF;">%s\\n</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">, buffer);</span></span>
<span class="line"><span style="color:#B392F0;">        fclose</span><span style="color:#E1E4E8;">(file);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>编译命令：<code>clang --target=wasm32-wasi demo.c -o demo.wasm</code></p><p><strong>Rust 开发流程：</strong></p><div class="language-rust"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">use</span><span style="color:#B392F0;"> std</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">fs;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">fn</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-&gt;</span><span style="color:#B392F0;"> Result</span><span style="color:#E1E4E8;">&lt;(), </span><span style="color:#B392F0;">Box</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">dyn</span><span style="color:#E1E4E8;"> std</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">error</span><span style="color:#F97583;">::</span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">&gt;&gt; {</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> content </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> fs</span><span style="color:#F97583;">::</span><span style="color:#B392F0;">read_to_string</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;data.txt&quot;</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#B392F0;">    println!</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;文件内容: {}&quot;</span><span style="color:#E1E4E8;">, content);</span></span>
<span class="line"><span style="color:#B392F0;">    Ok</span><span style="color:#E1E4E8;">(())</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>配置：在 <code>Cargo.toml</code> 中设置 <code>target = &quot;wasm32-wasi&quot;</code></p><h3 id="运行时生态" tabindex="-1">运行时生态 <a class="header-anchor" href="#运行时生态" aria-label="Permalink to &quot;运行时生态&quot;">​</a></h3><p>有多种运行时支持 WASI，每个都有不同的重点领域：</p><ul><li><strong>Wasmtime</strong>：服务器端和非 Web 嵌入，支持组件</li><li><strong>WAMR</strong>：物联网、嵌入式设备和边缘计算</li><li><strong>WasmEdge</strong>：云原生和边缘计算</li><li><strong>wazero</strong>：无需 CGO 的 Go 库</li><li><strong>Wasmer</strong>：多平台支持</li></ul><h2 id="版本演进" tabindex="-1">版本演进 <a class="header-anchor" href="#版本演进" aria-label="Permalink to &quot;版本演进&quot;">​</a></h2><p>WASI 至今已经发布了两个里程碑版本，分别是 0.1 和 0.2 (有时也称为 Preview 1 和 Preview 2，或 P1 和 P2)。</p><p><strong>版本特性对比：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>WASI Preview 1 (0.1):</span></span>
<span class="line"><span>- 基础系统调用接口</span></span>
<span class="line"><span>- 类似 POSIX 的 API 设计</span></span>
<span class="line"><span>- 基础文件 I/O 和网络</span></span>
<span class="line"><span></span></span>
<span class="line"><span>WASI Preview 2 (0.2):  </span></span>
<span class="line"><span>- 组件模型支持</span></span>
<span class="line"><span>- 增强的合成能力</span></span>
<span class="line"><span>- 更精细的能力控制</span></span></code></pre></div><h2 id="安全性与可移植性优势" tabindex="-1">安全性与可移植性优势 <a class="header-anchor" href="#安全性与可移植性优势" aria-label="Permalink to &quot;安全性与可移植性优势&quot;">​</a></h2><h3 id="细粒度的安全控制" tabindex="-1">细粒度的安全控制 <a class="header-anchor" href="#细粒度的安全控制" aria-label="Permalink to &quot;细粒度的安全控制&quot;">​</a></h3><p>与传统的文件权限甚至 chroot 系统相比，WASI 提供了更健壮、更细粒度的程序控制。运行时可以将它启动的每个 Wasm 模块的每个实例放入一个单独的沙箱中，只包含该特定实例真正需要的最小、最不受特权限制的函数组合。</p><p><strong>安全沙箱示意图：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>WASI 运行时</span></span>
<span class="line"><span>├── 实例 A 沙箱: [文件 X 读写, 网络连接 Y]</span></span>
<span class="line"><span>├── 实例 B 沙箱: [文件 Z 只读]</span></span>
<span class="line"><span>└── 实例 C 沙箱: [定时器, 随机数]</span></span></code></pre></div><h3 id="真正的二进制兼容性" tabindex="-1">真正的二进制兼容性 <a class="header-anchor" href="#真正的二进制兼容性" aria-label="Permalink to &quot;真正的二进制兼容性&quot;">​</a></h3><p>WASI 使“一次编译，到处运行”成为现实。使用任何你想要的语言，然后编译一次，产生一个二进制文件，这个文件可以在任何识别 WebAssembly 的环境中安全地运行。</p><p><strong>可移植性对比：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>传统编译:</span></span>
<span class="line"><span>源码 → Linux 二进制 | Windows 二进制 | macOS 二进制</span></span>
<span class="line"><span></span></span>
<span class="line"><span>WASI 编译:</span></span>
<span class="line"><span>源码 → WASM + WASI → 任何 WASI 兼容的运行时</span></span></code></pre></div>`,59)])])}const g=a(p,[["render",o]]);export{u as __pageData,g as default};
