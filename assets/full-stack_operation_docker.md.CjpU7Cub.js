import{_ as a,c as n,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const F=JSON.parse('{"title":"Docker","description":"","frontmatter":{},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[{"level":3,"title":"核心概念","slug":"核心概念","link":"#核心概念","children":[]}]},{"level":2,"title":"核心特性","slug":"核心特性","link":"#核心特性","children":[{"level":3,"title":"轻量级与资源高效","slug":"轻量级与资源高效","link":"#轻量级与资源高效","children":[]},{"level":3,"title":"可移植性","slug":"可移植性","link":"#可移植性","children":[]},{"level":3,"title":"标准化与隔离性","slug":"标准化与隔离性","link":"#标准化与隔离性","children":[]}]},{"level":2,"title":"Docker 与传统虚拟化的区别","slug":"docker-与传统虚拟化的区别","link":"#docker-与传统虚拟化的区别","children":[]},{"level":2,"title":"Docker 架构","slug":"docker-架构","link":"#docker-架构","children":[{"level":3,"title":"核心组件","slug":"核心组件","link":"#核心组件","children":[]}]},{"level":2,"title":"常用操作","slug":"常用操作","link":"#常用操作","children":[{"level":3,"title":"Dockerfile 示例","slug":"dockerfile-示例","link":"#dockerfile-示例","children":[]},{"level":3,"title":"容器生命周期管理","slug":"容器生命周期管理","link":"#容器生命周期管理","children":[]},{"level":3,"title":"数据持久化","slug":"数据持久化","link":"#数据持久化","children":[]}]},{"level":2,"title":"Docker API 使用","slug":"docker-api-使用","link":"#docker-api-使用","children":[{"level":3,"title":"API 版本","slug":"api-版本","link":"#api-版本","children":[]},{"level":3,"title":"API 调用方式","slug":"api-调用方式","link":"#api-调用方式","children":[]},{"level":3,"title":"Registry API","slug":"registry-api","link":"#registry-api","children":[]},{"level":3,"title":"安全机制","slug":"安全机制","link":"#安全机制","children":[]}]},{"level":2,"title":"Docker 的优势与不足","slug":"docker-的优势与不足","link":"#docker-的优势与不足","children":[{"level":3,"title":"优势","slug":"优势","link":"#优势","children":[]},{"level":3,"title":"不足","slug":"不足","link":"#不足","children":[]}]}],"relativePath":"full-stack/operation/docker.md","filePath":"full-stack/operation/docker.md"}'),o={name:"full-stack/operation/docker.md"};function e(t,s,c,r,i,y){return l(),n("div",null,[...s[0]||(s[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /full-stack/operation/docker.md for this page in Markdown format</div><h1 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>Docker 是一个开源的<strong>容器化平台</strong>，它提供了一种将应用程序与其依赖环境打包成容器的解决方案。这些容器可以在任何支持 Docker 的环境中快速部署和运行，从而实现应用程序的轻松迁移和高效管理。</p><h3 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h3><ul><li><strong>镜像</strong>：Docker 镜像是一个<strong>只读模板</strong>，包含运行应用程序所需的一切：代码、运行时、系统工具、库和设置。它类似于虚拟机的快照，是容器的基础。</li><li><strong>容器</strong>：容器是镜像的<strong>运行实例</strong>。它是一个轻量级、可执行的软件包，包含运行应用所需的所有依赖项。你可以同时运行多个基于同一镜像的容器。</li><li><strong>Dockerfile</strong>：Dockerfile 是一个文本文件，包含一系列用于构建 Docker 镜像的指令。</li></ul><h2 id="核心特性" tabindex="-1">核心特性 <a class="header-anchor" href="#核心特性" aria-label="Permalink to &quot;核心特性&quot;">​</a></h2><h3 id="轻量级与资源高效" tabindex="-1">轻量级与资源高效 <a class="header-anchor" href="#轻量级与资源高效" aria-label="Permalink to &quot;轻量级与资源高效&quot;">​</a></h3><p>与传统虚拟机相比，Docker 容器更加轻量级，因为它们<strong>共享宿主机的操作系统内核</strong>，不需要为每个应用运行完整的操作系统。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>传统虚拟机架构：</span></span>
<span class="line"><span>+-------------------+-------------------+-------------------+</span></span>
<span class="line"><span>|     应用 A        |      应用 B       |      应用 C       |</span></span>
<span class="line"><span>+-------------------+-------------------+-------------------+</span></span>
<span class="line"><span>|    Guest OS A     |    Guest OS B     |    Guest OS C     |</span></span>
<span class="line"><span>+-------------------+-------------------+-------------------+</span></span>
<span class="line"><span>|               Hypervisor / 虚拟机监视器                   |</span></span>
<span class="line"><span>+-----------------------------------------------------------+</span></span>
<span class="line"><span>|                    宿主机操作系统                          |</span></span>
<span class="line"><span>+-----------------------------------------------------------+</span></span>
<span class="line"><span>|                      物理硬件                             |</span></span>
<span class="line"><span>+-----------------------------------------------------------+</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Docker容器架构：</span></span>
<span class="line"><span>+-------------------+-------------------+-------------------+</span></span>
<span class="line"><span>|    容器 A         |     容器 B        |     容器 C        |</span></span>
<span class="line"><span>+-------------------+-------------------+-------------------+</span></span>
<span class="line"><span>|              Docker 引擎 (容器运行时)                     |</span></span>
<span class="line"><span>+-----------------------------------------------------------+</span></span>
<span class="line"><span>|                    宿主机操作系统                          |</span></span>
<span class="line"><span>+-----------------------------------------------------------+</span></span>
<span class="line"><span>|                      物理硬件                             |</span></span>
<span class="line"><span>+-----------------------------------------------------------+</span></span></code></pre></div><p>这种架构使得 Docker 可以在同一台主机上运行更多的容器实例，从而<strong>提高资源利用率</strong>。</p><h3 id="可移植性" tabindex="-1">可移植性 <a class="header-anchor" href="#可移植性" aria-label="Permalink to &quot;可移植性&quot;">​</a></h3><p>Docker 容器可以在任何支持 Docker 的平台上运行，无论是物理服务器、虚拟机还是云服务环境。这种跨平台兼容性为应用程序的灵活部署提供了有力支持。</p><h3 id="标准化与隔离性" tabindex="-1">标准化与隔离性 <a class="header-anchor" href="#标准化与隔离性" aria-label="Permalink to &quot;标准化与隔离性&quot;">​</a></h3><p>Docker 提供了一种<strong>标准化的方式</strong>来打包和部署应用程序。这种标准化降低了开发人员在不同环境之间迁移应用的复杂度。</p><p>同时，Docker 为每个容器提供了一个<strong>隔离的运行环境</strong>，确保容器之间不会相互影响。这种隔离性有助于提高应用程序的安全性和稳定性。</p><h2 id="docker-与传统虚拟化的区别" tabindex="-1">Docker 与传统虚拟化的区别 <a class="header-anchor" href="#docker-与传统虚拟化的区别" aria-label="Permalink to &quot;Docker 与传统虚拟化的区别&quot;">​</a></h2><p>Docker 基于 Linux 内核的 <strong>Cgroup 和 namespace</strong> 功能，实现了进程级的虚拟化技术。</p><ul><li><strong>启动速度</strong>：Docker 容器可以在几秒钟内启动和关闭，而传统虚拟机通常需要数分钟</li><li><strong>资源消耗</strong>：Docker 容器共享主机内核，无需额外的操作系统开销，资源消耗更少</li><li><strong>性能</strong>：Docker 容器直接运行在主机内核上，性能接近原生</li></ul><h2 id="docker-架构" tabindex="-1">Docker 架构 <a class="header-anchor" href="#docker-架构" aria-label="Permalink to &quot;Docker 架构&quot;">​</a></h2><h3 id="核心组件" tabindex="-1">核心组件 <a class="header-anchor" href="#核心组件" aria-label="Permalink to &quot;核心组件&quot;">​</a></h3><p>Docker 采用客户端-服务器架构：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>+-------------+    Docker REST API    +---------------+</span></span>
<span class="line"><span>| Docker 客户端 | -------------------&gt; | Docker 守护进程 |</span></span>
<span class="line"><span>+-------------+                       +---------------+</span></span>
<span class="line"><span>                                            |</span></span>
<span class="line"><span>                                            | 管理</span></span>
<span class="line"><span>                                            v</span></span>
<span class="line"><span>                                      +---------------+</span></span>
<span class="line"><span>                                      |   容器运行时   |</span></span>
<span class="line"><span>                                      +---------------+</span></span>
<span class="line"><span>                                            |</span></span>
<span class="line"><span>                                            | 使用</span></span>
<span class="line"><span>                                            v</span></span>
<span class="line"><span>                                      +---------------+</span></span>
<span class="line"><span>                                      |    containerd |</span></span>
<span class="line"><span>                                      +---------------+</span></span>
<span class="line"><span>                                            |</span></span>
<span class="line"><span>                                            | 低层操作</span></span>
<span class="line"><span>                                            v</span></span>
<span class="line"><span>                                      +---------------+</span></span>
<span class="line"><span>                                      |     runc      |</span></span>
<span class="line"><span>                                      +---------------+</span></span></code></pre></div><ul><li><strong>Docker 守护进程</strong>：管理 Docker 对象，如镜像、容器、网络和卷</li><li><strong>Docker 客户端</strong>：用户与 Docker 交互的主要方式</li><li><strong>容器运行时</strong>：负责运行容器的组件，Docker 默认使用 <strong>runc</strong></li></ul><h2 id="常用操作" tabindex="-1">常用操作 <a class="header-anchor" href="#常用操作" aria-label="Permalink to &quot;常用操作&quot;">​</a></h2><h3 id="dockerfile-示例" tabindex="-1">Dockerfile 示例 <a class="header-anchor" href="#dockerfile-示例" aria-label="Permalink to &quot;Dockerfile 示例&quot;">​</a></h3><div class="language-dockerfile"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> ubuntu:22.04</span></span>
<span class="line"><span style="color:#F97583;">RUN</span><span style="color:#E1E4E8;"> apt-get update &amp;&amp; apt-get install -y python3 python3-pip</span></span>
<span class="line"><span style="color:#F97583;">COPY</span><span style="color:#E1E4E8;"> . /app</span></span>
<span class="line"><span style="color:#F97583;">WORKDIR</span><span style="color:#E1E4E8;"> /app</span></span>
<span class="line"><span style="color:#F97583;">RUN</span><span style="color:#E1E4E8;"> pip3 install -r requirements.txt</span></span>
<span class="line"><span style="color:#F97583;">EXPOSE</span><span style="color:#E1E4E8;"> 5000</span></span>
<span class="line"><span style="color:#F97583;">CMD</span><span style="color:#E1E4E8;"> [</span><span style="color:#9ECBFF;">&quot;python3&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;app.py&quot;</span><span style="color:#E1E4E8;">]</span></span></code></pre></div><p>构建镜像：</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> build</span><span style="color:#79B8FF;"> -t</span><span style="color:#9ECBFF;"> my-python-app</span><span style="color:#9ECBFF;"> .</span></span></code></pre></div><h3 id="容器生命周期管理" tabindex="-1">容器生命周期管理 <a class="header-anchor" href="#容器生命周期管理" aria-label="Permalink to &quot;容器生命周期管理&quot;">​</a></h3><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;"># 运行容器</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> run</span><span style="color:#79B8FF;"> -d</span><span style="color:#79B8FF;"> -p</span><span style="color:#9ECBFF;"> 5000:5000</span><span style="color:#79B8FF;"> --name</span><span style="color:#9ECBFF;"> my-app</span><span style="color:#9ECBFF;"> my-python-app</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 查看运行中的容器</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> ps</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 查看容器日志</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> logs</span><span style="color:#9ECBFF;"> my-app</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 进入容器</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> exec</span><span style="color:#79B8FF;"> -it</span><span style="color:#9ECBFF;"> my-app</span><span style="color:#9ECBFF;"> /bin/bash</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 停止容器</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> stop</span><span style="color:#9ECBFF;"> my-app</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 启动已停止的容器</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> start</span><span style="color:#9ECBFF;"> my-app</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 删除容器</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> rm</span><span style="color:#9ECBFF;"> my-app</span></span></code></pre></div><h3 id="数据持久化" tabindex="-1">数据持久化 <a class="header-anchor" href="#数据持久化" aria-label="Permalink to &quot;数据持久化&quot;">​</a></h3><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;"># 创建卷</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> volume</span><span style="color:#9ECBFF;"> create</span><span style="color:#9ECBFF;"> my-data</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 使用卷运行容器</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> run</span><span style="color:#79B8FF;"> -d</span><span style="color:#79B8FF;"> -v</span><span style="color:#9ECBFF;"> my-data:/data</span><span style="color:#79B8FF;"> --name</span><span style="color:#9ECBFF;"> data-container</span><span style="color:#9ECBFF;"> my-python-app</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 挂载主机目录</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> run</span><span style="color:#79B8FF;"> -d</span><span style="color:#79B8FF;"> -v</span><span style="color:#9ECBFF;"> /host/path:/container/path</span><span style="color:#79B8FF;"> --name</span><span style="color:#9ECBFF;"> mount-container</span><span style="color:#9ECBFF;"> my-python-app</span></span></code></pre></div><h2 id="docker-api-使用" tabindex="-1">Docker API 使用 <a class="header-anchor" href="#docker-api-使用" aria-label="Permalink to &quot;Docker API 使用&quot;">​</a></h2><p>Docker 提供了丰富的 API 用于管理和操作 Docker 容器、镜像、网络和数据卷等资源。</p><h3 id="api-版本" tabindex="-1">API 版本 <a class="header-anchor" href="#api-版本" aria-label="Permalink to &quot;API 版本&quot;">​</a></h3><p>Docker API 分为三个版本：</p><ul><li><strong>V1</strong>：Docker 最初的 API 版本，目前已被废弃</li><li><strong>V2</strong>：Docker 现在的稳定版本 API，与 Docker CLI 和 Docker Engine 完全兼容</li><li><strong>V3</strong>：Docker 的最新 API 版本 (alpha 版本)，提供 Swarm、Network、Plugin 等新特性的支持</li></ul><h3 id="api-调用方式" tabindex="-1">API 调用方式 <a class="header-anchor" href="#api-调用方式" aria-label="Permalink to &quot;API 调用方式&quot;">​</a></h3><h4 id="docker-cli" tabindex="-1">Docker CLI <a class="header-anchor" href="#docker-cli" aria-label="Permalink to &quot;Docker CLI&quot;">​</a></h4><p>Docker CLI 是 Docker 命令行工具，可以通过命令行界面来管理和操作 Docker 引擎。Docker CLI 实际上是对 Docker API 的一层封装，它可以直接调用 Docker API 来完成相应的操作。</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;"># 使用 Docker CLI 启动一个新的 Docker 容器</span></span>
<span class="line"><span style="color:#B392F0;">docker</span><span style="color:#9ECBFF;"> run</span><span style="color:#79B8FF;"> -d</span><span style="color:#79B8FF;"> -p</span><span style="color:#9ECBFF;"> 8080:80</span><span style="color:#9ECBFF;"> nginx:latest</span></span></code></pre></div><h4 id="docker-sdk" tabindex="-1">Docker SDK <a class="header-anchor" href="#docker-sdk" aria-label="Permalink to &quot;Docker SDK&quot;">​</a></h4><p>Docker SDK 是一组编程语言特定的 API，用于访问和管理 Docker 引擎。Docker SDK 提供了一组简单的 API，可以直接在程序中调用而无需手动构造 HTTP 请求和解析响应。</p><p><strong>Python 示例：</strong></p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> docker</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">client </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> docker.from_env()</span></span>
<span class="line"><span style="color:#E1E4E8;">container </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> client.containers.run(</span><span style="color:#9ECBFF;">&#39;nginx:latest&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">detach</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">True</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">ports</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{</span><span style="color:#9ECBFF;">&#39;80/tcp&#39;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&#39;8080&#39;</span><span style="color:#E1E4E8;">})</span></span>
<span class="line"><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(container.id)</span></span></code></pre></div><p><strong>Node.js 示例：</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> Docker</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;dockerode&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> docker</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Docker</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 列出所有容器</span></span>
<span class="line"><span style="color:#E1E4E8;">docker.</span><span style="color:#B392F0;">listContainers</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">err</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">containers</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (err) </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> err;</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(containers);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 运行新容器</span></span>
<span class="line"><span style="color:#E1E4E8;">docker.</span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;nginx:latest&#39;</span><span style="color:#E1E4E8;">, [</span><span style="color:#9ECBFF;">&#39;ls&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;-la&#39;</span><span style="color:#E1E4E8;">], process.stdout, (</span><span style="color:#FFAB70;">err</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (err) </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> err;</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(data);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h4 id="http-restful-api" tabindex="-1">HTTP RESTful API <a class="header-anchor" href="#http-restful-api" aria-label="Permalink to &quot;HTTP RESTful API&quot;">​</a></h4><p>HTTP RESTful API 是 Docker API 最基本的调用方式，通过 HTTP 请求和响应来管理和操作 Docker 引擎。</p><p><strong>列出所有容器：</strong></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">curl</span><span style="color:#79B8FF;"> -X</span><span style="color:#9ECBFF;"> GET</span><span style="color:#9ECBFF;"> http://localhost:2375/containers/json</span></span></code></pre></div><p><strong>创建新容器：</strong></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">curl</span><span style="color:#79B8FF;"> -X</span><span style="color:#9ECBFF;"> POST</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#79B8FF;">  -H</span><span style="color:#9ECBFF;"> &quot;Content-Type: application/json&quot;</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#79B8FF;">  -d</span><span style="color:#9ECBFF;"> &#39;{</span></span>
<span class="line"><span style="color:#9ECBFF;">    &quot;Image&quot;: &quot;nginx:latest&quot;,</span></span>
<span class="line"><span style="color:#9ECBFF;">    &quot;HostConfig&quot;: {</span></span>
<span class="line"><span style="color:#9ECBFF;">      &quot;PortBindings&quot;: {</span></span>
<span class="line"><span style="color:#9ECBFF;">        &quot;80/tcp&quot;: [{ &quot;HostPort&quot;: &quot;8080&quot; }]</span></span>
<span class="line"><span style="color:#9ECBFF;">      }</span></span>
<span class="line"><span style="color:#9ECBFF;">    }</span></span>
<span class="line"><span style="color:#9ECBFF;">  }&#39;</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#9ECBFF;">  http://localhost:2375/containers/create</span></span></code></pre></div><p><strong>启动容器：</strong></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">curl</span><span style="color:#79B8FF;"> -X</span><span style="color:#9ECBFF;"> POST</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#9ECBFF;">  http://localhost:2375/containers/</span><span style="color:#F97583;">&lt;</span><span style="color:#9ECBFF;">container_i</span><span style="color:#E1E4E8;">d</span><span style="color:#F97583;">&gt;</span><span style="color:#9ECBFF;">/start</span></span></code></pre></div><h3 id="registry-api" tabindex="-1">Registry API <a class="header-anchor" href="#registry-api" aria-label="Permalink to &quot;Registry API&quot;">​</a></h3><p>Docker Registry API 是 Docker Registry 的 REST API，它简化了镜像和仓库的存储。</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;"># 取出镜像层</span></span>
<span class="line"><span style="color:#B392F0;">GET</span><span style="color:#9ECBFF;"> /v1/images/</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">image_id</span><span style="color:#E1E4E8;">)</span><span style="color:#9ECBFF;">/layer</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 检索镜像</span></span>
<span class="line"><span style="color:#B392F0;">GET</span><span style="color:#9ECBFF;"> /v1/images/</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">image_id</span><span style="color:#E1E4E8;">)</span><span style="color:#9ECBFF;">/json</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 获取库里所有的标签或者指定标签</span></span>
<span class="line"><span style="color:#B392F0;">GET</span><span style="color:#9ECBFF;"> /v1/repositories/</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">namespace</span><span style="color:#E1E4E8;">)</span><span style="color:#9ECBFF;">/</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">repository</span><span style="color:#E1E4E8;">)</span><span style="color:#9ECBFF;">/tags</span></span>
<span class="line"><span style="color:#B392F0;">GET</span><span style="color:#9ECBFF;"> /v1/repositories/</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">namespace</span><span style="color:#E1E4E8;">)</span><span style="color:#9ECBFF;">/</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">repository</span><span style="color:#E1E4E8;">)</span><span style="color:#9ECBFF;">/tags/</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">tag*</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 删除标签</span></span>
<span class="line"><span style="color:#B392F0;">DELETE</span><span style="color:#9ECBFF;"> /v1/repositories/</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">namespace</span><span style="color:#E1E4E8;">)</span><span style="color:#9ECBFF;">/</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">repository</span><span style="color:#E1E4E8;">)</span><span style="color:#9ECBFF;">/tags/</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">tag*</span><span style="color:#E1E4E8;">)</span></span></code></pre></div><h3 id="安全机制" tabindex="-1">安全机制 <a class="header-anchor" href="#安全机制" aria-label="Permalink to &quot;安全机制&quot;">​</a></h3><h4 id="tls-加密" tabindex="-1">TLS 加密 <a class="header-anchor" href="#tls-加密" aria-label="Permalink to &quot;TLS 加密&quot;">​</a></h4><p>Docker API 支持基于 TLS 的加密机制，可以通过 HTTPS 协议来加密 Docker API 的通信，防止数据在传输过程中被篡改或窃取。</p><p><strong>生成证书和密钥：</strong></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">openssl</span><span style="color:#9ECBFF;"> req</span><span style="color:#79B8FF;"> -newkey</span><span style="color:#9ECBFF;"> rsa:4096</span><span style="color:#79B8FF;"> -nodes</span><span style="color:#79B8FF;"> -keyout</span><span style="color:#9ECBFF;"> key.pem</span><span style="color:#79B8FF;"> -x509</span><span style="color:#79B8FF;"> -days</span><span style="color:#79B8FF;"> 365</span><span style="color:#79B8FF;"> -out</span><span style="color:#9ECBFF;"> cert.pem</span></span></code></pre></div><p><strong>配置 Docker 引擎使用 TLS：</strong></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">dockerd</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#79B8FF;">  --tlsverify</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#79B8FF;">  --tlscacert=ca.pem</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#79B8FF;">  --tlscert=cert.pem</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#79B8FF;">  --tlskey=key.pem</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#79B8FF;">  -H=0.0.0.0:2376</span></span></code></pre></div><h4 id="认证授权" tabindex="-1">认证授权 <a class="header-anchor" href="#认证授权" aria-label="Permalink to &quot;认证授权&quot;">​</a></h4><p>Docker API 支持基于 OAuth2.0 的认证和授权机制，可以通过访问令牌来验证客户端的身份并授权客户端访问 Docker API 的特定资源。</p><p><strong>获取访问令牌：</strong></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">curl</span><span style="color:#79B8FF;"> -X</span><span style="color:#9ECBFF;"> POST</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#79B8FF;">  -d</span><span style="color:#9ECBFF;"> &quot;client_id=&lt;CLIENT_ID&gt;&amp;client_secret=&lt;CLIENT_SECRET&gt;&amp;grant_type=client_credentials&quot;</span><span style="color:#79B8FF;"> \\</span></span>
<span class="line"><span style="color:#9ECBFF;">  http://localhost:4180/token</span></span></code></pre></div><p><strong>使用访问令牌访问 API：</strong></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">curl</span><span style="color:#79B8FF;"> -H</span><span style="color:#9ECBFF;"> &quot;Authorization: Bearer &lt;ACCESS_TOKEN&gt;&quot;</span><span style="color:#9ECBFF;"> http://localhost:2375/containers/json</span></span></code></pre></div><h2 id="docker-的优势与不足" tabindex="-1">Docker 的优势与不足 <a class="header-anchor" href="#docker-的优势与不足" aria-label="Permalink to &quot;Docker 的优势与不足&quot;">​</a></h2><h3 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h3><ol><li><strong>快速部署</strong>：短时间内可以部署成百上千个应用，更快速交付到线上。</li><li><strong>简化配置</strong>：将运行环境打包保存至容器，使用时直接启动即可。</li><li><strong>快速迁移和扩展</strong>：可跨平台运行在物理机、虚拟公有云等环境，良好的兼容性可以方便将应用从 A 宿主机迁移到 B 宿主机，甚至是 A 平台迁移到 B 平台。</li><li><strong>提高开发效率</strong>：Docker 容器可以将应用程序和其依赖项打包在一起，形成一个独立的容器。开发人员可以快速部署、测试和调试应用程序，无需担心环境差异导致的问题。</li></ol><h3 id="不足" tabindex="-1">不足 <a class="header-anchor" href="#不足" aria-label="Permalink to &quot;不足&quot;">​</a></h3><ol><li><strong>隔离性</strong>：各应用之间的隔离不如虚拟机彻底，因为同一台宿主机所有 Docker 的容器公用宿主机内核。</li><li><strong>安全性问题</strong>：Docker 容器虽然提供了隔离性，但它们与宿主机共享相同的内核。如果容器配置不当或存在漏洞，可能会对整个宿主机造成影响。</li><li><strong>持久化存储需求</strong>：Docker 容器的默认存储是临时性的。若需要实现数据的持久化保存，则需要通过额外的配置来挂载宿主机上的目录或使用专门的持久化存储卷。</li><li><strong>网络配置复杂性</strong>：Docker 容器的网络配置可能相对复杂。在构建跨容器的通信网络时，开发人员需要熟悉 Docker 的网络模型和配置方法，以确保容器之间的正常通信。</li></ol>`,77)])])}const E=a(o,[["render",e]]);export{F as __pageData,E as default};
