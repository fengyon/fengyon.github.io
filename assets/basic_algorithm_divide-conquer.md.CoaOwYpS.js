import{_ as n,c as a,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const F=JSON.parse('{"title":"递归与分治","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是递归","slug":"什么是递归","link":"#什么是递归","children":[{"level":3,"title":"递归三要素","slug":"递归三要素","link":"#递归三要素","children":[]}]},{"level":2,"title":"递归类型","slug":"递归类型","link":"#递归类型","children":[{"level":3,"title":"直接递归","slug":"直接递归","link":"#直接递归","children":[]},{"level":3,"title":"间接递归","slug":"间接递归","link":"#间接递归","children":[]}]},{"level":2,"title":"递归应用场景","slug":"递归应用场景","link":"#递归应用场景","children":[{"level":3,"title":"树形结构遍历","slug":"树形结构遍历","link":"#树形结构遍历","children":[]},{"level":3,"title":"组合问题求解","slug":"组合问题求解","link":"#组合问题求解","children":[]}]},{"level":2,"title":"递归复杂度分析","slug":"递归复杂度分析","link":"#递归复杂度分析","children":[{"level":3,"title":"时间复杂度","slug":"时间复杂度","link":"#时间复杂度","children":[]},{"level":3,"title":"空间复杂度","slug":"空间复杂度","link":"#空间复杂度","children":[]}]},{"level":2,"title":"递归优化技术","slug":"递归优化技术","link":"#递归优化技术","children":[{"level":3,"title":"记忆化","slug":"记忆化","link":"#记忆化","children":[]},{"level":3,"title":"尾递归","slug":"尾递归","link":"#尾递归","children":[]}]},{"level":2,"title":"什么是分治","slug":"什么是分治","link":"#什么是分治","children":[]},{"level":2,"title":"分治算法模式","slug":"分治算法模式","link":"#分治算法模式","children":[{"level":3,"title":"二分分解","slug":"二分分解","link":"#二分分解","children":[]},{"level":3,"title":"多路分解","slug":"多路分解","link":"#多路分解","children":[]}]},{"level":2,"title":"分治应用实例","slug":"分治应用实例","link":"#分治应用实例","children":[{"level":3,"title":"快速排序","slug":"快速排序","link":"#快速排序","children":[]},{"level":3,"title":"最近点对问题","slug":"最近点对问题","link":"#最近点对问题","children":[]}]},{"level":2,"title":"分治复杂度分析","slug":"分治复杂度分析","link":"#分治复杂度分析","children":[]}],"relativePath":"basic/algorithm/divide-conquer.md","filePath":"basic/algorithm/divide-conquer.md"}'),o={name:"basic/algorithm/divide-conquer.md"};function e(c,s,t,r,E,i){return l(),a("div",null,[...s[0]||(s[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /basic/algorithm/divide-conquer.md for this page in Markdown format</div><h1 id="递归与分治" tabindex="-1">递归与分治 <a class="header-anchor" href="#递归与分治" aria-label="Permalink to &quot;递归与分治&quot;">​</a></h1><h2 id="什么是递归" tabindex="-1">什么是递归 <a class="header-anchor" href="#什么是递归" aria-label="Permalink to &quot;什么是递归&quot;">​</a></h2><p>递归是函数直接或间接调用自身的编程技巧。它将复杂问题分解为相似的子问题，通过不断缩小问题规模直至达到基本情况。</p><p>特点：</p><ul><li>自我调用：函数在执行过程中调用自身</li><li>基本情况：必须有终止条件防止无限递归</li><li>栈机制：每次调用创建新的栈帧，后进先出</li><li>问题分解：将大问题转化为相似的小问题</li></ul><p>示意图 (函数调用栈)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>factorial(3)</span></span>
<span class="line"><span>  → factorial(2)</span></span>
<span class="line"><span>    → factorial(1)</span></span>
<span class="line"><span>      → factorial(0) 返回1</span></span>
<span class="line"><span>    返回1*1=1</span></span>
<span class="line"><span>  返回2*1=2</span></span>
<span class="line"><span>返回3*2=6</span></span></code></pre></div><h3 id="递归三要素" tabindex="-1">递归三要素 <a class="header-anchor" href="#递归三要素" aria-label="Permalink to &quot;递归三要素&quot;">​</a></h3><p>成功的递归实现需要三个关键要素：基本情况、递归情况和进步情况。</p><p>特点：</p><ul><li>基本情况：最简单情形的直接解答</li><li>递归情况：将问题分解为更小的子问题</li><li>进步情况：确保每次递归向基本情况前进</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 阶乘函数示例</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> factorial</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 基本情况</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">===</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">  // 递归情况 &amp; 进步情况 (n-1)</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">*</span><span style="color:#B392F0;"> factorial</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="递归类型" tabindex="-1">递归类型 <a class="header-anchor" href="#递归类型" aria-label="Permalink to &quot;递归类型&quot;">​</a></h2><h3 id="直接递归" tabindex="-1">直接递归 <a class="header-anchor" href="#直接递归" aria-label="Permalink to &quot;直接递归&quot;">​</a></h3><p>函数直接调用自身，是最常见的递归形式。</p><p>特点：</p><ul><li>明显调用：代码中直接可见自我调用</li><li>易于理解：递归关系直观明确</li><li>栈深度：与问题规模线性相关</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 斐波那契数列 - 直接递归</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> fibonacci</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">&lt;=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> n;</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> fibonacci</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">+</span><span style="color:#B392F0;"> fibonacci</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>示意图 (斐波那契递归树)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>fib(4)</span></span>
<span class="line"><span>├── fib(3)</span></span>
<span class="line"><span>│   ├── fib(2)</span></span>
<span class="line"><span>│   │   ├── fib(1)=1</span></span>
<span class="line"><span>│   │   └── fib(0)=0</span></span>
<span class="line"><span>│   └── fib(1)=1</span></span>
<span class="line"><span>└── fib(2)</span></span>
<span class="line"><span>    ├── fib(1)=1</span></span>
<span class="line"><span>    └── fib(0)=0</span></span></code></pre></div><h3 id="间接递归" tabindex="-1">间接递归 <a class="header-anchor" href="#间接递归" aria-label="Permalink to &quot;间接递归&quot;">​</a></h3><p>多个函数相互调用形成递归链，也称为相互递归。</p><p>特点：</p><ul><li>循环依赖：函数 A 调用 B，B 又调用 A</li><li>复杂逻辑：适合状态机或交替处理场景</li><li>调试挑战：调用路径不如直接递归清晰</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 奇偶判断 - 间接递归</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> isEven</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">===</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#79B8FF;"> true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> isOdd</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> isOdd</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">===</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#79B8FF;"> false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> isEven</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>示意图 (间接递归调用)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>isEven(3)</span></span>
<span class="line"><span>  → isOdd(2)</span></span>
<span class="line"><span>    → isEven(1)</span></span>
<span class="line"><span>      → isOdd(0) 返回false</span></span>
<span class="line"><span>    返回false</span></span>
<span class="line"><span>  返回false</span></span>
<span class="line"><span>返回false</span></span></code></pre></div><h2 id="递归应用场景" tabindex="-1">递归应用场景 <a class="header-anchor" href="#递归应用场景" aria-label="Permalink to &quot;递归应用场景&quot;">​</a></h2><h3 id="树形结构遍历" tabindex="-1">树形结构遍历 <a class="header-anchor" href="#树形结构遍历" aria-label="Permalink to &quot;树形结构遍历&quot;">​</a></h3><p>递归天然适合处理树形数据，如 DOM 树、文件系统、组织架构等。</p><p>特点：</p><ul><li>自相似性：子树与整树结构相同</li><li>深度优先：自然实现深度优先遍历</li><li>简洁代码：相比迭代方法代码更简洁</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 深度优先遍历DOM树</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> traverseDOM</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">node</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">callback</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">node) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#B392F0;">  callback</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">  // 递归处理所有子节点</span></span>
<span class="line"><span style="color:#F97583;">  for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> child</span><span style="color:#F97583;"> of</span><span style="color:#E1E4E8;"> node.children) {</span></span>
<span class="line"><span style="color:#B392F0;">    traverseDOM</span><span style="color:#E1E4E8;">(child, callback);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>示意图 (DOM 树遍历)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>div</span></span>
<span class="line"><span>├── h1</span></span>
<span class="line"><span>├── p</span></span>
<span class="line"><span>│   ├── span</span></span>
<span class="line"><span>│   └── strong</span></span>
<span class="line"><span>└── ul</span></span>
<span class="line"><span>    ├── li</span></span>
<span class="line"><span>    └── li</span></span>
<span class="line"><span>遍历顺序: div → h1 → p → span → strong → ul → li → li</span></span></code></pre></div><h3 id="组合问题求解" tabindex="-1">组合问题求解 <a class="header-anchor" href="#组合问题求解" aria-label="Permalink to &quot;组合问题求解&quot;">​</a></h3><p>递归适合解决需要尝试所有可能组合的问题，如排列、子集生成等。</p><p>特点：</p><ul><li>穷举搜索：系统性地探索所有可能性</li><li>回溯机制：通过递归栈自然实现回溯</li><li>解空间树：将问题建模为树形搜索空间</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 生成所有子集</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> subsets</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">nums</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> result</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [];</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  function</span><span style="color:#B392F0;"> backtrack</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">start</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">current</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    result.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">([</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">current]);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> start; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> nums.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      current.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(nums[i]);</span></span>
<span class="line"><span style="color:#B392F0;">      backtrack</span><span style="color:#E1E4E8;">(i </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">, current);</span></span>
<span class="line"><span style="color:#E1E4E8;">      current.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 回溯</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#B392F0;">  backtrack</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, []);</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> result;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>示意图 (子集生成)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>nums = [1,2,3]</span></span>
<span class="line"><span>[]</span></span>
<span class="line"><span>[1]</span></span>
<span class="line"><span>[1,2]</span></span>
<span class="line"><span>[1,2,3]</span></span>
<span class="line"><span>[1,3]</span></span>
<span class="line"><span>[2]</span></span>
<span class="line"><span>[2,3]</span></span>
<span class="line"><span>[3]</span></span></code></pre></div><h2 id="递归复杂度分析" tabindex="-1">递归复杂度分析 <a class="header-anchor" href="#递归复杂度分析" aria-label="Permalink to &quot;递归复杂度分析&quot;">​</a></h2><h3 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h3><p>递归算法的时间复杂度通常通过递推关系式分析。</p><p>特点：</p><ul><li>递推方程：T(n) = aT(n/b) + f(n)</li><li>递归树：可视化递归调用和每层工作量</li><li>主定理：快速求解常见递推式的时间复杂度</li></ul><p>示意图 (递归树分析)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>T(n) = 2T(n/2) + n</span></span>
<span class="line"><span>层次:</span></span>
<span class="line"><span>0: n</span></span>
<span class="line"><span>1: n/2 + n/2 = n</span></span>
<span class="line"><span>2: n/4 × 4 = n</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>每层工作量: n</span></span>
<span class="line"><span>层数: log n</span></span>
<span class="line"><span>总工作量: O(n log n)</span></span></code></pre></div><h3 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-label="Permalink to &quot;空间复杂度&quot;">​</a></h3><p>递归的空间复杂度主要由调用栈深度决定。</p><p>特点：</p><ul><li>栈深度：最坏情况下与递归深度成正比</li><li>尾递归：某些语言可优化为常数空间</li><li>辅助空间：除栈外算法使用的额外空间</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 不同递归的空间复杂度示例</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> linearRecursion</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">===</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(n);</span></span>
<span class="line"><span style="color:#B392F0;">  linearRecursion</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// O(n) 空间</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> binaryRecursion</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">&lt;=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> n;</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> binaryRecursion</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">+</span><span style="color:#B392F0;"> binaryRecursion</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// O(n) 空间（调用栈深度）</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="递归优化技术" tabindex="-1">递归优化技术 <a class="header-anchor" href="#递归优化技术" aria-label="Permalink to &quot;递归优化技术&quot;">​</a></h2><h3 id="记忆化" tabindex="-1">记忆化 <a class="header-anchor" href="#记忆化" aria-label="Permalink to &quot;记忆化&quot;">​</a></h3><p>存储已计算的结果避免重复计算，显著提升性能。</p><p>特点：</p><ul><li>空间换时间：用缓存存储中间结果</li><li>重复子问题：适合存在重叠子问题的递归</li><li>透明优化：不改变递归逻辑，只添加缓存</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 记忆化斐波那契</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> memoizedFibonacci</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> cache</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Map</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  function</span><span style="color:#B392F0;"> fib</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">&lt;=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> n;</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (cache.</span><span style="color:#B392F0;">has</span><span style="color:#E1E4E8;">(n)) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> cache.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(n);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> result</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> fib</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">+</span><span style="color:#B392F0;"> fib</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    cache.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(n, result);</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> result;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> fib;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>示意图 (记忆化效果)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>无记忆化: fib(5)计算fib(4),fib(3),fib(2),fib(1),fib(0)多次</span></span>
<span class="line"><span>有记忆化: fib(2),fib(3),fib(4)只计算一次，后续直接从缓存读取</span></span></code></pre></div><h3 id="尾递归" tabindex="-1">尾递归 <a class="header-anchor" href="#尾递归" aria-label="Permalink to &quot;尾递归&quot;">​</a></h3><p>递归调用是函数的最后操作，可被编译器优化为迭代。</p><p>特点：</p><ul><li>栈帧复用：当前栈帧可被下一次调用重用</li><li>常数空间：优化后空间复杂度为 O(1)</li><li>语言支持：依赖语言运行时的尾调用优化</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 尾递归阶乘</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> tailRecursiveFactorial</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">accumulator</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">===</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> accumulator;</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> tailRecursiveFactorial</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">, n </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> accumulator);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>示意图 (尾调用优化)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>普通递归: factorial(3) → 3*factorial(2) → 等待结果</span></span>
<span class="line"><span>尾递归: factorial(3,1) → factorial(2,3) → factorial(1,6) → factorial(0,6)</span></span>
<span class="line"><span>栈帧可复用，不需要保存中间状态</span></span></code></pre></div><h2 id="什么是分治" tabindex="-1">什么是分治 <a class="header-anchor" href="#什么是分治" aria-label="Permalink to &quot;什么是分治&quot;">​</a></h2><p>分治策略将问题分解为多个子问题，递归解决子问题后合并结果。包含三个步骤：分解、解决、合并。</p><p>特点：</p><ul><li>问题分解：将原问题划分为多个相似子问题</li><li>独立求解：子问题相互独立，可并行解决</li><li>结果合并：将子问题解合并为原问题解</li><li>递归基础：通常用递归实现分解过程</li></ul><p>示意图 (分治流程)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>原问题</span></span>
<span class="line"><span>    ↓ 分解</span></span>
<span class="line"><span>[子问题1][子问题2][子问题3]...</span></span>
<span class="line"><span>    ↓ 解决</span></span>
<span class="line"><span>[解1][解2][解3]...</span></span>
<span class="line"><span>    ↓ 合并</span></span>
<span class="line"><span>最终解</span></span></code></pre></div><h2 id="分治算法模式" tabindex="-1">分治算法模式 <a class="header-anchor" href="#分治算法模式" aria-label="Permalink to &quot;分治算法模式&quot;">​</a></h2><h3 id="二分分解" tabindex="-1">二分分解 <a class="header-anchor" href="#二分分解" aria-label="Permalink to &quot;二分分解&quot;">​</a></h3><p>将问题划分为两个规模相近的子问题，是最常见的分治模式。</p><p>特点：</p><ul><li>平衡划分：尽量保持子问题规模相等</li><li>对数深度：递归树深度为 O(log n)</li><li>高效合并：合并操作时间复杂度通常为 O(n)</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 归并排序 - 典型的分治算法</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> mergeSort</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">arr</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (arr.</span><span style="color:#79B8FF;">length</span><span style="color:#F97583;"> &lt;=</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> arr;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">  // 分解</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> mid</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">floor</span><span style="color:#E1E4E8;">(arr.</span><span style="color:#79B8FF;">length</span><span style="color:#F97583;"> /</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> left</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> mergeSort</span><span style="color:#E1E4E8;">(arr.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, mid));</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> right</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> mergeSort</span><span style="color:#E1E4E8;">(arr.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(mid));</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">  // 合并</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> merge</span><span style="color:#E1E4E8;">(left, right);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> merge</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">left</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">right</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> result</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [];</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">, j </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> left.</span><span style="color:#79B8FF;">length</span><span style="color:#F97583;"> &amp;&amp;</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (left[i] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> right[j]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      result.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(left[i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">]);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      result.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(right[j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">]);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> result.</span><span style="color:#B392F0;">concat</span><span style="color:#E1E4E8;">(left.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(i)).</span><span style="color:#B392F0;">concat</span><span style="color:#E1E4E8;">(right.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(j));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>示意图 (归并排序分治)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[8,3,5,1,9,2,7,4]</span></span>
<span class="line"><span>        ↓ 分解</span></span>
<span class="line"><span>[8,3,5,1]   [9,2,7,4]</span></span>
<span class="line"><span>    ↓           ↓</span></span>
<span class="line"><span>[8,3] [5,1] [9,2] [7,4]</span></span>
<span class="line"><span> ↓     ↓     ↓     ↓</span></span>
<span class="line"><span>[8][3][5][1][9][2][7][4]  // 基本情况</span></span>
<span class="line"><span>    ↓ 合并  ↓     ↓ 合并  ↓</span></span>
<span class="line"><span>[3,8] [1,5] [2,9] [4,7]</span></span>
<span class="line"><span>    ↓           ↓</span></span>
<span class="line"><span>[1,3,5,8]   [2,4,7,9]</span></span>
<span class="line"><span>        ↓ 合并</span></span>
<span class="line"><span>[1,2,3,4,5,7,8,9]</span></span></code></pre></div><h3 id="多路分解" tabindex="-1">多路分解 <a class="header-anchor" href="#多路分解" aria-label="Permalink to &quot;多路分解&quot;">​</a></h3><p>将问题划分为多个子问题，适合可自然分割为多个部分的问题。</p><p>特点：</p><ul><li>并行潜力：多个子问题可并行求解</li><li>复杂合并：合并多个子问题结果可能更复杂</li><li>适用场景：矩阵运算、快速傅里叶变换等</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 矩阵乘法分治 - Strassen算法简化版</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> matrixMultiply</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">A</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">B</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> n</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> A</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">  // 基本情况：1x1矩阵</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (n </span><span style="color:#F97583;">===</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> [[</span><span style="color:#79B8FF;">A</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">][</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> B</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">][</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]]];</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">  // 分解为4个子矩阵</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> mid</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> A11</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> partitionMatrix</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, mid, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, mid);</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> A12</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> partitionMatrix</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, mid, mid, n);</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> A21</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> partitionMatrix</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A</span><span style="color:#E1E4E8;">, mid, n, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, mid);</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> A22</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> partitionMatrix</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A</span><span style="color:#E1E4E8;">, mid, n, mid, n);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> B11</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> partitionMatrix</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">B</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, mid, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, mid);</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> B12</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> partitionMatrix</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">B</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, mid, mid, n);</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> B21</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> partitionMatrix</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">B</span><span style="color:#E1E4E8;">, mid, n, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, mid);</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> B22</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> partitionMatrix</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">B</span><span style="color:#E1E4E8;">, mid, n, mid, n);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">  // 递归计算子问题</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> C11</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> addMatrices</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#B392F0;">    matrixMultiply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A11</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">B11</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#B392F0;">    matrixMultiply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A12</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">B21</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> C12</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> addMatrices</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#B392F0;">    matrixMultiply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A11</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">B12</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#B392F0;">    matrixMultiply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A12</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">B22</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> C21</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> addMatrices</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#B392F0;">    matrixMultiply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A21</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">B11</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#B392F0;">    matrixMultiply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A22</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">B21</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> C22</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> addMatrices</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#B392F0;">    matrixMultiply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A21</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">B12</span><span style="color:#E1E4E8;">),</span></span>
<span class="line"><span style="color:#B392F0;">    matrixMultiply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">A22</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">B22</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">  // 合并结果</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> combineMatrices</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">C11</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">C12</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">C21</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">C22</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="分治应用实例" tabindex="-1">分治应用实例 <a class="header-anchor" href="#分治应用实例" aria-label="Permalink to &quot;分治应用实例&quot;">​</a></h2><h3 id="快速排序" tabindex="-1">快速排序 <a class="header-anchor" href="#快速排序" aria-label="Permalink to &quot;快速排序&quot;">​</a></h3><p>快速排序通过选择基准元素划分数组，递归排序子数组。</p><p>特点：</p><ul><li>原地排序：不需要额外存储空间</li><li>平均效率：平均情况下 O(n log n) 时间复杂度</li><li>基准选择：性能受基准选择策略影响</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 快速排序实现</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> quickSort</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">arr</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">low</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">high</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> arr.</span><span style="color:#79B8FF;">length</span><span style="color:#F97583;"> -</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (low </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> high) {</span></span>
<span class="line"><span style="color:#6A737D;">    // 分解：分区操作</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> pivotIndex</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> partition</span><span style="color:#E1E4E8;">(arr, low, high);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 解决：递归排序子数组</span></span>
<span class="line"><span style="color:#B392F0;">    quickSort</span><span style="color:#E1E4E8;">(arr, low, pivotIndex </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#B392F0;">    quickSort</span><span style="color:#E1E4E8;">(arr, pivotIndex </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">, high);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> arr;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> partition</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">arr</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">low</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">high</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> pivot</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> arr[high];</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> low </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> low; j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> high; j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (arr[j] </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> pivot) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      [arr[i], arr[j]] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [arr[j], arr[i]];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  [arr[i </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">], arr[high]] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [arr[high], arr[i </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">]];</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>示意图 (快速排序分区)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>数组: [3,8,2,5,1,4,7,6] 基准=6</span></span>
<span class="line"><span>分区过程:</span></span>
<span class="line"><span>i=-1, j=0: 3&lt;=6 → i=0, 交换arr[0]与自身 [3,8,2,5,1,4,7,6]</span></span>
<span class="line"><span>j=1: 8&gt;6 → 无操作</span></span>
<span class="line"><span>j=2: 2&lt;=6 → i=1, 交换arr[1]和arr[2] [3,2,8,5,1,4,7,6]</span></span>
<span class="line"><span>j=3: 5&lt;=6 → i=2, 交换arr[2]和arr[3] [3,2,5,8,1,4,7,6]</span></span>
<span class="line"><span>j=4: 1&lt;=6 → i=3, 交换arr[3]和arr[4] [3,2,5,1,8,4,7,6]</span></span>
<span class="line"><span>j=5: 4&lt;=6 → i=4, 交换arr[4]和arr[5] [3,2,5,1,4,8,7,6]</span></span>
<span class="line"><span>j=6: 7&gt;6 → 无操作</span></span>
<span class="line"><span>最后交换arr[5]和arr[7]: [3,2,5,1,4,6,7,8]</span></span>
<span class="line"><span>基准6位于正确位置，索引=5</span></span></code></pre></div><h3 id="最近点对问题" tabindex="-1">最近点对问题 <a class="header-anchor" href="#最近点对问题" aria-label="Permalink to &quot;最近点对问题&quot;">​</a></h3><p>在平面中找到距离最近的两个点，展示分治在几何问题中的应用。</p><p>特点：</p><ul><li>二维分解：按 x 坐标排序后分割平面</li><li>跨越处理：需要特别处理分布在分界线两侧的点对</li><li>优化剪枝：利用几何性质减少需要检查的点对</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 最近点对问题分治解法</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> closestPair</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">points</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 按x坐标排序</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> sortedByX</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">points].</span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> a.x </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b.x);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  function</span><span style="color:#B392F0;"> divideAndConquer</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">points</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">left</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">right</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (right </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">&lt;=</span><span style="color:#79B8FF;"> 3</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">      // 基本情况：暴力求解</span></span>
<span class="line"><span style="color:#F97583;">      return</span><span style="color:#B392F0;"> bruteForceClosest</span><span style="color:#E1E4E8;">(points, left, right);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> mid</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">floor</span><span style="color:#E1E4E8;">((left </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> right) </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> midPoint</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> points[mid];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 分解：递归求解左右子集</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> leftMin</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> divideAndConquer</span><span style="color:#E1E4E8;">(points, left, mid);</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> rightMin</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> divideAndConquer</span><span style="color:#E1E4E8;">(points, mid </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">, right);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 合并：考虑跨越分界线的点对</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> minDist</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">min</span><span style="color:#E1E4E8;">(leftMin.distance, rightMin.distance);</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> strip</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> [];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 收集距离分界线在minDist范围内的点</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> left; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> right; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">      if</span><span style="color:#E1E4E8;"> (Math.</span><span style="color:#B392F0;">abs</span><span style="color:#E1E4E8;">(points[i].x </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> midPoint.x) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> minDist) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        strip.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(points[i]);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 按y坐标排序strip中的点</span></span>
<span class="line"><span style="color:#E1E4E8;">    strip.</span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> a.y </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b.y);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 检查strip中的点对</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> stripMin </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { distance: </span><span style="color:#79B8FF;">Infinity</span><span style="color:#E1E4E8;"> };</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> strip.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">      for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">; j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> strip.</span><span style="color:#79B8FF;">length</span><span style="color:#F97583;"> &amp;&amp;</span><span style="color:#E1E4E8;"> (strip[j].y </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> strip[i].y) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> minDist; j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">        const</span><span style="color:#79B8FF;"> dist</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> distance</span><span style="color:#E1E4E8;">(strip[i], strip[j]);</span></span>
<span class="line"><span style="color:#F97583;">        if</span><span style="color:#E1E4E8;"> (dist </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> stripMin.distance) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          stripMin </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { point1: strip[i], point2: strip[j], distance: dist };</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> [leftMin, rightMin, stripMin].</span><span style="color:#B392F0;">reduce</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">min</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">curr</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">      curr.distance </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> min.distance </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> curr </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> min</span></span>
<span class="line"><span style="color:#E1E4E8;">    );</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> divideAndConquer</span><span style="color:#E1E4E8;">(sortedByX, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, sortedByX.</span><span style="color:#79B8FF;">length</span><span style="color:#F97583;"> -</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="分治复杂度分析" tabindex="-1">分治复杂度分析 <a class="header-anchor" href="#分治复杂度分析" aria-label="Permalink to &quot;分治复杂度分析&quot;">​</a></h2><p>分治算法复杂度通常用主定理分析，考虑分解因子、子问题数量和合并成本。</p><p>主定理形式：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>T(n) = aT(n/b) + f(n)</span></span>
<span class="line"><span>其中：</span></span>
<span class="line"><span>a ≥ 1, b &gt; 1</span></span>
<span class="line"><span>f(n)是分解和合并的成本</span></span></code></pre></div><p>常见情况：</p><ul><li>a &gt; bᵏ：T(n) = O(n^(log_b a)) // 子问题数量主导</li><li>a = bᵏ：T(n) = O(nᵏ log n) // 平衡情况</li><li>a &lt; bᵏ：T(n) = O(f(n)) // 合并成本主导</li></ul><p>示意图 (分治算法复杂度分类)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>归并排序: T(n)=2T(n/2)+O(n) → O(n log n)</span></span>
<span class="line"><span>快速排序: T(n)=T(n/2)+T(n/2)+O(n) → O(n log n) 平均</span></span>
<span class="line"><span>二分搜索: T(n)=T(n/2)+O(1) → O(log n)</span></span>
<span class="line"><span>Strassen矩阵乘法: T(n)=7T(n/2)+O(n²) → O(n^(log₂7)) ≈ O(n^2.81)</span></span></code></pre></div>`,110)])])}const d=n(o,[["render",e]]);export{F as __pageData,d as default};
