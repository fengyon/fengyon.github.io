import{_ as a,c as n,o as l,b as o}from"./chunks/framework.CMLuPXeo.js";const y=JSON.parse('{"title":"umijs Mock 与代理","description":"","frontmatter":{},"headers":[{"level":2,"title":"Mock 数据","slug":"mock-数据","link":"#mock-数据","children":[{"level":3,"title":"约定式 Mock 文件","slug":"约定式-mock-文件","link":"#约定式-mock-文件","children":[]},{"level":3,"title":"编写 Mock 文件","slug":"编写-mock-文件","link":"#编写-mock-文件","children":[]},{"level":3,"title":"使用 Mock.js 生成模拟数据","slug":"使用-mock-js-生成模拟数据","link":"#使用-mock-js-生成模拟数据","children":[]},{"level":3,"title":"模拟延迟","slug":"模拟延迟","link":"#模拟延迟","children":[]},{"level":3,"title":"合理拆分 Mock 文件","slug":"合理拆分-mock-文件","link":"#合理拆分-mock-文件","children":[]},{"level":3,"title":"关闭 Mock 功能","slug":"关闭-mock-功能","link":"#关闭-mock-功能","children":[]}]},{"level":2,"title":"代理配置","slug":"代理配置","link":"#代理配置","children":[{"level":3,"title":"配置代理","slug":"配置代理","link":"#配置代理","children":[]},{"level":3,"title":"在组件中使用代理","slug":"在组件中使用代理","link":"#在组件中使用代理","children":[]},{"level":3,"title":"跨域问题处理","slug":"跨域问题处理","link":"#跨域问题处理","children":[]}]},{"level":2,"title":"Mock 与代理的协作","slug":"mock-与代理的协作","link":"#mock-与代理的协作","children":[]}],"relativePath":"framework/umijs/mock.md","filePath":"framework/umijs/mock.md"}'),p={name:"framework/umijs/mock.md"};function e(c,s,t,r,i,E){return l(),n("div",null,[...s[0]||(s[0]=[o(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /framework/umijs/mock.md for this page in Markdown format</div><h1 id="umijs-mock-与代理" tabindex="-1">umijs Mock 与代理 <a class="header-anchor" href="#umijs-mock-与代理" aria-label="Permalink to &quot;umijs Mock 与代理&quot;">​</a></h1><h2 id="mock-数据" tabindex="-1">Mock 数据 <a class="header-anchor" href="#mock-数据" aria-label="Permalink to &quot;Mock 数据&quot;">​</a></h2><p>Mock 数据是前端开发过程中必不可少的一环，它通过预先与服务器端约定好的接口来模拟请求数据甚至逻辑，让前端开发能够独立自主进行，不会被服务端的开发进度所阻塞。</p><h3 id="约定式-mock-文件" tabindex="-1">约定式 Mock 文件 <a class="header-anchor" href="#约定式-mock-文件" aria-label="Permalink to &quot;约定式 Mock 文件&quot;">​</a></h3><p>UmiJS 采用约定式的 Mock 文件管理方式。它约定 <code>src/mock</code> 文件夹下的所有文件都是 Mock 文件。</p><p>目录结构示例：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>.</span></span>
<span class="line"><span>└── src</span></span>
<span class="line"><span>    ├── mock</span></span>
<span class="line"><span>    │   ├── api.ts</span></span>
<span class="line"><span>    │   └── users.ts</span></span>
<span class="line"><span>    └── pages</span></span>
<span class="line"><span>        └── index.tsx</span></span></code></pre></div><p>在上述结构中，<code>src/mock</code> 下的 <code>api.ts</code> 和 <code>users.ts</code> 都会被 UmiJS 解析为 Mock 文件。</p><h3 id="编写-mock-文件" tabindex="-1">编写 Mock 文件 <a class="header-anchor" href="#编写-mock-文件" aria-label="Permalink to &quot;编写 Mock 文件&quot;">​</a></h3><p>Mock 文件支持多种写法，既可以简单返回静态数据，也可以使用函数处理复杂逻辑。</p><p>基本写法示例：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  // 支持值为 Object 和 Array</span></span>
<span class="line"><span style="color:#9ECBFF;">  &#39;GET /api/users&#39;</span><span style="color:#E1E4E8;">: { users: [</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">] },</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">  // GET 方法可忽略不写</span></span>
<span class="line"><span style="color:#9ECBFF;">  &#39;/api/users/1&#39;</span><span style="color:#E1E4E8;">: { id: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#6A737D;">  // 支持自定义函数，API 参考 express@4</span></span>
<span class="line"><span style="color:#9ECBFF;">  &#39;POST /api/users/create&#39;</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">req</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">res</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">    // 添加跨域请求头</span></span>
<span class="line"><span style="color:#E1E4E8;">    res.</span><span style="color:#B392F0;">setHeader</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Access-Control-Allow-Origin&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;*&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    res.</span><span style="color:#B392F0;">end</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;ok&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><p>访问 <code>/api/users</code> 就能得到 <code>{ users: [1,2] }</code> 的响应，其他接口同理。</p><h3 id="使用-mock-js-生成模拟数据" tabindex="-1">使用 Mock.js 生成模拟数据 <a class="header-anchor" href="#使用-mock-js-生成模拟数据" aria-label="Permalink to &quot;使用 Mock.js 生成模拟数据&quot;">​</a></h3><p>Mock.js 是常用的辅助生成模拟数据的三方库，可以提升 Mock 数据的能力：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> mockjs </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;mockjs&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  // 使用 mockjs 等三方库</span></span>
<span class="line"><span style="color:#9ECBFF;">  &#39;GET /api/tags&#39;</span><span style="color:#E1E4E8;">: mockjs.</span><span style="color:#B392F0;">mock</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#9ECBFF;">    &#39;list|100&#39;</span><span style="color:#E1E4E8;">: [{ name: </span><span style="color:#9ECBFF;">&#39;@city&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;value|1-100&#39;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">50</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;type|0-2&#39;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> }],</span></span>
<span class="line"><span style="color:#E1E4E8;">  }),</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><h3 id="模拟延迟" tabindex="-1">模拟延迟 <a class="header-anchor" href="#模拟延迟" aria-label="Permalink to &quot;模拟延迟&quot;">​</a></h3><p>为了更真实地模拟网络请求，可以手动添加 setTimeout 模拟延迟：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#9ECBFF;">&#39;GET /api/tags&#39;</span><span style="color:#E1E4E8;">: (</span><span style="color:#FFAB70;">req</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">res</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#B392F0;">  setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    res.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">      list: [</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">],</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">  }, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">},</span></span></code></pre></div><h3 id="合理拆分-mock-文件" tabindex="-1">合理拆分 Mock 文件 <a class="header-anchor" href="#合理拆分-mock-文件" aria-label="Permalink to &quot;合理拆分 Mock 文件&quot;">​</a></h3><p>对于复杂的系统，请求接口通常很多。为了处理大量模拟请求的场景，建议将每一个数据模型抽象成一个文件，统一放在 mock 文件夹中，它们会自动被 UmiJS 引入。</p><h3 id="关闭-mock-功能" tabindex="-1">关闭 Mock 功能 <a class="header-anchor" href="#关闭-mock-功能" aria-label="Permalink to &quot;关闭 Mock 功能&quot;">​</a></h3><p>可以通过配置完全关闭 Mock 功能：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  mock: </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><p>也可以通过环境变量临时关闭：</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">$</span><span style="color:#9ECBFF;"> MOCK=none</span><span style="color:#9ECBFF;"> umi</span><span style="color:#9ECBFF;"> dev</span></span></code></pre></div><h2 id="代理配置" tabindex="-1">代理配置 <a class="header-anchor" href="#代理配置" aria-label="Permalink to &quot;代理配置&quot;">​</a></h2><p>在 UmiJS 中，可以通过配置代理来实现跨域请求。Umi 提供了内置的代理支持，可以轻松地将所有请求转发到另一个服务器。</p><h3 id="配置代理" tabindex="-1">配置代理 <a class="header-anchor" href="#配置代理" aria-label="Permalink to &quot;配置代理&quot;">​</a></h3><p>在项目的配置文件 (<code>.umirc.ts</code> 或 <code>config/config.ts</code>) 中配置代理：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  proxy: {</span></span>
<span class="line"><span style="color:#9ECBFF;">    &#39;/api&#39;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      target: </span><span style="color:#9ECBFF;">&#39;https://blogs.zdldove.top&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      changeOrigin: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      pathRewrite: { </span><span style="color:#9ECBFF;">&#39;^/api&#39;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&#39;&#39;</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><p>在 Ant Design Pro 中，代理配置通常在 <code>/config/proxy.ts</code> 文件中：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">dev</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#9ECBFF;">  &#39;/api/&#39;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    target: </span><span style="color:#9ECBFF;">&#39;http://localhost&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    changeOrigin: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    pathRewrite: { </span><span style="color:#9ECBFF;">&#39;^&#39;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&#39;&#39;</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">},</span></span></code></pre></div><h3 id="在组件中使用代理" tabindex="-1">在组件中使用代理 <a class="header-anchor" href="#在组件中使用代理" aria-label="Permalink to &quot;在组件中使用代理&quot;">​</a></h3><p>配置代理后，在组件中发起请求时，只需要将请求的地址设置为相对于代理地址的路径即可：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { request } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;umi&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">request</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/api/users&#39;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">response</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(response);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p>上述请求中的 <code>/api/users</code> 会被转发到 <code>http://example.com/api/users</code>。</p><h3 id="跨域问题处理" tabindex="-1">跨域问题处理 <a class="header-anchor" href="#跨域问题处理" aria-label="Permalink to &quot;跨域问题处理&quot;">​</a></h3><p>跨域请求可能会受到浏览器的限制。除了使用代理配置来解决跨域问题外，还可以通过配置 CORS 头部来允许跨域请求。</p><p>如果权限允许修改后端服务器的配置，可以添加以下 CORS 头部信息：</p><ul><li>在服务器响应头中添加 <code>Access-Control-Allow-Origin</code> 字段，指定允许的域名</li><li>添加 <code>Access-Control-Allow-Methods</code> 字段，指定允许的请求方法</li><li>根据需要添加其他 CORS 相关头部字段</li></ul><h2 id="mock-与代理的协作" tabindex="-1">Mock 与代理的协作 <a class="header-anchor" href="#mock-与代理的协作" aria-label="Permalink to &quot;Mock 与代理的协作&quot;">​</a></h2><p>在实际开发中，Mock 数据和代理可以协同工作。当后端 API 尚未完成时，前端可以使用 Mock 数据进行开发和测试；当后端 API 完成后，只需配置代理指向真实的后端服务器即可。</p><p>UmiJS 的 Mock 功能在开发环境下自动启用，当请求的地址在 Mock 中不存在时，会尝试访问代理提供的地址。这种机制使得从前端 Mock 数据切换到真实后端服务变得非常顺畅。</p>`,45)])])}const k=a(p,[["render",e]]);export{y as __pageData,k as default};
