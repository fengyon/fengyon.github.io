import{_ as a,c as n,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const E=JSON.parse('{"title":"光照模型","description":"","frontmatter":{},"headers":[{"level":2,"title":"光照模型基础","slug":"光照模型基础","link":"#光照模型基础","children":[]},{"level":2,"title":"局部光照与全局光照","slug":"局部光照与全局光照","link":"#局部光照与全局光照","children":[]},{"level":2,"title":"环境光照","slug":"环境光照","link":"#环境光照","children":[]},{"level":2,"title":"漫反射光照","slug":"漫反射光照","link":"#漫反射光照","children":[]},{"level":2,"title":"镜面反射光照","slug":"镜面反射光照","link":"#镜面反射光照","children":[{"level":3,"title":"Phong 镜面模型","slug":"phong-镜面模型","link":"#phong-镜面模型","children":[]},{"level":3,"title":"Blinn-Phong 模型","slug":"blinn-phong-模型","link":"#blinn-phong-模型","children":[]}]},{"level":2,"title":"完整光照方程","slug":"完整光照方程","link":"#完整光照方程","children":[]},{"level":2,"title":"光源类型","slug":"光源类型","link":"#光源类型","children":[{"level":3,"title":"定向光","slug":"定向光","link":"#定向光","children":[]},{"level":3,"title":"点光源","slug":"点光源","link":"#点光源","children":[]},{"level":3,"title":"聚光灯","slug":"聚光灯","link":"#聚光灯","children":[]}]},{"level":2,"title":"法线向量处理","slug":"法线向量处理","link":"#法线向量处理","children":[]},{"level":2,"title":"着色频率","slug":"着色频率","link":"#着色频率","children":[{"level":3,"title":"逐顶点着色","slug":"逐顶点着色","link":"#逐顶点着色","children":[]},{"level":3,"title":"逐片段着色","slug":"逐片段着色","link":"#逐片段着色","children":[]}]},{"level":2,"title":"WebGL 中的光照实现","slug":"webgl-中的光照实现","link":"#webgl-中的光照实现","children":[]},{"level":2,"title":"性能优化策略","slug":"性能优化策略","link":"#性能优化策略","children":[]}],"relativePath":"web-3d/theory/lighting.md","filePath":"web-3d/theory/lighting.md"}'),e={name:"web-3d/theory/lighting.md"};function o(i,s,c,t,r,d){return l(),n("div",null,[...s[0]||(s[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /web-3d/theory/lighting.md for this page in Markdown format</div><h1 id="光照模型" tabindex="-1">光照模型 <a class="header-anchor" href="#光照模型" aria-label="Permalink to &quot;光照模型&quot;">​</a></h1><p>光照模型是 3D 图形学中模拟光线与物体表面交互的数学方法，它决定了物体在场景中的视觉外观。在 Web 3D 开发中，合理的光照模型能够显著增强场景的真实感和沉浸感，是创建逼真视觉效果的关键技术。</p><h2 id="光照模型基础" tabindex="-1">光照模型基础 <a class="header-anchor" href="#光照模型基础" aria-label="Permalink to &quot;光照模型基础&quot;">​</a></h2><p>光照模型描述了光线如何与材质表面相互作用，包括吸收、反射和透射等物理现象。计算机图形学中的光照模型是对真实光照的近似，平衡计算成本和视觉效果。</p><p>特点：</p><ul><li>基于物理的简化模型，而非完全物理准确</li><li>分离光照计算与材质属性</li><li>支持实时渲染的性能要求</li></ul><p>示意图 (光线与表面交互)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>入射光线 → 表面 → 反射光线 + 吸收 + 透射</span></span>
<span class="line"><span>    ↓        ↓         ↓</span></span>
<span class="line"><span>  方向     材质属性    方向/强度</span></span></code></pre></div><h2 id="局部光照与全局光照" tabindex="-1">局部光照与全局光照 <a class="header-anchor" href="#局部光照与全局光照" aria-label="Permalink to &quot;局部光照与全局光照&quot;">​</a></h2><p>光照模型分为局部光照和全局光照两大类。局部光照只考虑直接光照，全局光照还包含间接光照和光线反弹效果。</p><p>特点：</p><ul><li>局部光照：计算简单，适合实时渲染</li><li>全局光照：效果真实，计算成本高</li><li>Web 3D 主要使用局部光照模型</li></ul><p>示意图对比：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>局部光照：        全局光照：</span></span>
<span class="line"><span>光源 → 表面 → 眼睛    光源 → 表面A → 表面B → 眼睛</span></span>
<span class="line"><span>                     ↓</span></span>
<span class="line"><span>                   间接光照</span></span></code></pre></div><h2 id="环境光照" tabindex="-1">环境光照 <a class="header-anchor" href="#环境光照" aria-label="Permalink to &quot;环境光照&quot;">​</a></h2><p>环境光照模拟场景中的间接光照，为物体提供基础亮度。这是最简单的光照分量，不考虑光线方向。</p><p>特点：</p><ul><li>恒定照明，无方向性</li><li>防止完全黑暗的区域</li><li>通常与场景环境贴图结合</li></ul><p>环境光计算公式：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>颜色 = 材质环境色 × 环境光强度</span></span></code></pre></div><p>示意图 (环境光效果)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>无环境光：        有环境光：</span></span>
<span class="line"><span>  [暗部全黑]        [暗部可见]</span></span>
<span class="line"><span>  /        \\       /        \\</span></span>
<span class="line"><span> |  暗面   |     |  灰色面  |</span></span>
<span class="line"><span>  \\        /       \\        /</span></span></code></pre></div><h2 id="漫反射光照" tabindex="-1">漫反射光照 <a class="header-anchor" href="#漫反射光照" aria-label="Permalink to &quot;漫反射光照&quot;">​</a></h2><p>漫反射模拟光线在粗糙表面的均匀散射，遵循 Lambert 余弦定律。反射强度与表面法线和光线方向的夹角余弦成正比。</p><p>特点：</p><ul><li>方向敏感，与观察角度无关</li><li>产生柔和的明暗过渡</li><li>使用点积计算光照强度</li></ul><p>Lambert 定律示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>表面法线  光线方向</span></span>
<span class="line"><span>   ↑       ↗</span></span>
<span class="line"><span>   |      /</span></span>
<span class="line"><span>   |     /</span></span>
<span class="line"><span>   |    /</span></span>
<span class="line"><span>   | θ /</span></span>
<span class="line"><span>表面-------</span></span>
<span class="line"><span>强度 ∝ cos(θ) = 点积(法线, 光线)</span></span></code></pre></div><p>漫反射计算公式：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>强度 = max(点积(法线, 光线方向), 0)</span></span>
<span class="line"><span>颜色 = 材质漫反射色 × 光颜色 × 强度</span></span></code></pre></div><h2 id="镜面反射光照" tabindex="-1">镜面反射光照 <a class="header-anchor" href="#镜面反射光照" aria-label="Permalink to &quot;镜面反射光照&quot;">​</a></h2><p>镜面反射模拟光线在光滑表面的集中反射，产生高光效果。常见模型包括 Phong 和 Blinn-Phong 模型。</p><p>特点：</p><ul><li>观察角度敏感</li><li>产生明亮的高光点</li><li>受表面光滑度影响</li></ul><p>镜面反射示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>光线方向  视线方向</span></span>
<span class="line"><span>   ↗       ↘</span></span>
<span class="line"><span>    \\       /</span></span>
<span class="line"><span>     \\     /</span></span>
<span class="line"><span>      \\   /</span></span>
<span class="line"><span>       \\ /</span></span>
<span class="line"><span>       表面</span></span>
<span class="line"><span>反射方向 = 反射(光线方向, 法线)</span></span></code></pre></div><h3 id="phong-镜面模型" tabindex="-1">Phong 镜面模型 <a class="header-anchor" href="#phong-镜面模型" aria-label="Permalink to &quot;Phong 镜面模型&quot;">​</a></h3><p>Phong 模型通过反射方向与视线方向的点积计算高光，再通过指数控制高光集中度。</p><p>特点：</p><ul><li>直观的物理意义</li><li>计算反射方向向量</li><li>高光指数控制光泽度</li></ul><p>Phong 计算公式：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>反射方向 = 反射(-光线方向, 法线)</span></span>
<span class="line"><span>高光强度 = max(点积(反射方向, 视线方向), 0)^光泽度</span></span></code></pre></div><h3 id="blinn-phong-模型" tabindex="-1">Blinn-Phong 模型 <a class="header-anchor" href="#blinn-phong-模型" aria-label="Permalink to &quot;Blinn-Phong 模型&quot;">​</a></h3><p>Blinn-Phong 使用半角向量替代反射向量，计算更高效且高光更自然，是现代图形 API 的默认模型。</p><p>特点：</p><ul><li>计算成本低于 Phong 模型</li><li>高光过渡更平滑</li><li>广泛用于实时渲染</li></ul><p>半角向量示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>光线方向  视线方向</span></span>
<span class="line"><span>   ↗       ↘</span></span>
<span class="line"><span>    \\       /</span></span>
<span class="line"><span>     \\     /</span></span>
<span class="line"><span>      \\   /</span></span>
<span class="line"><span>       \\ /</span></span>
<span class="line"><span>        H (半角向量)</span></span>
<span class="line"><span>法线 →  ↑</span></span></code></pre></div><p>Blinn-Phong 计算公式：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>半角向量 = 归一化(光线方向 + 视线方向)</span></span>
<span class="line"><span>高光强度 = max(点积(法线, 半角向量), 0)^光泽度</span></span></code></pre></div><h2 id="完整光照方程" tabindex="-1">完整光照方程 <a class="header-anchor" href="#完整光照方程" aria-label="Permalink to &quot;完整光照方程&quot;">​</a></h2><p>将各光照分量组合得到完整的光照模型，通常采用环境光、漫反射和镜面反射的加和模型。</p><p>完整 Phong 光照模型：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>最终颜色 = 环境光 + 漫反射 + 镜面反射</span></span>
<span class="line"><span>        = 材质环境 × 光环境 </span></span>
<span class="line"><span>        + 材质漫反射 × 光颜色 × max(点积(法线, 光线), 0)</span></span>
<span class="line"><span>        + 材质镜面 × 光颜色 × max(点积(反射方向, 视线), 0)^光泽度</span></span></code></pre></div><p>各分量效果示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>环境光：    漫反射：     镜面反射：     组合效果：</span></span>
<span class="line"><span> 均匀灰色    方向明暗     高光亮斑     完整光照</span></span>
<span class="line"><span>  [    ]     [亮/暗]     [ 亮斑 ]     [真实感]</span></span>
<span class="line"><span>  /    \\     /    \\      /    \\       /    \\</span></span>
<span class="line"><span> | 灰   |   | 渐变 |    | 亮点 |     | 综合 |</span></span>
<span class="line"><span>  \\    /     \\    /      \\    /       \\    /</span></span></code></pre></div><h2 id="光源类型" tabindex="-1">光源类型 <a class="header-anchor" href="#光源类型" aria-label="Permalink to &quot;光源类型&quot;">​</a></h2><p>不同类型的光源影响光照计算的方式，Web 3D 中常见的光源包括定向光、点光源和聚光灯。</p><h3 id="定向光" tabindex="-1">定向光 <a class="header-anchor" href="#定向光" aria-label="Permalink to &quot;定向光&quot;">​</a></h3><p>定向光模拟无限远处的光源 (如太阳)，所有光线平行且强度不变。</p><p>特点：</p><ul><li>方向恒定，无位置概念</li><li>计算简单高效</li><li>适合室外场景</li></ul><p>示意图 (定向光)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>平行光线：</span></span>
<span class="line"><span>   ↓↓↓↓↓</span></span>
<span class="line"><span>   ↓↓↓↓↓ → 表面</span></span>
<span class="line"><span>   ↓↓↓↓↓</span></span>
<span class="line"><span>  方向一致</span></span></code></pre></div><h3 id="点光源" tabindex="-1">点光源 <a class="header-anchor" href="#点光源" aria-label="Permalink to &quot;点光源&quot;">​</a></h3><p>点光源从特定位置向所有方向发射光线，强度随距离衰减。</p><p>特点：</p><ul><li>有明确位置</li><li>强度随距离衰减</li><li>适合灯泡、蜡烛等效果</li></ul><p>示意图 (点光源)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>  光源</span></span>
<span class="line"><span>   ●</span></span>
<span class="line"><span>  /|\\</span></span>
<span class="line"><span> / | \\  光线辐射</span></span>
<span class="line"><span>/  |  \\</span></span></code></pre></div><p>点光源衰减公式：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>衰减 = 1.0 / (常数 + 线性×距离 + 二次×距离²)</span></span></code></pre></div><h3 id="聚光灯" tabindex="-1">聚光灯 <a class="header-anchor" href="#聚光灯" aria-label="Permalink to &quot;聚光灯&quot;">​</a></h3><p>聚光灯发射锥形光线，具有位置、方向和锥角限制。</p><p>特点：</p><ul><li>锥形照明区域</li><li>内外锥角控制边缘软化</li><li>适合手电筒、车灯效果</li></ul><p>示意图 (聚光灯)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>  光源</span></span>
<span class="line"><span>   ●</span></span>
<span class="line"><span>  /|\\</span></span>
<span class="line"><span> / | \\  照明锥体</span></span>
<span class="line"><span>/  |  \\</span></span>
<span class="line"><span>---θ--- 锥角</span></span></code></pre></div><p>聚光灯强度计算：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>角度 = 点积(光线方向, 聚光方向)</span></span>
<span class="line"><span>强度 = (角度 - 外锥角) / (内锥角 - 外锥角)</span></span>
<span class="line"><span>强度 = clamp(强度, 0, 1)</span></span></code></pre></div><h2 id="法线向量处理" tabindex="-1">法线向量处理 <a class="header-anchor" href="#法线向量处理" aria-label="Permalink to &quot;法线向量处理&quot;">​</a></h2><p>法线向量在光照计算中至关重要，但需要正确处理变换和插值才能获得准确结果。</p><p>特点：</p><ul><li>必须使用模型矩阵的逆转置矩阵变换</li><li>片段着色器中需要重新归一化</li><li>支持法线贴图增强细节</li></ul><p>法线变换示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>顶点法线 → 模型矩阵逆转置 → 世界空间法线</span></span>
<span class="line"><span>   ↓              ↓             ↓</span></span>
<span class="line"><span>局部空间       特殊变换       光照计算</span></span></code></pre></div><p>法线贴图效果：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>无法线贴图：       有法线贴图：</span></span>
<span class="line"><span>  平滑表面          细节凹凸</span></span>
<span class="line"><span>  [      ]         [ /\\/\\ ]</span></span>
<span class="line"><span>  /      \\         /      \\</span></span>
<span class="line"><span> |  平    |       | 凹凸   |</span></span>
<span class="line"><span>  \\      /         \\      /</span></span></code></pre></div><h2 id="着色频率" tabindex="-1">着色频率 <a class="header-anchor" href="#着色频率" aria-label="Permalink to &quot;着色频率&quot;">​</a></h2><p>着色频率决定光照计算的粒度，影响视觉效果和性能。主要分为逐顶点着色和逐片段着色。</p><h3 id="逐顶点着色" tabindex="-1">逐顶点着色 <a class="header-anchor" href="#逐顶点着色" aria-label="Permalink to &quot;逐顶点着色&quot;">​</a></h3><p>在顶点着色器中计算光照，结果在三角形内插值。</p><p>特点：</p><ul><li>计算量小，性能高</li><li>细节不足，出现马赫带</li><li>适合简单场景或低性能设备</li></ul><p>示意图 (逐顶点着色)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>顶点计算光照 → 插值颜色 → 片段输出</span></span>
<span class="line"><span>   v0(红)       渐变        像素</span></span>
<span class="line"><span>   / \\        红---绿</span></span>
<span class="line"><span> v1(绿)-v2(蓝)  \\ /</span></span>
<span class="line"><span>                蓝</span></span></code></pre></div><h3 id="逐片段着色" tabindex="-1">逐片段着色 <a class="header-anchor" href="#逐片段着色" aria-label="Permalink to &quot;逐片段着色&quot;">​</a></h3><p>在片段着色器中为每个像素计算光照。</p><p>特点：</p><ul><li>视觉效果平滑准确</li><li>计算量较大</li><li>现代渲染的标准做法</li></ul><p>示意图 (逐片段着色)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>顶点传递数据 → 逐像素计算 → 精确光照</span></span>
<span class="line"><span>  法线、位置     每个像素       平滑过渡</span></span></code></pre></div><h2 id="webgl-中的光照实现" tabindex="-1">WebGL 中的光照实现 <a class="header-anchor" href="#webgl-中的光照实现" aria-label="Permalink to &quot;WebGL 中的光照实现&quot;">​</a></h2><p>在 WebGL 中实现光照需要精心设计着色器和 JavaScript 代码，合理管理光源参数和材质属性。</p><p>顶点着色器示例：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">attribute</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> position;</span></span>
<span class="line"><span style="color:#F97583;">attribute</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> normal;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> mat4</span><span style="color:#E1E4E8;"> modelViewProjection;</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> mat4</span><span style="color:#E1E4E8;"> modelMatrix;</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> mat3</span><span style="color:#E1E4E8;"> normalMatrix;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">varying</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> vNormal;</span></span>
<span class="line"><span style="color:#F97583;">varying</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> vPosition;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    gl_Position </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> modelViewProjection </span><span style="color:#F97583;">*</span><span style="color:#B392F0;"> vec4</span><span style="color:#E1E4E8;">(position, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    vNormal </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> normalMatrix </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> normal;</span></span>
<span class="line"><span style="color:#E1E4E8;">    vPosition </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> vec3</span><span style="color:#E1E4E8;">(modelMatrix </span><span style="color:#F97583;">*</span><span style="color:#B392F0;"> vec4</span><span style="color:#E1E4E8;">(position, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>片段着色器示例：</p><div class="language-glsl"><button title="Copy Code" class="copy"></button><span class="lang">glsl</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">varying</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> vNormal;</span></span>
<span class="line"><span style="color:#F97583;">varying</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> vPosition;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> lightPosition;</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> lightColor;</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> ambientColor;</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> diffuseColor;</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> vec3</span><span style="color:#E1E4E8;"> specularColor;</span></span>
<span class="line"><span style="color:#F97583;">uniform</span><span style="color:#F97583;"> float</span><span style="color:#E1E4E8;"> shininess;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">void</span><span style="color:#B392F0;"> main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 向量计算</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 normal </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> normalize</span><span style="color:#E1E4E8;">(vNormal);</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 lightDir </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> normalize</span><span style="color:#E1E4E8;">(lightPosition </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> vPosition);</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 viewDir </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> normalize</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">vPosition);</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 reflectDir </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> reflect</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">lightDir, normal);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 环境光</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 ambient </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ambientColor </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> diffuseColor;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 漫反射</span></span>
<span class="line"><span style="color:#F97583;">    float</span><span style="color:#E1E4E8;"> diff </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> max</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">dot</span><span style="color:#E1E4E8;">(normal, lightDir), </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 diffuse </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> lightColor </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> diff </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> diffuseColor;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 镜面反射 (Blinn-Phong)</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 halfwayDir </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> normalize</span><span style="color:#E1E4E8;">(lightDir </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> viewDir);</span></span>
<span class="line"><span style="color:#F97583;">    float</span><span style="color:#E1E4E8;"> spec </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> pow</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">dot</span><span style="color:#E1E4E8;">(normal, halfwayDir), </span><span style="color:#79B8FF;">0.0</span><span style="color:#E1E4E8;">), shininess);</span></span>
<span class="line"><span style="color:#E1E4E8;">    vec3 specular </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> lightColor </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> spec </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> specularColor;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    gl_FragColor </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> vec4</span><span style="color:#E1E4E8;">(ambient </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> diffuse </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> specular, </span><span style="color:#79B8FF;">1.0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="性能优化策略" tabindex="-1">性能优化策略 <a class="header-anchor" href="#性能优化策略" aria-label="Permalink to &quot;性能优化策略&quot;">​</a></h2><p>光照计算是渲染管线中的性能瓶颈之一，需要采用合适的优化策略。</p><p>特点：</p><ul><li>减少光照计算复杂度</li><li>使用光照贴图预计算静态光照</li><li>限制动态光源数量</li></ul><p>优化技术对比：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>完整逐像素光照 → 简化光照模型 → 光照贴图 + 球谐光照</span></span>
<span class="line"><span>   高质量          平衡质量性能       高性能静态场景</span></span>
<span class="line"><span>   ↓               ↓               ↓</span></span>
<span class="line"><span>计算密集        实时友好          预计算为主</span></span></code></pre></div>`,115)])])}const h=a(e,[["render",o]]);export{E as __pageData,h as default};
