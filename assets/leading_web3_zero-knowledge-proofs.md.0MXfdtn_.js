import{_ as e,c as s,o as n,b as l}from"./chunks/framework.CMLuPXeo.js";const u=JSON.parse('{"title":"零知识证明","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是零知识证明？","slug":"什么是零知识证明","link":"#什么是零知识证明","children":[]},{"level":2,"title":"零知识证明的核心特性","slug":"零知识证明的核心特性","link":"#零知识证明的核心特性","children":[{"level":3,"title":"完备性","slug":"完备性","link":"#完备性","children":[]},{"level":3,"title":"可靠性","slug":"可靠性","link":"#可靠性","children":[]},{"level":3,"title":"零知识性","slug":"零知识性","link":"#零知识性","children":[]}]},{"level":2,"title":"零知识证明的技术类型","slug":"零知识证明的技术类型","link":"#零知识证明的技术类型","children":[{"level":3,"title":"交互式与非交互式","slug":"交互式与非交互式","link":"#交互式与非交互式","children":[]},{"level":3,"title":"主要技术流派","slug":"主要技术流派","link":"#主要技术流派","children":[]}]},{"level":2,"title":"零知识证明的工作原理","slug":"零知识证明的工作原理","link":"#零知识证明的工作原理","children":[{"level":3,"title":"基于电路的方法","slug":"基于电路的方法","link":"#基于电路的方法","children":[]},{"level":3,"title":"Fiat-Shamir 变换","slug":"fiat-shamir-变换","link":"#fiat-shamir-变换","children":[]},{"level":3,"title":"现代 ZKP 系统流程","slug":"现代-zkp-系统流程","link":"#现代-zkp-系统流程","children":[]}]},{"level":2,"title":"零知识证明的应用场景","slug":"零知识证明的应用场景","link":"#零知识证明的应用场景","children":[{"level":3,"title":"区块链扩容","slug":"区块链扩容","link":"#区块链扩容","children":[]},{"level":3,"title":"隐私保护","slug":"隐私保护","link":"#隐私保护","children":[]},{"level":3,"title":"安全投票","slug":"安全投票","link":"#安全投票","children":[]},{"level":3,"title":"去中心化身份","slug":"去中心化身份","link":"#去中心化身份","children":[]},{"level":3,"title":"可验证计算","slug":"可验证计算","link":"#可验证计算","children":[]}]},{"level":2,"title":"零知识证明的未来发展","slug":"零知识证明的未来发展","link":"#零知识证明的未来发展","children":[{"level":3,"title":"零知识机器学习","slug":"零知识机器学习","link":"#零知识机器学习","children":[]},{"level":3,"title":"零知识协处理器","slug":"零知识协处理器","link":"#零知识协处理器","children":[]},{"level":3,"title":"硬件加速","slug":"硬件加速","link":"#硬件加速","children":[]},{"level":3,"title":"互操作性解决方案","slug":"互操作性解决方案","link":"#互操作性解决方案","children":[]},{"level":3,"title":"抗串通基础设施","slug":"抗串通基础设施","link":"#抗串通基础设施","children":[]}]}],"relativePath":"leading/web3/zero-knowledge-proofs.md","filePath":"leading/web3/zero-knowledge-proofs.md"}'),t={name:"leading/web3/zero-knowledge-proofs.md"};function i(o,a,r,p,d,c){return n(),s("div",null,[...a[0]||(a[0]=[l(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /leading/web3/zero-knowledge-proofs.md for this page in Markdown format</div><h1 id="零知识证明" tabindex="-1">零知识证明 <a class="header-anchor" href="#零知识证明" aria-label="Permalink to &quot;零知识证明&quot;">​</a></h1><p>零知识证明是一种密码学协议，允许一方 (证明者) 向另一方 (验证者) 证明某个陈述是真实的，而不会透露任何超出该陈述本身有效性的信息。它实现了“在无需透露知识本身的情况下证明拥有知识”这一看似矛盾的目标，为数字世界的隐私与安全建立了新范式。</p><h2 id="什么是零知识证明" tabindex="-1">什么是零知识证明？ <a class="header-anchor" href="#什么是零知识证明" aria-label="Permalink to &quot;什么是零知识证明？&quot;">​</a></h2><p>零知识证明由 Goldwasser、Micali 和 Rackoff 在1985年首次提出。其核心在于，证明者能够在不披露任何实际内容的情况下，让验证者相信其拥有某个信息或秘密。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>证明者 --（我知道秘密S）--&gt; 验证者</span></span>
<span class="line"><span>验证者 &lt;-（相信你知道S，但对S一无所知）-- 证明者</span></span></code></pre></div><p>经典示例 (三色图问题)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>证明者想证明一张地图可以用三种颜色着色且相邻区域颜色不同。</span></span>
<span class="line"><span>1. 证明者准备6份着色的地图副本（涵盖所有颜色排列）</span></span>
<span class="line"><span>2. 验证者随机选择一条边界</span></span>
<span class="line"><span>3. 证明者揭示该边界两侧区域的颜色</span></span>
<span class="line"><span>4. 重复多次，如每次颜色都不同，验证者即相信着色方案正确</span></span>
<span class="line"><span>整个过程验证者看不到完整着色方案。</span></span></code></pre></div><h2 id="零知识证明的核心特性" tabindex="-1">零知识证明的核心特性 <a class="header-anchor" href="#零知识证明的核心特性" aria-label="Permalink to &quot;零知识证明的核心特性&quot;">​</a></h2><h3 id="完备性" tabindex="-1">完备性 <a class="header-anchor" href="#完备性" aria-label="Permalink to &quot;完备性&quot;">​</a></h3><p>如果陈述真实且双方诚实，证明一定会被验证者接受。有效的证明总能通过验证。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>真实陈述 + 诚实证明者 + 诚实验证者 = 证明被接受</span></span></code></pre></div><h3 id="可靠性" tabindex="-1">可靠性 <a class="header-anchor" href="#可靠性" aria-label="Permalink to &quot;可靠性&quot;">​</a></h3><p>虚假陈述的证明者几乎无法欺骗验证者。通过多次“挑战-响应”循环，欺骗概率呈指数级下降。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>欺骗概率 ≈ (1/2)^n （n=交互次数）</span></span>
<span class="line"><span>n=10时，欺骗概率 &lt; 0.1%</span></span>
<span class="line"><span>n=20时，欺骗概率 &lt; 0.0001%</span></span></code></pre></div><h3 id="零知识性" tabindex="-1">零知识性 <a class="header-anchor" href="#零知识性" aria-label="Permalink to &quot;零知识性&quot;">​</a></h3><p>验证者除了“陈述为真”外，学不到任何额外信息。所有交互信息都可由验证者自行模拟生成。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>真实交互过程：证明者 → 信息序列 → 验证者</span></span>
<span class="line"><span>模拟过程：验证者自行生成 → 信息序列（统计不可区分）</span></span></code></pre></div><h2 id="零知识证明的技术类型" tabindex="-1">零知识证明的技术类型 <a class="header-anchor" href="#零知识证明的技术类型" aria-label="Permalink to &quot;零知识证明的技术类型&quot;">​</a></h2><h3 id="交互式与非交互式" tabindex="-1">交互式与非交互式 <a class="header-anchor" href="#交互式与非交互式" aria-label="Permalink to &quot;交互式与非交互式&quot;">​</a></h3><p><strong>交互式零知识证明</strong>需要多轮对话，证明者与验证者来回交换信息。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>开始 → 承诺 → 挑战 → 响应 → 验证 → 结束</span></span>
<span class="line"><span>       (证明者)  (验证者) (证明者) (验证者)</span></span></code></pre></div><p><strong>非交互式零知识证明</strong>由 Blum、Feldman 和 Micali 于1988年提出，只需单次通信，特别适合区块链等异步环境。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>证明者：生成证明 → 发送 → 验证者：验证证明</span></span></code></pre></div><h3 id="主要技术流派" tabindex="-1">主要技术流派 <a class="header-anchor" href="#主要技术流派" aria-label="Permalink to &quot;主要技术流派&quot;">​</a></h3><h4 id="zk-snark" tabindex="-1">zk-SNARK <a class="header-anchor" href="#zk-snark" aria-label="Permalink to &quot;zk-SNARK&quot;">​</a></h4><p><strong>特点</strong>：证明体积小、验证速度快，需要可信设置。 <strong>应用</strong>：Zcash 隐私交易、以太坊扩容方案。 <strong>技术基础</strong>：椭圆曲线配对、二次算术程序。</p><h4 id="zk-stark" tabindex="-1">zk-STARK <a class="header-anchor" href="#zk-stark" aria-label="Permalink to &quot;zk-STARK&quot;">​</a></h4><p><strong>特点</strong>：无需可信设置、透明、具有后量子安全潜力。 <strong>优势</strong>：证明生成速度快，适合大规模计算。 <strong>代价</strong>：证明体积较大。</p><h4 id="bulletproofs" tabindex="-1">Bulletproofs <a class="header-anchor" href="#bulletproofs" aria-label="Permalink to &quot;Bulletproofs&quot;">​</a></h4><p><strong>特点</strong>：无需可信设置，证明大小随见证值呈对数增长。 <strong>适用场景</strong>：机密交易、范围证明。</p><h2 id="零知识证明的工作原理" tabindex="-1">零知识证明的工作原理 <a class="header-anchor" href="#零知识证明的工作原理" aria-label="Permalink to &quot;零知识证明的工作原理&quot;">​</a></h2><h3 id="基于电路的方法" tabindex="-1">基于电路的方法 <a class="header-anchor" href="#基于电路的方法" aria-label="Permalink to &quot;基于电路的方法&quot;">​</a></h3><p>将计算问题转换为算术电路或逻辑电路，然后转化为多项式表示。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>计算问题 → 电路表示 → 多项式转换 → 证明生成</span></span></code></pre></div><h3 id="fiat-shamir-变换" tabindex="-1">Fiat-Shamir 变换 <a class="header-anchor" href="#fiat-shamir-变换" aria-label="Permalink to &quot;Fiat-Shamir 变换&quot;">​</a></h3><p>将交互式证明转换为非交互式证明的关键技术，使用哈希函数替代验证者的随机挑战。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>交互式：承诺 → 挑战 ← 随机数 → 响应</span></span>
<span class="line"><span>非交互式：承诺 → 挑战=哈希(承诺) → 响应</span></span></code></pre></div><h3 id="现代-zkp-系统流程" tabindex="-1">现代 ZKP 系统流程 <a class="header-anchor" href="#现代-zkp-系统流程" aria-label="Permalink to &quot;现代 ZKP 系统流程&quot;">​</a></h3><ol><li><strong>问题表述</strong>：将待证明陈述转化为可计算形式</li><li><strong>电路编译</strong>：将计算转换为零知识友好电路</li><li><strong>证明生成</strong>：使用见证 (私有输入) 生成证明</li><li><strong>证明验证</strong>：验证者检查证明的有效性</li></ol><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>陈述 → 电路编译 → 公共输入 + 私有见证 → 证明生成 → 验证</span></span></code></pre></div><h2 id="零知识证明的应用场景" tabindex="-1">零知识证明的应用场景 <a class="header-anchor" href="#零知识证明的应用场景" aria-label="Permalink to &quot;零知识证明的应用场景&quot;">​</a></h2><h3 id="区块链扩容" tabindex="-1">区块链扩容 <a class="header-anchor" href="#区块链扩容" aria-label="Permalink to &quot;区块链扩容&quot;">​</a></h3><p><strong>ZK Rollup</strong> 通过在链下执行交易并生成有效性证明，大幅提升交易吞吐量。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>用户交易 → 链下处理 → 生成ZK证明 → 主链验证证明 → 状态更新</span></span></code></pre></div><h3 id="隐私保护" tabindex="-1">隐私保护 <a class="header-anchor" href="#隐私保护" aria-label="Permalink to &quot;隐私保护&quot;">​</a></h3><p><strong>匿名支付</strong>：Zcash、Tornado Cash 等使用零知识证明隐藏交易细节。 <strong>身份验证</strong>：证明年龄或国籍等属性而不透露具体信息。</p><h3 id="安全投票" tabindex="-1">安全投票 <a class="header-anchor" href="#安全投票" aria-label="Permalink to &quot;安全投票&quot;">​</a></h3><p><strong>MACI</strong> 使用零知识证明确保投票正确计数，同时保护投票隐私。</p><p>工作机制：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>投票 → 加密 → 零知识证明 → 计票验证</span></span>
<span class="line"><span>协调员生成证明保证计票正确性，同时不泄露个人投票选择</span></span></code></pre></div><h3 id="去中心化身份" tabindex="-1">去中心化身份 <a class="header-anchor" href="#去中心化身份" aria-label="Permalink to &quot;去中心化身份&quot;">​</a></h3><p>用户控制身份信息，仅在需要时证明特定属性而不暴露完整身份。</p><h3 id="可验证计算" tabindex="-1">可验证计算 <a class="header-anchor" href="#可验证计算" aria-label="Permalink to &quot;可验证计算&quot;">​</a></h3><p>将复杂计算外包给第三方，通过零知识证明验证计算正确性，无需重新执行。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>复杂计算 → 外包执行 → 返回结果+ZK证明 → 验证证明</span></span></code></pre></div><h2 id="零知识证明的未来发展" tabindex="-1">零知识证明的未来发展 <a class="header-anchor" href="#零知识证明的未来发展" aria-label="Permalink to &quot;零知识证明的未来发展&quot;">​</a></h2><h3 id="零知识机器学习" tabindex="-1">零知识机器学习 <a class="header-anchor" href="#零知识机器学习" aria-label="Permalink to &quot;零知识机器学习&quot;">​</a></h3><p><strong>ZKML</strong> 将零知识证明应用于机器学习，实现在不泄露数据或模型细节的情况下验证机器学习计算结果。</p><p>应用场景：医疗诊断、金融预测模型的隐私保护验证。</p><h3 id="零知识协处理器" tabindex="-1">零知识协处理器 <a class="header-anchor" href="#零知识协处理器" aria-label="Permalink to &quot;零知识协处理器&quot;">​</a></h3><p><strong>ZKCoprocessor</strong> 作为区块链的协处理单元，处理复杂计算并返回可验证结果。</p><p>优势：突破区块链计算限制，实现复杂数据分析的可验证性。</p><h3 id="硬件加速" tabindex="-1">硬件加速 <a class="header-anchor" href="#硬件加速" aria-label="Permalink to &quot;硬件加速&quot;">​</a></h3><p><strong>ZK-ASIC</strong> 专用集成电路优化证明生成速度，解决当前 ZKP 性能瓶颈。</p><h3 id="互操作性解决方案" tabindex="-1">互操作性解决方案 <a class="header-anchor" href="#互操作性解决方案" aria-label="Permalink to &quot;互操作性解决方案&quot;">​</a></h3><p><strong>ZK 跨链协议</strong>使用零知识证明实现跨链资产转移的状态验证，减少对信任假设的依赖。</p><h3 id="抗串通基础设施" tabindex="-1">抗串通基础设施 <a class="header-anchor" href="#抗串通基础设施" aria-label="Permalink to &quot;抗串通基础设施&quot;">​</a></h3><p><strong>MACI</strong> 结合零知识证明和中央协调员，防止链上投票中的贿赂和串通行为。</p><p>零知识证明技术正从理论走向成熟应用，在保护隐私的同时确保可验证性，为构建更安全、更私密的数字世界奠定基础。随着技术进步和应用场景拓展，零知识证明有望在金融、医疗、政府等各领域发挥关键作用。</p>`,81)])])}const g=e(t,[["render",i]]);export{u as __pageData,g as default};
