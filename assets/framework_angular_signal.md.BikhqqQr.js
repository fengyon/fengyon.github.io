import{_ as a,c as n,o as l,b as e}from"./chunks/framework.CMLuPXeo.js";const y=JSON.parse('{"title":"Angular Signal","description":"","frontmatter":{},"headers":[{"level":2,"title":"信号概念","slug":"信号概念","link":"#信号概念","children":[]},{"level":2,"title":"信号基础","slug":"信号基础","link":"#信号基础","children":[{"level":3,"title":"创建信号","slug":"创建信号","link":"#创建信号","children":[]},{"level":3,"title":"读取与更新","slug":"读取与更新","link":"#读取与更新","children":[]}]},{"level":2,"title":"计算信号","slug":"计算信号","link":"#计算信号","children":[{"level":3,"title":"派生状态","slug":"派生状态","link":"#派生状态","children":[]},{"level":3,"title":"计算特性","slug":"计算特性","link":"#计算特性","children":[]}]},{"level":2,"title":"副作用效应","slug":"副作用效应","link":"#副作用效应","children":[{"level":3,"title":"Effect 使用","slug":"effect-使用","link":"#effect-使用","children":[]},{"level":3,"title":"Effect 管理","slug":"effect-管理","link":"#effect-管理","children":[]}]},{"level":2,"title":"高级用法","slug":"高级用法","link":"#高级用法","children":[{"level":3,"title":"对象和数组处理","slug":"对象和数组处理","link":"#对象和数组处理","children":[]},{"level":3,"title":"相等性控制","slug":"相等性控制","link":"#相等性控制","children":[]}]},{"level":2,"title":"与 RxJS 互操作","slug":"与-rxjs-互操作","link":"#与-rxjs-互操作","children":[{"level":3,"title":"相互转换","slug":"相互转换","link":"#相互转换","children":[]},{"level":3,"title":"使用场景","slug":"使用场景","link":"#使用场景","children":[]}]},{"level":2,"title":"性能优势","slug":"性能优势","link":"#性能优势","children":[{"level":3,"title":"精细跟踪","slug":"精细跟踪","link":"#精细跟踪","children":[]},{"level":3,"title":"Zone.js 集成","slug":"zone-js-集成","link":"#zone-js-集成","children":[]}]},{"level":2,"title":"最佳实践","slug":"最佳实践","link":"#最佳实践","children":[{"level":3,"title":"模式选择","slug":"模式选择","link":"#模式选择","children":[]},{"level":3,"title":"开发建议","slug":"开发建议","link":"#开发建议","children":[]}]}],"relativePath":"framework/angular/signal.md","filePath":"framework/angular/signal.md"}'),p={name:"framework/angular/signal.md"};function o(t,s,c,r,i,E){return l(),n("div",null,[...s[0]||(s[0]=[e(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /framework/angular/signal.md for this page in Markdown format</div><h1 id="angular-signal" tabindex="-1">Angular Signal <a class="header-anchor" href="#angular-signal" aria-label="Permalink to &quot;Angular Signal&quot;">​</a></h1><h2 id="信号概念" tabindex="-1">信号概念 <a class="header-anchor" href="#信号概念" aria-label="Permalink to &quot;信号概念&quot;">​</a></h2><p>Angular Signal 是 Angular 框架中引入的一种新的响应式状态管理机制，它提供了一种精细跟踪状态变化的方式，让框架能够优化渲染更新。信号本质上是一个值的包装器，当值发生变化时可以通知感兴趣的消费者。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>传统状态管理 vs 信号管理</span></span>
<span class="line"><span>传统: 状态改变 → Zone.js检测整个组件树 → 重新渲染可能未变化的部分</span></span>
<span class="line"><span>信号: 状态改变 → 只通知依赖该信号的组件 → 精准更新受影响部分</span></span></code></pre></div><h2 id="信号基础" tabindex="-1">信号基础 <a class="header-anchor" href="#信号基础" aria-label="Permalink to &quot;信号基础&quot;">​</a></h2><h3 id="创建信号" tabindex="-1">创建信号 <a class="header-anchor" href="#创建信号" aria-label="Permalink to &quot;创建信号&quot;">​</a></h3><p>使用 <code>signal()</code> 函数创建可写信号，初始值可以是任何数据类型。</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">count </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> signal</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// 简单创建</span></span>
<span class="line"><span style="color:#B392F0;">count</span><span style="color:#E1E4E8;">: WritableSignal</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">number</span><span style="color:#F97583;">&gt;</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> signal</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// 带类型注解</span></span></code></pre></div><h3 id="读取与更新" tabindex="-1">读取与更新 <a class="header-anchor" href="#读取与更新" aria-label="Permalink to &quot;读取与更新&quot;">​</a></h3><p>信号的值通过 getter 函数读取，使用 set() 和 update() 方法更新值。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>信号操作：</span></span>
<span class="line"><span>创建: count = signal(0)</span></span>
<span class="line"><span>读取: count() → 0</span></span>
<span class="line"><span>设置: count.set(1) → 值变为1</span></span>
<span class="line"><span>更新: count.update(val =&gt; val + 1) → 基于前值计算</span></span></code></pre></div><p>示例代码：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 模板中</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">p</span><span style="color:#E1E4E8;">&gt;当前计数：{{ </span><span style="color:#B392F0;">count</span><span style="color:#E1E4E8;">() }}</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">&lt;</span><span style="color:#B392F0;">button</span><span style="color:#E1E4E8;"> (click)</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;increment()&quot;</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">增加</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">button</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 组件中</span></span>
<span class="line"><span style="color:#B392F0;">increment</span><span style="color:#E1E4E8;">(): </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#79B8FF;">  this</span><span style="color:#E1E4E8;">.count.</span><span style="color:#B392F0;">update</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">current</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> current </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="计算信号" tabindex="-1">计算信号 <a class="header-anchor" href="#计算信号" aria-label="Permalink to &quot;计算信号&quot;">​</a></h2><h3 id="派生状态" tabindex="-1">派生状态 <a class="header-anchor" href="#派生状态" aria-label="Permalink to &quot;派生状态&quot;">​</a></h3><p><code>computed()</code> 创建从其他信号派生值的只读信号，具有延迟计算和记忆特性。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>计算信号依赖链：</span></span>
<span class="line"><span>firstName → fullName → 显示界面</span></span>
<span class="line"><span>lastName  ↗</span></span>
<span class="line"><span></span></span>
<span class="line"><span>当 firstName 或 lastName 变化时 → fullName 自动重新计算 → 界面更新</span></span></code></pre></div><p>示例代码：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">firstName </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> signal</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;张&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">lastName </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> signal</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;三&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">fullName </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> computed</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#9ECBFF;"> \`\${</span><span style="color:#79B8FF;">this</span><span style="color:#9ECBFF;">.</span><span style="color:#B392F0;">firstName</span><span style="color:#9ECBFF;">()</span><span style="color:#9ECBFF;">} \${</span><span style="color:#79B8FF;">this</span><span style="color:#9ECBFF;">.</span><span style="color:#B392F0;">lastName</span><span style="color:#9ECBFF;">()</span><span style="color:#9ECBFF;">}\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">p</span><span style="color:#E1E4E8;">&gt;欢迎，{{ </span><span style="color:#B392F0;">fullName</span><span style="color:#E1E4E8;">() }}</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">&gt;</span></span></code></pre></div><h3 id="计算特性" tabindex="-1">计算特性 <a class="header-anchor" href="#计算特性" aria-label="Permalink to &quot;计算特性&quot;">​</a></h3><p>计算信号仅在第一次读取时计算值，然后缓存结果，直到依赖项变化才重新计算。Angular 只跟踪推导过程中实际读取的信号，动态管理依赖关系。</p><h2 id="副作用效应" tabindex="-1">副作用效应 <a class="header-anchor" href="#副作用效应" aria-label="Permalink to &quot;副作用效应&quot;">​</a></h2><h3 id="effect-使用" tabindex="-1">Effect 使用 <a class="header-anchor" href="#effect-使用" aria-label="Permalink to &quot;Effect 使用&quot;">​</a></h3><p><code>effect()</code> 用于执行副作用操作，如日志记录、数据持久化等。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>信号变化 → effect 自动执行 → 执行副作用操作</span></span>
<span class="line"><span>    ↑</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>依赖信号变化时重新运行</span></span></code></pre></div><p>示例代码：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">constructor</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#B392F0;">  effect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;计数发生变化：&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">count</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#6A737D;">    // 可在此处添加 localStorage 存储等操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="effect-管理" tabindex="-1">Effect 管理 <a class="header-anchor" href="#effect-管理" aria-label="Permalink to &quot;Effect 管理&quot;">​</a></h3><p>Effect 在创建时运行一次，并在其依赖的信号变化时重新运行。Effect 会自动在其封闭上下文销毁时清理，也可手动通过返回的 <code>EffectRef</code> 销毁。</p><h2 id="高级用法" tabindex="-1">高级用法 <a class="header-anchor" href="#高级用法" aria-label="Permalink to &quot;高级用法&quot;">​</a></h2><h3 id="对象和数组处理" tabindex="-1">对象和数组处理 <a class="header-anchor" href="#对象和数组处理" aria-label="Permalink to &quot;对象和数组处理&quot;">​</a></h3><p>处理复杂数据结构时，需使用信号 API 更新值，避免直接修改。</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 正确方式</span></span>
<span class="line"><span style="color:#E1E4E8;">users </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> signal</span><span style="color:#E1E4E8;">([{name: </span><span style="color:#9ECBFF;">&#39;张三&#39;</span><span style="color:#E1E4E8;">, age: </span><span style="color:#79B8FF;">30</span><span style="color:#E1E4E8;">}]);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">addUser</span><span style="color:#E1E4E8;">(user: User): </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#79B8FF;">  this</span><span style="color:#E1E4E8;">.users.</span><span style="color:#B392F0;">update</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">users</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> [</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">users, user]);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 错误方式：直接修改</span></span>
<span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">users</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(newUser); </span><span style="color:#6A737D;">// 绕过信号系统</span></span></code></pre></div><h3 id="相等性控制" tabindex="-1">相等性控制 <a class="header-anchor" href="#相等性控制" aria-label="Permalink to &quot;相等性控制&quot;">​</a></h3><p>创建信号时可提供自定义相等函数，控制何时触发更新。</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> _ </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;lodash&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> data</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> signal</span><span style="color:#E1E4E8;">([</span><span style="color:#9ECBFF;">&#39;test&#39;</span><span style="color:#E1E4E8;">], { equal: _.isEqual })</span></span>
<span class="line"><span style="color:#E1E4E8;">data.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">([</span><span style="color:#9ECBFF;">&#39;test&#39;</span><span style="color:#E1E4E8;">]) </span><span style="color:#6A737D;">// 深度相等，不触发更新</span></span></code></pre></div><h2 id="与-rxjs-互操作" tabindex="-1">与 RxJS 互操作 <a class="header-anchor" href="#与-rxjs-互操作" aria-label="Permalink to &quot;与 RxJS 互操作&quot;">​</a></h2><h3 id="相互转换" tabindex="-1">相互转换 <a class="header-anchor" href="#相互转换" aria-label="Permalink to &quot;相互转换&quot;">​</a></h3><p>Angular 提供 <code>toObservable</code> 和 <code>toSignal</code> 函数实现信号与 Observable 之间的转换。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>信号世界 ←→ RxJS 世界</span></span>
<span class="line"><span>toSignal() →</span></span>
<span class="line"><span>           ← toObservable()</span></span></code></pre></div><p>示例代码：</p><div class="language-typescript"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 信号转 Observable</span></span>
<span class="line"><span style="color:#E1E4E8;">count </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> signal</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">count$ </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> toObservable</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.count)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// Observable 转信号</span></span>
<span class="line"><span style="color:#E1E4E8;">data$ </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> this</span><span style="color:#E1E4E8;">.dataService.</span><span style="color:#B392F0;">getData</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">data </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> toSignal</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.data$, { initialValue: [] })</span></span></code></pre></div><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><p>Signals 用于本地 UI 状态管理，Observables 适合异步数据流如 HTTP 请求、WebSocket 等。</p><h2 id="性能优势" tabindex="-1">性能优势 <a class="header-anchor" href="#性能优势" aria-label="Permalink to &quot;性能优势&quot;">​</a></h2><h3 id="精细跟踪" tabindex="-1">精细跟踪 <a class="header-anchor" href="#精细跟踪" aria-label="Permalink to &quot;精细跟踪&quot;">​</a></h3><p>信号通过减少变更检测过程中的计算次数来提高运行时性能，只更新依赖于变化信号的组件。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>传统变更检测: 检查整个组件树 → 计算量大</span></span>
<span class="line"><span>信号机制: 知道精确依赖路径 → 只更新必要部分</span></span></code></pre></div><h3 id="zone-js-集成" tabindex="-1">Zone.js 集成 <a class="header-anchor" href="#zone-js-集成" aria-label="Permalink to &quot;Zone.js 集成&quot;">​</a></h3><p>在 <code>OnPush</code> 组件中使用信号时，信号更新会自动标记组件需要检查，无需手动触发变更检测。信号为未来使 Zone.js 成为可选功能奠定基础。</p><h2 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-label="Permalink to &quot;最佳实践&quot;">​</a></h2><h3 id="模式选择" tabindex="-1">模式选择 <a class="header-anchor" href="#模式选择" aria-label="Permalink to &quot;模式选择&quot;">​</a></h3><ul><li><strong>信号</strong>：适合局部 UI 状态、简单派生状态</li><li><strong>RxJS</strong>：适合复杂异步流、事件处理</li><li><strong>混合使用</strong>：利用互操作功能充分发挥两者优势</li></ul><h3 id="开发建议" tabindex="-1">开发建议 <a class="header-anchor" href="#开发建议" aria-label="Permalink to &quot;开发建议&quot;">​</a></h3><ol><li>始终使用信号 API 更新值</li><li>合理使用 computed() 缓存昂贵计算</li><li>注意 effect() 执行时机和清理</li><li>利用 TypeScript 类型系统保证类型安全</li></ol><p>Angular Signals 代表 Angular 响应式演进的未来方向，提供更简单、更高效的状态管理方案，同时保持与现有系统的完全兼容性。</p>`,63)])])}const u=a(p,[["render",o]]);export{y as __pageData,u as default};
