import{_ as e,c as l,o as s,b as n}from"./chunks/framework.CMLuPXeo.js";const h=JSON.parse('{"title":"nuxtjs 渲染模式","description":"","frontmatter":{},"headers":[{"level":2,"title":"理解渲染","slug":"理解渲染","link":"#理解渲染","children":[]},{"level":2,"title":"通用渲染","slug":"通用渲染","link":"#通用渲染","children":[{"level":3,"title":"优点","slug":"优点","link":"#优点","children":[]},{"level":3,"title":"缺点","slug":"缺点","link":"#缺点","children":[]}]},{"level":2,"title":"客户端渲染","slug":"客户端渲染","link":"#客户端渲染","children":[{"level":3,"title":"优点","slug":"优点-1","link":"#优点-1","children":[]},{"level":3,"title":"缺点","slug":"缺点-1","link":"#缺点-1","children":[]}]},{"level":2,"title":"混合渲染","slug":"混合渲染","link":"#混合渲染","children":[{"level":3,"title":"路由规则属性","slug":"路由规则属性","link":"#路由规则属性","children":[]}]},{"level":2,"title":"边缘渲染","slug":"边缘渲染","link":"#边缘渲染","children":[{"level":3,"title":"支持平台","slug":"支持平台","link":"#支持平台","children":[]}]},{"level":2,"title":"如何选择渲染模式","slug":"如何选择渲染模式","link":"#如何选择渲染模式","children":[{"level":3,"title":"通用渲染适用场景","slug":"通用渲染适用场景","link":"#通用渲染适用场景","children":[]},{"level":3,"title":"客户端渲染适用场景","slug":"客户端渲染适用场景","link":"#客户端渲染适用场景","children":[]},{"level":3,"title":"混合渲染适用场景","slug":"混合渲染适用场景","link":"#混合渲染适用场景","children":[]},{"level":3,"title":"边缘渲染适用场景","slug":"边缘渲染适用场景","link":"#边缘渲染适用场景","children":[]}]}],"relativePath":"framework/nuxtjs/rendering.md","filePath":"framework/nuxtjs/rendering.md"}'),t={name:"framework/nuxtjs/rendering.md"};function r(o,a,i,p,c,d){return s(),l("div",null,[...a[0]||(a[0]=[n(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /framework/nuxtjs/rendering.md for this page in Markdown format</div><h1 id="nuxtjs-渲染模式" tabindex="-1">nuxtjs 渲染模式 <a class="header-anchor" href="#nuxtjs-渲染模式" aria-label="Permalink to &quot;nuxtjs 渲染模式&quot;">​</a></h1><h2 id="理解渲染" tabindex="-1">理解渲染 <a class="header-anchor" href="#理解渲染" aria-label="Permalink to &quot;理解渲染&quot;">​</a></h2><p>在 Web 开发中，<strong>渲染</strong>是指将 JavaScript 代码转换为浏览器可显示的 HTML 元素的过程。根据渲染发生的位置不同，可分为服务端渲染和客户端渲染。</p><p>示意图： 传统客户端渲染 (CSR)： [浏览器请求] → [服务器返回空 HTML] → [下载 JS] → [执行 Vue.js] → [渲染页面]</p><p>Nuxt.js 支持多种渲染模式，包括<strong>通用渲染</strong>、<strong>客户端渲染</strong>，还提供<strong>混合渲染</strong>以及在 <strong>CDN 边缘服务器</strong>上渲染应用的可能。</p><h2 id="通用渲染" tabindex="-1">通用渲染 <a class="header-anchor" href="#通用渲染" aria-label="Permalink to &quot;通用渲染&quot;">​</a></h2><p>通用渲染结合了服务端渲染和客户端渲染的优点。当浏览器请求启用了通用渲染的 URL 时，服务器会返回一个完全渲染的 HTML 页面。然后，为了保留客户端渲染的优势，一旦下载了 HTML 文档，客户端会在后台加载在服务器上运行的 JavaScript 代码，使静态页面重新拥有动态能力，这个过程称为 <strong>Hydration (水合作用)</strong>。</p><p>示意图： [浏览器请求] → [服务器运行 Vue.js 生成 HTML] → [返回完整 HTML] ↓ [用户立即看到内容] → [后台加载 JS] → [Vue.js 接管交互]</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li><strong>性能优势</strong>：用户可以立即访问页面内容，因为浏览器显示静态内容比 JavaScript 生成的内容快得多。</li><li><strong>SEO 友好</strong>：搜索引擎爬虫可以直接索引页面的内容。</li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li><strong>开发限制</strong>：服务器和浏览器环境提供的 API 不同。</li><li><strong>成本较高</strong>：需要运行服务器来动态渲染页面。</li></ul><h2 id="客户端渲染" tabindex="-1">客户端渲染 <a class="header-anchor" href="#客户端渲染" aria-label="Permalink to &quot;客户端渲染&quot;">​</a></h2><p>传统的 Vue.js 应用是在浏览器中渲染的。在浏览器下载并解析所有包含创建当前界面指令的 JavaScript 代码后，再由 Vue.js 生成 HTML 元素。</p><p>示意图： [浏览器请求] → [服务器返回空 HTML 和 JS] → [下载 JS] → [执行 Vue.js] → [渲染页面]</p><p>在 <code>nuxt.config.ts</code> 中启用仅客户端渲染：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#B392F0;"> defineNuxtConfig</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  ssr: </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><h3 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li><strong>开发速度</strong>：无需担心代码的服务端兼容性。</li><li><strong>成本较低</strong>：可以在任何静态服务器上托管。</li><li><strong>离线支持</strong>：代码完全在浏览器中运行，可在无网络时继续工作。</li></ul><h3 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li><strong>性能问题</strong>：用户必须等待浏览器下载、解析和运行 JavaScript 文件。</li><li><strong>SEO 缺陷</strong>：索引和更新通过客户端渲染交付的内容需要更多时间。</li></ul><h2 id="混合渲染" tabindex="-1">混合渲染 <a class="header-anchor" href="#混合渲染" aria-label="Permalink to &quot;混合渲染&quot;">​</a></h2><p>混合渲染允许为每个路由使用不同的缓存规则，并决定服务器应如何响应给定 URL 上的新请求。</p><p>通过路由规则，可以为一组 Nuxt 路由定义规则，更改渲染模式或分配基于路由的缓存策略。</p><p>示例配置：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#B392F0;"> defineNuxtConfig</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  routeRules: {</span></span>
<span class="line"><span style="color:#6A737D;">    // 首页在构建时预渲染</span></span>
<span class="line"><span style="color:#9ECBFF;">    &#39;/&#39;</span><span style="color:#E1E4E8;">: { prerender: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#6A737D;">    // 产品页面按需生成，在后台重新验证，缓存直到API响应更改</span></span>
<span class="line"><span style="color:#9ECBFF;">    &#39;/products&#39;</span><span style="color:#E1E4E8;">: { swr: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#6A737D;">    // 博客文章页面按需生成，在后台重新验证，在CDN上缓存1小时</span></span>
<span class="line"><span style="color:#9ECBFF;">    &#39;/blog/**&#39;</span><span style="color:#E1E4E8;">: { isr: </span><span style="color:#79B8FF;">3600</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#6A737D;">    // 管理仪表板只在客户端渲染</span></span>
<span class="line"><span style="color:#9ECBFF;">    &#39;/admin/**&#39;</span><span style="color:#E1E4E8;">: { ssr: </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#6A737D;">    // 重定向遗留url</span></span>
<span class="line"><span style="color:#9ECBFF;">    &#39;/old-page&#39;</span><span style="color:#E1E4E8;">: { redirect: </span><span style="color:#9ECBFF;">&#39;/new-page&#39;</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><h3 id="路由规则属性" tabindex="-1">路由规则属性 <a class="header-anchor" href="#路由规则属性" aria-label="Permalink to &quot;路由规则属性&quot;">​</a></h3><ul><li><code>redirect</code>：定义服务器端重定向</li><li><code>ssr</code>：对应用程序的部分区域禁用服务器端渲染</li><li><code>swr</code>：向服务器响应添加缓存头部</li><li><code>isr</code>：其行为与 <code>swr</code> 相同，只是能够在支持此功能的平台上将响应添加到 CDN 缓存中</li><li><code>prerender</code>：在构建时预先渲染路由</li></ul><h2 id="边缘渲染" tabindex="-1">边缘渲染 <a class="header-anchor" href="#边缘渲染" aria-label="Permalink to &quot;边缘渲染&quot;">​</a></h2><p>边缘侧渲染的工作原理是将渲染过程推送到网络的“边缘”位置，即 CDN 的边缘服务器。当请求某个页面时，请求不会直接到达原始服务器，而是被最近的边缘服务器截获。</p><p>示意图： [用户请求] → [CDN 边缘服务器] → [生成 HTML] → [返回用户] (减少延迟，加快加载速度)</p><h3 id="支持平台" tabindex="-1">支持平台 <a class="header-anchor" href="#支持平台" aria-label="Permalink to &quot;支持平台&quot;">​</a></h3><ul><li><strong>Cloudflare Pages</strong>：使用 Git 集成和 <code>nuxt build</code> 命令，无需任何配置即可实现边缘侧渲染。</li><li><strong>Vercel</strong>：使用 <code>nuxt build</code> 命令和环境变量 <code>NITRO_PRESET=vercel-edge</code>。</li><li><strong>Netlify</strong>：使用 <code>nuxt build</code> 命令和环境变量 <code>NITRO_PRESET=netlify-edge</code>。</li></ul><h2 id="如何选择渲染模式" tabindex="-1">如何选择渲染模式 <a class="header-anchor" href="#如何选择渲染模式" aria-label="Permalink to &quot;如何选择渲染模式&quot;">​</a></h2><h3 id="通用渲染适用场景" tabindex="-1">通用渲染适用场景 <a class="header-anchor" href="#通用渲染适用场景" aria-label="Permalink to &quot;通用渲染适用场景&quot;">​</a></h3><p>通用渲染非常通用，几乎可以适合任何用例，尤其适用于任何面向内容的网站：博客、营销网站、投资组合、电子商务网站和市场。</p><h3 id="客户端渲染适用场景" tabindex="-1">客户端渲染适用场景 <a class="header-anchor" href="#客户端渲染适用场景" aria-label="Permalink to &quot;客户端渲染适用场景&quot;">​</a></h3><p>对于不需要被索引或用户访问频繁的高度交互的 Web 应用程序，客户端渲染是一个不错的选择。例如：SaaS、后台应用程序或在线游戏。</p><h3 id="混合渲染适用场景" tabindex="-1">混合渲染适用场景 <a class="header-anchor" href="#混合渲染适用场景" aria-label="Permalink to &quot;混合渲染适用场景&quot;">​</a></h3><p>适合一个应用中不同页面有不同需求的场景。例如：一个 CMS 管理系统，一些向外展示的页面应该是静态的，但是管理后台需要注册功能，更像一个动态应用。</p><h3 id="边缘渲染适用场景" tabindex="-1">边缘渲染适用场景 <a class="header-anchor" href="#边缘渲染适用场景" aria-label="Permalink to &quot;边缘渲染适用场景&quot;">​</a></h3><p>对性能要求高、用户分布广的全球性应用，希望减少延迟并提供更快的用户体验。</p>`,43)])])}const g=e(t,[["render",r]]);export{h as __pageData,g as default};
