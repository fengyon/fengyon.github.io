import{_ as s,c as l,o as n,b as e}from"./chunks/framework.CMLuPXeo.js";const u=JSON.parse('{"title":"热更新","description":"","frontmatter":{},"headers":[{"level":2,"title":"热更新概述","slug":"热更新概述","link":"#热更新概述","children":[]},{"level":2,"title":"技术方案","slug":"技术方案","link":"#技术方案","children":[{"level":3,"title":"原生方案","slug":"原生方案","link":"#原生方案","children":[]},{"level":3,"title":"混合方案","slug":"混合方案","link":"#混合方案","children":[]}]},{"level":2,"title":"工作原理","slug":"工作原理","link":"#工作原理","children":[{"level":3,"title":"核心流程","slug":"核心流程","link":"#核心流程","children":[]},{"level":3,"title":"Webpack HMR 原理","slug":"webpack-hmr-原理","link":"#webpack-hmr-原理","children":[]},{"level":3,"title":"资源更新机制","slug":"资源更新机制","link":"#资源更新机制","children":[]}]},{"level":2,"title":"实现要点","slug":"实现要点","link":"#实现要点","children":[{"level":3,"title":"客户端实现","slug":"客户端实现","link":"#客户端实现","children":[]},{"level":3,"title":"服务端管理","slug":"服务端管理","link":"#服务端管理","children":[]},{"level":3,"title":"安全与稳定性","slug":"安全与稳定性","link":"#安全与稳定性","children":[]}]},{"level":2,"title":"适用场景","slug":"适用场景","link":"#适用场景","children":[{"level":3,"title":"业务场景","slug":"业务场景","link":"#业务场景","children":[]},{"level":3,"title":"技术场景","slug":"技术场景","link":"#技术场景","children":[]},{"level":3,"title":"限制与约束","slug":"限制与约束","link":"#限制与约束","children":[]}]}],"relativePath":"special/mobile/publish/hot-update.md","filePath":"special/mobile/publish/hot-update.md"}'),t={name:"special/mobile/publish/hot-update.md"};function i(p,a,o,r,c,d){return n(),l("div",null,[...a[0]||(a[0]=[e(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /special/mobile/publish/hot-update.md for this page in Markdown format</div><h1 id="热更新" tabindex="-1">热更新 <a class="header-anchor" href="#热更新" aria-label="Permalink to &quot;热更新&quot;">​</a></h1><h2 id="热更新概述" tabindex="-1">热更新概述 <a class="header-anchor" href="#热更新概述" aria-label="Permalink to &quot;热更新概述&quot;">​</a></h2><p>热更新是一种允许应用程序在运行时进行更新的技术。它通过动态替换应用程序的部分代码或资源来实现更新，而无需重新安装整个应用程序。这种技术已经成为移动开发中的重要工具，帮助开发者在用户无感知的情况下修复 BUG 和发布新功能。</p><p>热更新与传统应用商店更新形成鲜明对比：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>传统更新: [应用商店下载] -&gt; [用户手动安装] -&gt; [重启应用] -&gt; [更新完成]</span></span>
<span class="line"><span>热更新:   [检测更新] -&gt; [下载补丁] -&gt; [动态替换] -&gt; [立即生效]</span></span></code></pre></div><p>核心特点包括：</p><ul><li><strong>动态性</strong>：在应用程序运行时动态加载和替换代码</li><li><strong>无感知</strong>：用户无需重新下载安装整个应用</li><li><strong>敏捷性</strong>：绕过应用商店审核流程，快速迭代</li><li><strong>精准性</strong>：可针对不同用户群体或地区发布不同的更新</li></ul><h2 id="技术方案" tabindex="-1">技术方案 <a class="header-anchor" href="#技术方案" aria-label="Permalink to &quot;技术方案&quot;">​</a></h2><p>移动端热更新技术主要分为两大类方案，各有其特点与适用场景。</p><h3 id="原生方案" tabindex="-1">原生方案 <a class="header-anchor" href="#原生方案" aria-label="Permalink to &quot;原生方案&quot;">​</a></h3><p>原生热更新方案直接针对平台特性设计，性能高效但实现复杂。</p><p><strong>Android 方案</strong>：</p><ul><li><strong>Tinker</strong>：微信团队推出的方案，采用 Dex 差分合并技术</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[旧APK] --[差分]--&gt; [Patch文件] --[合并]--&gt; [新APK]</span></span></code></pre></div><p>特点：稳定性高，但需要重启应用</p><ul><li><strong>Robust</strong>：美团推出的即时更新方案 原理：为每个方法自动插入代理逻辑</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>public long getIndex() {</span></span>
<span class="line"><span>    if(changeQuickRedirect != null) {</span></span>
<span class="line"><span>        // 执行补丁逻辑</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return 100L; // 原逻辑</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>特点：兼容性好，实时生效，但会增加方法数</p><p><strong>iOS 方案</strong>：</p><ul><li><strong>JSPatch</strong>：使用 JavaScript 调用 iOS 原生接口 特点：符合 Apple 审核原则，群众基础广泛</li></ul><h3 id="混合方案" tabindex="-1">混合方案 <a class="header-anchor" href="#混合方案" aria-label="Permalink to &quot;混合方案&quot;">​</a></h3><p>混合方案基于 Web 技术，开发效率高但性能略有损耗。</p><p><strong>HTML5 方案</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[Web资源] -&gt; [下载更新] -&gt; [替换缓存] -&gt; [立即生效]</span></span></code></pre></div><p>特点：跨平台支持，简单易用，但性能较差</p><p><strong>小程序容器</strong>： 如 FinClip SDK，将小程序运行时嵌入原生应用</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[原生应用] + [小程序容器] -&gt; [加载小程序] -&gt; [热更新业务模块]</span></span></code></pre></div><p>特点：体验接近原生，安全沙箱隔离</p><h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h2><p>热更新系统的核心技术流程涉及客户端与服务端的协同工作。</p><h3 id="核心流程" tabindex="-1">核心流程 <a class="header-anchor" href="#核心流程" aria-label="Permalink to &quot;核心流程&quot;">​</a></h3><p>典型的热更新过程包含以下几个阶段：</p><ol><li><strong>更新检测</strong>：应用启动时或定期检查服务器是否有更新</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[应用启动] -&gt; [请求服务器] -&gt; [版本比对] -&gt; [判断是否需要更新]</span></span></code></pre></div><ol start="2"><li><strong>补丁下载</strong>：从服务器获取差异化的更新包</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[全量更新] : 下载完整新版本</span></span>
<span class="line"><span>[增量更新] : 仅下载变更部分，节省流量</span></span></code></pre></div><ol start="3"><li><strong>验证合并</strong>：校验补丁完整性并合并到应用中</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[签名验证] -&gt; [完整性检查] -&gt; [安全合并]</span></span></code></pre></div><ol start="4"><li><strong>动态加载</strong>：使用类加载机制替换原有代码</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[DexClassLoader] (Android)</span></span>
<span class="line"><span>[JSContext] (iOS JSPatch)</span></span></code></pre></div><h3 id="webpack-hmr-原理" tabindex="-1">Webpack HMR 原理 <a class="header-anchor" href="#webpack-hmr-原理" aria-label="Permalink to &quot;Webpack HMR 原理&quot;">​</a></h3><p>Webpack 的热模块替换是现代前端开发中的重要技术。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[文件修改] -&gt; [Webpack检测] -&gt; [编译补丁] -&gt; [WS推送] -&gt; [浏览器替换]</span></span></code></pre></div><p>详细流程：</p><ol><li>文件系统监听文件变化</li><li>Webpack 编译生成两个补丁文件： <ul><li><code>manifest</code> (JSON)：描述变化的模块</li><li><code>updated chunk</code> (JS)：包含实现代码</li></ul></li><li>通过 WebSocket 推送到浏览器</li><li>HMR Runtime 接收并应用更新</li></ol><h3 id="资源更新机制" tabindex="-1">资源更新机制 <a class="header-anchor" href="#资源更新机制" aria-label="Permalink to &quot;资源更新机制&quot;">​</a></h3><p>除了代码更新，资源文件也有不同的更新策略：</p><ul><li><strong>增量更新</strong>：只更新变化的资源文件 优点：速度快，流量小 缺点：需要维护版本管理</li><li><strong>全量更新</strong>：替换所有资源文件 优点：管理简单 缺点：速度慢，流量大</li></ul><h2 id="实现要点" tabindex="-1">实现要点 <a class="header-anchor" href="#实现要点" aria-label="Permalink to &quot;实现要点&quot;">​</a></h2><p>实现一个稳定可靠的热更新系统需要关注多个技术细节。</p><h3 id="客户端实现" tabindex="-1">客户端实现 <a class="header-anchor" href="#客户端实现" aria-label="Permalink to &quot;客户端实现&quot;">​</a></h3><p>客户端需要具备更新检测、下载和安全验证能力。</p><p><strong>更新检测策略</strong>：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 示例：检测更新时机</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> checkUpdate</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">    // 启动时检测</span></span>
<span class="line"><span style="color:#E1E4E8;">    appLaunch → </span><span style="color:#B392F0;">checkVersion</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // 定时检测</span></span>
<span class="line"><span style="color:#B392F0;">    setInterval</span><span style="color:#E1E4E8;">(checkVersion, </span><span style="color:#79B8FF;">24</span><span style="color:#F97583;"> *</span><span style="color:#79B8FF;"> 60</span><span style="color:#F97583;"> *</span><span style="color:#79B8FF;"> 60</span><span style="color:#F97583;"> *</span><span style="color:#79B8FF;"> 1000</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">    // 用户手动触发</span></span>
<span class="line"><span style="color:#E1E4E8;">    settingsPage → </span><span style="color:#B392F0;">manualCheck</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p><strong>下载与验证</strong>：</p><ul><li>断点续传支持</li><li>文件完整性校验 (MD5/SHA1)</li><li>数字签名验证</li></ul><h3 id="服务端管理" tabindex="-1">服务端管理 <a class="header-anchor" href="#服务端管理" aria-label="Permalink to &quot;服务端管理&quot;">​</a></h3><p>服务端需要支持精准的更新发布控制。</p><p><strong>灰度发布策略</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[内部测试] -&gt; [5%用户] -&gt; [20%用户] -&gt; [全量发布]</span></span></code></pre></div><p>可根据设备类型、版本、用户标签等进行精准控制</p><p><strong>版本管理</strong>：</p><ul><li>补丁版本兼容性检查</li><li>多版本支持与回滚机制</li><li>更新策略配置化</li></ul><h3 id="安全与稳定性" tabindex="-1">安全与稳定性 <a class="header-anchor" href="#安全与稳定性" aria-label="Permalink to &quot;安全与稳定性&quot;">​</a></h3><p>热更新引入的安全风险需要特别关注。</p><p><strong>安全措施</strong>：</p><ul><li>补丁签名机制，防止篡改</li><li>传输加密，避免中间人攻击</li><li>代码混淆，增加反编译难度</li></ul><p><strong>稳定性保障</strong>：</p><ul><li>补丁兼容性测试</li><li>回滚机制，更新失败时恢复</li><li>性能监控，确保更新后应用稳定</li></ul><h2 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;适用场景&quot;">​</a></h2><p>热更新技术在不同场景下发挥独特价值。</p><h3 id="业务场景" tabindex="-1">业务场景 <a class="header-anchor" href="#业务场景" aria-label="Permalink to &quot;业务场景&quot;">​</a></h3><ul><li><strong>紧急 Bug 修复</strong>：绕过商店审核，快速修复线上问题</li><li><strong>AB 测试</strong>：同一批用户可测试不同方案</li><li><strong>活动运营</strong>：快速上线临时活动页面</li><li><strong>渐进式发布</strong>：逐步放开新功能，降低风险</li></ul><h3 id="技术场景" tabindex="-1">技术场景 <a class="header-anchor" href="#技术场景" aria-label="Permalink to &quot;技术场景&quot;">​</a></h3><ul><li><strong>基础库更新</strong>：修复安全漏洞，更新工具库</li><li><strong>UI 调整</strong>：修改界面样式和交互逻辑</li><li><strong>业务逻辑变更</strong>：调整业务流程和规则</li><li><strong>资源更新</strong>：更新图片、文案等静态资源</li></ul><h3 id="限制与约束" tabindex="-1">限制与约束 <a class="header-anchor" href="#限制与约束" aria-label="Permalink to &quot;限制与约束&quot;">​</a></h3><p>热更新并非万能，有其使用边界：</p><ul><li>iOS 对热更新有严格限制，可能违反审核协议</li><li>结构性变更无法通过热更新实现</li><li>性能敏感场景需谨慎使用</li><li>二进制代码更新受平台限制</li></ul>`,79)])])}const h=s(t,[["render",i]]);export{u as __pageData,h as default};
