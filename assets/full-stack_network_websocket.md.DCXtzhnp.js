import{_ as n,c as e,o as s,b as l}from"./chunks/framework.CMLuPXeo.js";const u=JSON.parse('{"title":"WebSocket","description":"","frontmatter":{},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"历史","slug":"历史","link":"#历史","children":[]},{"level":2,"title":"协议概述","slug":"协议概述","link":"#协议概述","children":[]},{"level":2,"title":"核心特点","slug":"核心特点","link":"#核心特点","children":[{"level":3,"title":"全双工通信","slug":"全双工通信","link":"#全双工通信","children":[]},{"level":3,"title":"持久连接","slug":"持久连接","link":"#持久连接","children":[]},{"level":3,"title":"低延迟与轻量开销","slug":"低延迟与轻量开销","link":"#低延迟与轻量开销","children":[]},{"level":3,"title":"基于帧的传输","slug":"基于帧的传输","link":"#基于帧的传输","children":[]},{"level":3,"title":"双向实时性","slug":"双向实时性","link":"#双向实时性","children":[]}]},{"level":2,"title":"工作原理","slug":"工作原理","link":"#工作原理","children":[{"level":3,"title":"连接握手","slug":"连接握手","link":"#连接握手","children":[]},{"level":3,"title":"数据传输","slug":"数据传输","link":"#数据传输","children":[]},{"level":3,"title":"连接维护","slug":"连接维护","link":"#连接维护","children":[]}]},{"level":2,"title":"数据帧格式","slug":"数据帧格式","link":"#数据帧格式","children":[]},{"level":2,"title":"适用场景","slug":"适用场景","link":"#适用场景","children":[{"level":3,"title":"即时通讯系统","slug":"即时通讯系统","link":"#即时通讯系统","children":[]},{"level":3,"title":"实时协作工具","slug":"实时协作工具","link":"#实时协作工具","children":[]},{"level":3,"title":"金融与行情更新","slug":"金融与行情更新","link":"#金融与行情更新","children":[]},{"level":3,"title":"在线游戏","slug":"在线游戏","link":"#在线游戏","children":[]},{"level":3,"title":"实时监控系统","slug":"实时监控系统","link":"#实时监控系统","children":[]}]},{"level":2,"title":"与 HTTP 对比","slug":"与-http-对比","link":"#与-http-对比","children":[{"level":3,"title":"通信模式差异","slug":"通信模式差异","link":"#通信模式差异","children":[]},{"level":3,"title":"性能优势","slug":"性能优势","link":"#性能优势","children":[]},{"level":3,"title":"技术选型考量","slug":"技术选型考量","link":"#技术选型考量","children":[]}]}],"relativePath":"full-stack/network/websocket.md","filePath":"full-stack/network/websocket.md"}'),t={name:"full-stack/network/websocket.md"};function i(p,a,o,c,r,d){return s(),e("div",null,[...a[0]||(a[0]=[l(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /full-stack/network/websocket.md for this page in Markdown format</div><h1 id="websocket" tabindex="-1">WebSocket <a class="header-anchor" href="#websocket" aria-label="Permalink to &quot;WebSocket&quot;">​</a></h1><h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><p>WebSocket 是 HTML5 提供的一种在单个 TCP 连接上进行<strong>全双工通信</strong>的协议。它实现了客户端与服务端之间的双向实时数据交换，解决了传统 HTTP 协议在实时通信场景下的效率问题。WebSocket 协议通过一次 HTTP 握手建立连接，之后通信双方即可随时互相推送数据，显著减少了网络延迟和不必要的数据交换。</p><h2 id="历史" tabindex="-1">历史 <a class="header-anchor" href="#历史" aria-label="Permalink to &quot;历史&quot;">​</a></h2><p>WebSocket 协议的产生源于 Web 应用对实时通信能力日益增长的需求。在 WebSocket 出现之前，开发者通常使用 AJAX 轮询或长轮询等技术模拟实时通信，但这些方案存在效率低下、资源消耗大、数据实时性差等问题。2011 年，IETF (互联网工程任务组) 发布了 RFC 6455，正式标准化了 WebSocket 协议。随着 HTML5 的推广和主流浏览器的支持，WebSocket 已成为 Web 实时通信的基石技术。</p><h2 id="协议概述" tabindex="-1">协议概述 <a class="header-anchor" href="#协议概述" aria-label="Permalink to &quot;协议概述&quot;">​</a></h2><p>WebSocket 是一种独立的基于 TCP 的协议，但与 HTTP 有良好的兼容性。它使用 <strong>ws</strong> (非加密) 和 <strong>wss</strong> (加密) 作为 URL 方案，默认分别占用 80 和 443 端口。WebSocket 连接建立需要一次 HTTP 升级握手，之后客户端和服务器便可以在单个持久连接上自由交换数据。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP 请求-响应: 客户端 -&gt; 请求 -&gt; 服务器 -&gt; 响应 -&gt; 客户端 (循环)</span></span>
<span class="line"><span>WebSocket 全双工: 客户端 &lt;--&gt; 服务器 (持久连接，双向通信)</span></span></code></pre></div><h2 id="核心特点" tabindex="-1">核心特点 <a class="header-anchor" href="#核心特点" aria-label="Permalink to &quot;核心特点&quot;">​</a></h2><h3 id="全双工通信" tabindex="-1">全双工通信 <a class="header-anchor" href="#全双工通信" aria-label="Permalink to &quot;全双工通信&quot;">​</a></h3><p>WebSocket 允许客户端和服务器同时独立地发送和接收数据，这与 HTTP 的半双工模式 (必须等待请求才能响应) 形成鲜明对比。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP: 客户端请求 -&gt; 服务器响应 -&gt; 客户端请求 -&gt; ... (单向交替)</span></span>
<span class="line"><span>WebSocket: 客户端 &lt;-&gt; 服务器 (同时双向)</span></span></code></pre></div><h3 id="持久连接" tabindex="-1">持久连接 <a class="header-anchor" href="#持久连接" aria-label="Permalink to &quot;持久连接&quot;">​</a></h3><p>一旦 WebSocket 连接建立，它将一直保持打开状态，直到显式关闭。这消除了传统 HTTP 短连接反复建立和断开带来的开销。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP: 连接 -&gt; 请求 -&gt; 响应 -&gt; 断开 (每次交互)</span></span>
<span class="line"><span>WebSocket: 连接 -&gt; 保持 -&gt; 数据传输 -&gt; ... -&gt; 手动关闭</span></span></code></pre></div><h3 id="低延迟与轻量开销" tabindex="-1">低延迟与轻量开销 <a class="header-anchor" href="#低延迟与轻量开销" aria-label="Permalink to &quot;低延迟与轻量开销&quot;">​</a></h3><p>WebSocket 在建立连接后，数据传输使用轻量级的帧结构，头部开销极小 (仅 2-14 字节)。数据一旦可用就立即发送，无需客户端重复请求，显著降低了通信延迟。</p><h3 id="基于帧的传输" tabindex="-1">基于帧的传输 <a class="header-anchor" href="#基于帧的传输" aria-label="Permalink to &quot;基于帧的传输&quot;">​</a></h3><p>WebSocket 采用二进制帧格式传输数据。每个帧包含操作码、掩码、数据长度和载荷等核心字段，支持文本、二进制数据等多种数据类型。</p><h3 id="双向实时性" tabindex="-1">双向实时性 <a class="header-anchor" href="#双向实时性" aria-label="Permalink to &quot;双向实时性&quot;">​</a></h3><p>服务器可以主动向客户端推送信息，客户端也能随时向服务器发送数据，这使得 WebSocket 非常适合实时性要求高的应用。</p><h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h2><h3 id="连接握手" tabindex="-1">连接握手 <a class="header-anchor" href="#连接握手" aria-label="Permalink to &quot;连接握手&quot;">​</a></h3><p>WebSocket 连接始于一个特殊的 HTTP 升级请求：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>客户端请求:</span></span>
<span class="line"><span>GET /chat HTTP/1.1</span></span>
<span class="line"><span>Host: server.example.com</span></span>
<span class="line"><span>Upgrade: websocket           # 请求协议升级</span></span>
<span class="line"><span>Connection: Upgrade          # 指示升级连接</span></span>
<span class="line"><span>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==  # 随机密钥</span></span>
<span class="line"><span>Sec-WebSocket-Version: 13    # 协议版本</span></span>
<span class="line"><span></span></span>
<span class="line"><span>服务器响应:</span></span>
<span class="line"><span>HTTP/1.1 101 Switching Protocols</span></span>
<span class="line"><span>Upgrade: websocket</span></span>
<span class="line"><span>Connection: Upgrade</span></span>
<span class="line"><span>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=  # 验证响应</span></span></code></pre></div><p>握手成功后，底层 TCP 连接被复用，后续通信脱离 HTTP 协议。</p><h3 id="数据传输" tabindex="-1">数据传输 <a class="header-anchor" href="#数据传输" aria-label="Permalink to &quot;数据传输&quot;">​</a></h3><p>握手完成后，数据通过 WebSocket 帧进行传输。帧结构精简，主要包含：</p><ul><li>操作码：区分数据类型 (文本、二进制、关闭帧、Ping/Pong 等)</li><li>载荷长度：数据长度指示</li><li>掩码：客户端到服务器的帧需要掩码处理</li><li>数据载荷：实际传输内容</li></ul><h3 id="连接维护" tabindex="-1">连接维护 <a class="header-anchor" href="#连接维护" aria-label="Permalink to &quot;连接维护&quot;">​</a></h3><p>WebSocket 通过 <strong>Ping/Pong 心跳机制</strong>保持连接活跃。服务器定期发送 Ping 帧，客户端回应 Pong 帧，若超时未收到响应则判定连接失效。任何一方都可以发送关闭帧 (操作码 0x08) 来正常终止连接。</p><h2 id="数据帧格式" tabindex="-1">数据帧格式 <a class="header-anchor" href="#数据帧格式" aria-label="Permalink to &quot;数据帧格式&quot;">​</a></h2><p>WebSocket 通信的最小单位是帧，多个帧可以组成一条完整消息。帧格式按位精细定义：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span> 0                   1                   2                   3</span></span>
<span class="line"><span> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span></span>
<span class="line"><span>+-+-+-+-+-------+-+-------------+-------------------------------+</span></span>
<span class="line"><span>|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span></span>
<span class="line"><span>|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span></span>
<span class="line"><span>|N|V|V|V|       |S|             |   (if payload len==126/127)   |</span></span>
<span class="line"><span>| |1|2|3|       |K|             |                               |</span></span>
<span class="line"><span>+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span></span>
<span class="line"><span>|     Extended payload length continued, if payload len == 127  |</span></span>
<span class="line"><span>+ - - - - - - - - - - - - - - - +-------------------------------+</span></span>
<span class="line"><span>|                               |Masking-key, if MASK set to 1  |</span></span>
<span class="line"><span>+-------------------------------+-------------------------------+</span></span>
<span class="line"><span>| Masking-key (continued)       |          Payload Data         |</span></span>
<span class="line"><span>+-------------------------------- - - - - - - - - - - - - - - - +</span></span>
<span class="line"><span>:                     Payload Data continued ...                :</span></span>
<span class="line"><span>+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span></span>
<span class="line"><span>|                     Payload Data continued ...                |</span></span>
<span class="line"><span>+---------------------------------------------------------------+</span></span></code></pre></div><p>关键字段说明：</p><ul><li>FIN：标识是否为消息的最后一帧</li><li>操作码：定义数据类型 (0x1=文本，0x2=二进制，0x8=关闭连接等)</li><li>Mask：指示是否使用掩码</li><li>Payload length：数据载荷长度</li></ul><h2 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;适用场景&quot;">​</a></h2><h3 id="即时通讯系统" tabindex="-1">即时通讯系统 <a class="header-anchor" href="#即时通讯系统" aria-label="Permalink to &quot;即时通讯系统&quot;">​</a></h3><p>网页版微信、企业微信、在线客服等需要实时收发消息的应用。WebSocket 能保证消息的即时性和低延迟。</p><h3 id="实时协作工具" tabindex="-1">实时协作工具 <a class="header-anchor" href="#实时协作工具" aria-label="Permalink to &quot;实时协作工具&quot;">​</a></h3><p>腾讯文档、飞书文档等多人协作编辑场景，需要实时同步光标位置和内容变更。</p><h3 id="金融与行情更新" tabindex="-1">金融与行情更新 <a class="header-anchor" href="#金融与行情更新" aria-label="Permalink to &quot;金融与行情更新&quot;">​</a></h3><p>股票、期货等实时行情数据系统，每秒可能需要多次更新，WebSocket 推送比轮询更高效。</p><h3 id="在线游戏" tabindex="-1">在线游戏 <a class="header-anchor" href="#在线游戏" aria-label="Permalink to &quot;在线游戏&quot;">​</a></h3><p>网页版多人在线游戏 (如联机贪吃蛇)，需要实时同步玩家操作和游戏状态。</p><h3 id="实时监控系统" tabindex="-1">实时监控系统 <a class="header-anchor" href="#实时监控系统" aria-label="Permalink to &quot;实时监控系统&quot;">​</a></h3><p>物联网设备监控、服务器性能监控等场景，需要持续接收设备或服务器推送的状态数据。</p><h2 id="与-http-对比" tabindex="-1">与 HTTP 对比 <a class="header-anchor" href="#与-http-对比" aria-label="Permalink to &quot;与 HTTP 对比&quot;">​</a></h2><h3 id="通信模式差异" tabindex="-1">通信模式差异 <a class="header-anchor" href="#通信模式差异" aria-label="Permalink to &quot;通信模式差异&quot;">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>HTTP: </span></span>
<span class="line"><span>  客户端 -&gt; [请求] -&gt; 服务器</span></span>
<span class="line"><span>  客户端 &lt;- [响应] &lt;- 服务器</span></span>
<span class="line"><span>  (循环，每次请求都需要建立连接)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>WebSocket:</span></span>
<span class="line"><span>  客户端 -&gt; [握手] -&gt; 服务器</span></span>
<span class="line"><span>  客户端 &lt;- [确认] &lt;- 服务器</span></span>
<span class="line"><span>  客户端 &lt;-&gt; 服务器 (持久双向通信)</span></span></code></pre></div><h3 id="性能优势" tabindex="-1">性能优势 <a class="header-anchor" href="#性能优势" aria-label="Permalink to &quot;性能优势&quot;">​</a></h3><p>与传统 HTTP 轮询相比，WebSocket 具有显著性能优势：</p><ul><li><strong>减少网络开销</strong>：避免重复的 HTTP 头部和连接建立</li><li><strong>降低延迟</strong>：服务器数据立即可推送，无需等待客户端请求</li><li><strong>提升吞吐量</strong>：轻量级帧结构支持更高频率的数据交换</li></ul><h3 id="技术选型考量" tabindex="-1">技术选型考量 <a class="header-anchor" href="#技术选型考量" aria-label="Permalink to &quot;技术选型考量&quot;">​</a></h3><ul><li><strong>选择 WebSocket</strong>：需要低延迟双向通信、服务器主动推送、高频数据交换的场景</li><li><strong>选择 HTTP</strong>：简单请求-响应、资源缓存、兼容性要求高的传统 Web 应用</li></ul>`,56)])])}const b=n(t,[["render",i]]);export{u as __pageData,b as default};
