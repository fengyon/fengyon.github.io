import{_ as n,c as a,o as l,b as e}from"./chunks/framework.CMLuPXeo.js";const y=JSON.parse('{"title":"云函数","description":"","frontmatter":{},"headers":[{"level":2,"title":"核心概念与工作原理","slug":"核心概念与工作原理","link":"#核心概念与工作原理","children":[]},{"level":2,"title":"主要特点","slug":"主要特点","link":"#主要特点","children":[{"level":3,"title":"无需服务器管理","slug":"无需服务器管理","link":"#无需服务器管理","children":[]},{"level":3,"title":"事件驱动与多种触发方式","slug":"事件驱动与多种触发方式","link":"#事件驱动与多种触发方式","children":[]},{"level":3,"title":"自动弹性伸缩","slug":"自动弹性伸缩","link":"#自动弹性伸缩","children":[]},{"level":3,"title":"精细化的按需计费","slug":"精细化的按需计费","link":"#精细化的按需计费","children":[]},{"level":3,"title":"多语言支持","slug":"多语言支持","link":"#多语言支持","children":[]}]},{"level":2,"title":"函数类型与开发模式","slug":"函数类型与开发模式","link":"#函数类型与开发模式","children":[{"level":3,"title":"事件函数 (Event Function)","slug":"事件函数-event-function","link":"#事件函数-event-function","children":[]},{"level":3,"title":"Web 云函数 (Web Function)","slug":"web-云函数-web-function","link":"#web-云函数-web-function","children":[]}]},{"level":2,"title":"典型应用场景","slug":"典型应用场景","link":"#典型应用场景","children":[{"level":3,"title":"弹性伸缩的 API 后端","slug":"弹性伸缩的-api-后端","link":"#弹性伸缩的-api-后端","children":[]},{"level":3,"title":"实时文件处理","slug":"实时文件处理","link":"#实时文件处理","children":[]},{"level":3,"title":"数据处理与 ETL","slug":"数据处理与-etl","link":"#数据处理与-etl","children":[]},{"level":3,"title":"自动化任务与定时作业","slug":"自动化任务与定时作业","link":"#自动化任务与定时作业","children":[]}]},{"level":2,"title":"技术优势与局限性","slug":"技术优势与局限性","link":"#技术优势与局限性","children":[{"level":3,"title":"核心优势","slug":"核心优势","link":"#核心优势","children":[]},{"level":3,"title":"挑战与局限性","slug":"挑战与局限性","link":"#挑战与局限性","children":[]}]},{"level":2,"title":"开发与部署流程","slug":"开发与部署流程","link":"#开发与部署流程","children":[{"level":3,"title":"基本开发流程","slug":"基本开发流程","link":"#基本开发流程","children":[]},{"level":3,"title":"函数调用方式","slug":"函数调用方式","link":"#函数调用方式","children":[]}]}],"relativePath":"full-stack/serverless/functions.md","filePath":"full-stack/serverless/functions.md"}'),o={name:"full-stack/serverless/functions.md"};function t(p,s,r,i,c,E){return l(),a("div",null,[...s[0]||(s[0]=[e(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /full-stack/serverless/functions.md for this page in Markdown format</div><h1 id="云函数" tabindex="-1">云函数 <a class="header-anchor" href="#云函数" aria-label="Permalink to &quot;云函数&quot;">​</a></h1><p>云函数是一项基于 <strong>Serverless (无服务器)</strong> 架构的计算服务，它提供 <strong>FaaS (Function as a Service)</strong> 能力，让开发者能够将开发测试的对象聚焦到函数级别。开发者只需编写函数代码并部署到云端，无需购买、搭建和管理服务器，云函数会根据实际流量进行弹性伸缩，自动处理基础设施的管理和维护。</p><h2 id="核心概念与工作原理" tabindex="-1">核心概念与工作原理 <a class="header-anchor" href="#核心概念与工作原理" aria-label="Permalink to &quot;核心概念与工作原理&quot;">​</a></h2><p>云函数的核心思想是<strong>事件驱动的函数即服务</strong>。开发者编写独立的函数代码，云平台负责在有事件触发时执行这些函数。</p><p><strong>基本工作流程：</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>事件触发 → 资源分配 → 执行函数 → 返回结果 → 释放资源</span></span>
<span class="line"><span>    ↑          ↓          ↓          ↓         ↓</span></span>
<span class="line"><span> HTTP请求   分配计算   运行业务   输出响应   回收计算</span></span>
<span class="line"><span> 消息队列   资源实例   逻辑代码   数据     资源</span></span></code></pre></div><p><strong>物理设计上</strong>，一个云函数可由多个文件组成，占用一定量的 CPU 内存等计算资源；各云函数完全独立；可分别部署在不同的地区。</p><p>每个云函数都在自己的容器中运行，平台自动管理底层计算资源。当函数被触发时，云平台会分配必要的内存和 CPU 资源，函数运行结束后，这些资源会被回收。</p><h2 id="主要特点" tabindex="-1">主要特点 <a class="header-anchor" href="#主要特点" aria-label="Permalink to &quot;主要特点&quot;">​</a></h2><h3 id="无需服务器管理" tabindex="-1">无需服务器管理 <a class="header-anchor" href="#无需服务器管理" aria-label="Permalink to &quot;无需服务器管理&quot;">​</a></h3><p>云函数将服务器管理、资源调度和监控运维完全交由云平台处理：</p><ul><li><strong>免服务器管理</strong>：自动处理服务器配置、部署、监控</li><li><strong>自动扩缩容</strong>：根据请求量自动调整实例数量</li><li><strong>高可用保障</strong>：内置负载均衡和故障转移机制</li></ul><h3 id="事件驱动与多种触发方式" tabindex="-1">事件驱动与多种触发方式 <a class="header-anchor" href="#事件驱动与多种触发方式" aria-label="Permalink to &quot;事件驱动与多种触发方式&quot;">​</a></h3><p>云函数基于<strong>事件触发模型</strong>完成消息的收发及业务处理，支持多种触发方式：</p><ul><li><strong>HTTP 请求</strong> (通过 API 网关)</li><li><strong>消息队列</strong> (如 CKafka)</li><li><strong>定时触发器</strong> (使用 cron 表达式)</li><li><strong>云存储事件</strong> (如文件上传)</li><li><strong>数据库变更</strong></li></ul><h3 id="自动弹性伸缩" tabindex="-1">自动弹性伸缩 <a class="header-anchor" href="#自动弹性伸缩" aria-label="Permalink to &quot;自动弹性伸缩&quot;">​</a></h3><p>云函数具备强大的自动扩缩容能力：</p><ul><li><strong>快速启动</strong>：毫秒级冷启动，快速响应用户请求</li><li><strong>自动扩缩容</strong>：根据请求量自动调整实例数量</li><li><strong>按需扩容</strong>：从零到数千实例的秒级扩展能力</li></ul><h3 id="精细化的按需计费" tabindex="-1">精细化的按需计费 <a class="header-anchor" href="#精细化的按需计费" aria-label="Permalink to &quot;精细化的按需计费&quot;">​</a></h3><p>云函数采用<strong>按实际使用量计费</strong>的模式：</p><ul><li><strong>零闲置成本</strong>：只在函数实际执行时计费，空闲时零费用</li><li><strong>按执行时间计费</strong>：按函数运行时长和配置内存付费</li><li><strong>按调用次数计费</strong>：根据函数被调用的次数计费</li></ul><h3 id="多语言支持" tabindex="-1">多语言支持 <a class="header-anchor" href="#多语言支持" aria-label="Permalink to &quot;多语言支持&quot;">​</a></h3><p>主流云函数平台支持多种编程语言：</p><table tabindex="0"><thead><tr><th>语言</th><th>版本支持</th><th>特点</th></tr></thead><tbody><tr><td>Node.js</td><td>12.x, 14.x, 16.x, 18.x</td><td>生态丰富，适合快速开发</td></tr><tr><td>Python</td><td>3.6, 3.7, 3.9</td><td>数据处理能力强，AI/ML 友好</td></tr><tr><td>Java</td><td>8, 11</td><td>企业级应用，性能稳定</td></tr><tr><td>Golang</td><td>1.x</td><td>高性能，并发处理优秀</td></tr><tr><td>PHP</td><td>7.2, 8.0</td><td>Web 开发友好</td></tr></tbody></table><h2 id="函数类型与开发模式" tabindex="-1">函数类型与开发模式 <a class="header-anchor" href="#函数类型与开发模式" aria-label="Permalink to &quot;函数类型与开发模式&quot;">​</a></h2><h3 id="事件函数-event-function" tabindex="-1">事件函数 (Event Function) <a class="header-anchor" href="#事件函数-event-function" aria-label="Permalink to &quot;事件函数 (Event Function)&quot;">​</a></h3><p>适合处理事件驱动的业务逻辑：</p><ul><li><strong>专注业务逻辑</strong>，无需关心 HTTP 协议细节</li><li>支持多种触发方式 (SDK、HTTP、定时器)</li><li>简单的入参和返回值格式</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 示例：温度转换事件函数</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> function_sdk</span></span>
<span class="line"><span style="color:#E1E4E8;">import json</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">cli = function_sdk.EdgeClient()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">def handler(event, context):</span></span>
<span class="line"><span style="color:#E1E4E8;">    # 获取消息内容</span></span>
<span class="line"><span style="color:#E1E4E8;">    msg = json.loads(event[</span><span style="color:#9ECBFF;">&quot;payload&quot;</span><span style="color:#E1E4E8;">].decode(</span><span style="color:#9ECBFF;">&#39;utf-8&#39;</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    # 业务逻辑：摄氏温度转华氏温度</span></span>
<span class="line"><span style="color:#E1E4E8;">    if msg[</span><span style="color:#9ECBFF;">&quot;celsius&quot;</span><span style="color:#E1E4E8;">] &gt; 100:</span></span>
<span class="line"><span style="color:#E1E4E8;">        msg[</span><span style="color:#9ECBFF;">&quot;fahrenheit&quot;</span><span style="color:#E1E4E8;">] = msg[</span><span style="color:#9ECBFF;">&quot;celsius&quot;</span><span style="color:#E1E4E8;">] </span><span style="color:#79B8FF;">*</span><span style="color:#E1E4E8;"> 1.8 + 32</span></span>
<span class="line"><span style="color:#E1E4E8;">        payload = json.dumps(msg).encode(</span><span style="color:#9ECBFF;">&#39;utf-8&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        # 向指定 topic 发送消息</span></span>
<span class="line"><span style="color:#E1E4E8;">        cli.publish(</span><span style="color:#9ECBFF;">&quot;converted_topic&quot;</span><span style="color:#E1E4E8;">, payload)</span></span></code></pre></div><h3 id="web-云函数-web-function" tabindex="-1">Web 云函数 (Web Function) <a class="header-anchor" href="#web-云函数-web-function" aria-label="Permalink to &quot;Web 云函数 (Web Function)&quot;">​</a></h3><p>适合构建完整的 Web 应用和 API 服务：</p><ul><li>完整的 <strong>HTTP 请求/响应</strong>处理能力</li><li>支持主流 <strong>Web 框架</strong> (Express.js、Koa.js)</li><li>支持 SSE、WebSocket 等实时通信</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 示例：Express.js Web 函数</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> express</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;express&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> app</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> express</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">app.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/api/users&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">req</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">res</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> users</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> ctx.mpserverless.db.</span><span style="color:#B392F0;">collection</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;users&#39;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">find</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">  res.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">(users)</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF;">exports</span><span style="color:#E1E4E8;">.main </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> app</span></span></code></pre></div><h2 id="典型应用场景" tabindex="-1">典型应用场景 <a class="header-anchor" href="#典型应用场景" aria-label="Permalink to &quot;典型应用场景&quot;">​</a></h2><h3 id="弹性伸缩的-api-后端" tabindex="-1">弹性伸缩的 API 后端 <a class="header-anchor" href="#弹性伸缩的-api-后端" aria-label="Permalink to &quot;弹性伸缩的 API 后端&quot;">​</a></h3><p>云函数特别适合构建<strong>弹性伸缩的 API 后端服务</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>客户端 → API网关 → 云函数 → 数据库</span></span>
<span class="line"><span>            ↓</span></span>
<span class="line"><span>      自动伸缩处理流量波动</span></span></code></pre></div><p>当使用云函数 SCF 构建 API 时，SCF 函数的一次执行可以处理一个 HTTP 请求。云函数 SCF 会根据对单个函数的需求自动进行弹性伸缩。</p><h3 id="实时文件处理" tabindex="-1">实时文件处理 <a class="header-anchor" href="#实时文件处理" aria-label="Permalink to &quot;实时文件处理&quot;">​</a></h3><p>云函数可用于<strong>实时文件处理和转换</strong>：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>文件上传 → 触发函数 → 处理文件 → 存储结果</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>图片压缩、格式转换、内容审核</span></span></code></pre></div><p>云函数可以轻松与云存储服务集成，在文件被创建或更新时触发函数。</p><h3 id="数据处理与-etl" tabindex="-1">数据处理与 ETL <a class="header-anchor" href="#数据处理与-etl" aria-label="Permalink to &quot;数据处理与 ETL&quot;">​</a></h3><p>适合<strong>数据清洗、转换和加载</strong>任务：</p><ul><li><strong>数据验证和清洗</strong></li><li><strong>格式转换</strong></li><li><strong>实时数据分析</strong></li></ul><h3 id="自动化任务与定时作业" tabindex="-1">自动化任务与定时作业 <a class="header-anchor" href="#自动化任务与定时作业" aria-label="Permalink to &quot;自动化任务与定时作业&quot;">​</a></h3><p>凭借其<strong>事件驱动</strong>特性和灵活性，云函数 SCF 非常适合用于将那些不需要让整个服务器一直运行的业务自动化。例如执行<strong>定时任务</strong>。</p><h2 id="技术优势与局限性" tabindex="-1">技术优势与局限性 <a class="header-anchor" href="#技术优势与局限性" aria-label="Permalink to &quot;技术优势与局限性&quot;">​</a></h2><h3 id="核心优势" tabindex="-1">核心优势 <a class="header-anchor" href="#核心优势" aria-label="Permalink to &quot;核心优势&quot;">​</a></h3><ol><li><strong>降低成本</strong>：云函数可以大幅度降低开发成本，按实际使用量计费，无需为闲置资源付费</li><li><strong>提升开发效率</strong>：开发者只需关注业务逻辑代码，云函数提供了高效可靠的函数开发与运行框架</li><li><strong>简化运维</strong>：完全托管的基础设施，自动处理扩缩容、监控和故障恢复</li><li><strong>高可用性与弹性</strong>：内置跨可用区部署和自动容错机制</li></ol><h3 id="挑战与局限性" tabindex="-1">挑战与局限性 <a class="header-anchor" href="#挑战与局限性" aria-label="Permalink to &quot;挑战与局限性&quot;">​</a></h3><ol><li><strong>冷启动延迟</strong>：函数实例首次创建或长时间未使用时会有初始化延迟，通过<strong>快照恢复</strong>和<strong>预测预热</strong>技术可降低影响</li><li><strong>执行时间限制</strong>：函数通常有最大执行时间限制 (如 15 分钟)</li><li><strong>状态管理</strong>：函数实例是<strong>无状态</strong>的，需要依赖外部存储保存状态数据</li><li><strong>调试复杂性</strong>：分布式环境下的调试和日志收集较为复杂</li></ol><h2 id="开发与部署流程" tabindex="-1">开发与部署流程 <a class="header-anchor" href="#开发与部署流程" aria-label="Permalink to &quot;开发与部署流程&quot;">​</a></h2><h3 id="基本开发流程" tabindex="-1">基本开发流程 <a class="header-anchor" href="#基本开发流程" aria-label="Permalink to &quot;基本开发流程&quot;">​</a></h3><p>云函数的典型开发流程包括：</p><ol><li><strong>创建函数</strong>：在云平台创建函数，指定名称、运行环境和资源规格</li><li><strong>编写代码</strong>：按照函数签名编写业务逻辑</li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 函数基本结构</span></span>
<span class="line"><span style="color:#79B8FF;">exports</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">main</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> async</span><span style="color:#F97583;"> function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">event</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">context</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 从event参数获取触发事件数据</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">httpMethod</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">path</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">headers</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">body</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> event</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 业务逻辑处理</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> result</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> processRequest</span><span style="color:#E1E4E8;">(body)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">  // 返回响应</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    statusCode: </span><span style="color:#79B8FF;">200</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    headers: { </span><span style="color:#9ECBFF;">&#39;Content-Type&#39;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&#39;application/json&#39;</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#E1E4E8;">    body: </span><span style="color:#79B8FF;">JSON</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">stringify</span><span style="color:#E1E4E8;">(result),</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><ol start="3"><li><strong>本地测试</strong>：使用命令行工具本地运行和调试函数</li><li><strong>部署上线</strong>：将函数代码打包部署到云端</li></ol><h3 id="函数调用方式" tabindex="-1">函数调用方式 <a class="header-anchor" href="#函数调用方式" aria-label="Permalink to &quot;函数调用方式&quot;">​</a></h3><p>云函数支持多种调用方式：</p><ul><li><strong>SDK 调用</strong>：使用各平台提供的 SDK 调用函数</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 小程序中调用云函数示例</span></span>
<span class="line"><span style="color:#E1E4E8;">mpServerless.function</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;getImageList&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">    username: </span><span style="color:#9ECBFF;">&#39;Vincent&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">res</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (res.success </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> res.result) {</span></span>
<span class="line"><span style="color:#79B8FF;">      this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">setData</span><span style="color:#E1E4E8;">({ imageList: res.result.images })</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span></code></pre></div><ul><li><strong>HTTP 触发</strong>：通过 API 网关提供 HTTP 接口</li><li><strong>内部调用</strong>：云函数之间可以互相调用</li></ul>`,64)])])}const u=n(o,[["render",t]]);export{y as __pageData,u as default};
