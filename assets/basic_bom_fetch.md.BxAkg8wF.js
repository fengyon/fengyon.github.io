import{_ as a,c as n,o as e,b as o}from"./chunks/framework.CMLuPXeo.js";const d=JSON.parse('{"title":"Fetch API 教程","description":"","frontmatter":{},"headers":[{"level":2,"title":"基本用法","slug":"基本用法","link":"#基本用法","children":[]},{"level":2,"title":"Response 对象：处理 HTTP 回应","slug":"response-对象-处理-http-回应","link":"#response-对象-处理-http-回应","children":[{"level":3,"title":"Response 对象的同步属性","slug":"response-对象的同步属性","link":"#response-对象的同步属性","children":[]},{"level":3,"title":"判断请求是否成功","slug":"判断请求是否成功","link":"#判断请求是否成功","children":[]},{"level":3,"title":"Response.headers 属性","slug":"response-headers-属性","link":"#response-headers-属性","children":[]},{"level":3,"title":"读取内容的方法","slug":"读取内容的方法","link":"#读取内容的方法","children":[]},{"level":3,"title":"Response.clone()","slug":"response-clone","link":"#response-clone","children":[]},{"level":3,"title":"Response.body 属性","slug":"response-body-属性","link":"#response-body-属性","children":[]}]},{"level":2,"title":"fetch() 的第二个参数：定制 HTTP 请求","slug":"fetch-的第二个参数-定制-http-请求","link":"#fetch-的第二个参数-定制-http-请求","children":[]},{"level":2,"title":"fetch() 配置对象的完整 API","slug":"fetch-配置对象的完整-api","link":"#fetch-配置对象的完整-api","children":[]},{"level":2,"title":"取消 fetch() 请求","slug":"取消-fetch-请求","link":"#取消-fetch-请求","children":[]},{"level":2,"title":"参考链接","slug":"参考链接","link":"#参考链接","children":[]}],"relativePath":"basic/bom/fetch.md","filePath":"basic/bom/fetch.md"}'),p={name:"basic/bom/fetch.md"};function l(c,s,t,r,E,i){return e(),n("div",null,[...s[0]||(s[0]=[o(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /basic/bom/fetch.md for this page in Markdown format</div><h1 id="fetch-api-教程" tabindex="-1">Fetch API 教程 <a class="header-anchor" href="#fetch-api-教程" aria-label="Permalink to &quot;Fetch API 教程&quot;">​</a></h1><p><code>fetch()</code> 是 XMLHttpRequest 的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。</p><p>浏览器原生提供这个对象。本章详细介绍它的用法。</p><h2 id="基本用法" tabindex="-1">基本用法 <a class="header-anchor" href="#基本用法" aria-label="Permalink to &quot;基本用法&quot;">​</a></h2><p><code>fetch()</code> 的功能与 XMLHttpRequest 基本相同，都是向服务器发出 HTTP 请求，但有三个主要的差异。</p><p>(1) <code>fetch()</code> 使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。</p><p>(2) <code>fetch()</code> 采用模块化设计，API 分散在多个对象上 (Response 对象、Request 对象、Headers 对象)，更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。</p><p>(3) <code>fetch()</code> 通过数据流 (Stream 对象) 处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHttpRequest 对象不支持数据流，所有的数据全部放在缓存里，不支持分块读取，必须等待全部获取后，再一次性读取。</p><p>用法上，<code>fetch()</code> 接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象。它的基本用法如下。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(url)</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">catch</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span></code></pre></div><p>下面是一个例子，从服务器获取 JSON 数据。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;https://api.github.com/users/ruanyf&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">response</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">json</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(json))</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">catch</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">err</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Request Failed&#39;</span><span style="color:#E1E4E8;">, err));</span></span></code></pre></div><p>上面示例中，<code>fetch()</code> 接收到的 <code>response</code> 是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API" target="_blank" rel="noreferrer">Stream 对象</a>，里面的数据本例是 JSON 数据，所以使用 <code>response.json()</code> 方法，将其转为 JSON 对象。它是一个异步操作，返回一个 Promise 对象。</p><p>Promise 可以使用 await 语法改写，使得语义更清晰。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> getJSON</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> url </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;"> &#39;https://api.github.com/users/ruanyf&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">  try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    let</span><span style="color:#E1E4E8;"> response </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Request Failed&#39;</span><span style="color:#E1E4E8;">, error);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>上面示例中，<code>await</code> 语句必须放在 <code>try...catch</code> 里面，这样才能捕捉异步操作中可能发生的错误。</p><p>后文都采用 <code>await</code> 的写法，不再使用 <code>.then()</code> 的写法。</p><h2 id="response-对象-处理-http-回应" tabindex="-1">Response 对象：处理 HTTP 回应 <a class="header-anchor" href="#response-对象-处理-http-回应" aria-label="Permalink to &quot;Response 对象：处理 HTTP 回应&quot;">​</a></h2><h3 id="response-对象的同步属性" tabindex="-1">Response 对象的同步属性 <a class="header-anchor" href="#response-对象的同步属性" aria-label="Permalink to &quot;Response 对象的同步属性&quot;">​</a></h3><p><code>fetch()</code> 请求成功以后，得到的是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank" rel="noreferrer">Response 对象</a>。它对应服务器的 HTTP 回应。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(url);</span></span></code></pre></div><p>前面说过，Response 包含的数据通过 Stream 接口异步读取，但是它还包含一些同步属性，对应 HTTP 回应的标头信息 (Headers)，可以立即读取。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> fetchText</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> response </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/readme.txt&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(response.status);</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(response.statusText);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>上面示例中，<code>response.status</code> 和 <code>response.statusText</code> 就是 Response 的同步属性，可以立即读取。</p><p>标头信息属性有下面这些。</p><p><strong>Response.ok</strong></p><p><code>Response.ok</code> 属性返回一个布尔值，表示请求是否成功，<code>true</code> 对应 HTTP 请求的状态码 200 到 299，<code>false</code> 对应其他的状态码。</p><p><strong>Response.status</strong></p><p><code>Response.status</code> 属性返回一个数字，表示 HTTP 回应的状态码 (例如 200，表示成功请求)。</p><p><strong>Response.statusText</strong></p><p><code>Response.statusText</code> 属性返回一个字符串，表示 HTTP 回应的状态信息 (例如请求成功以后，服务器返回“OK”)。</p><p><strong>Response.url</strong></p><p><code>Response.url</code> 属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</p><p><strong>Response.type</strong></p><p><code>Response.type</code> 属性返回请求的类型。可能的值如下：</p><ul><li><code>basic</code>：普通请求，即同源请求。</li><li><code>cors</code>：跨源请求。</li><li><code>error</code>：网络错误，主要用于 Service Worker。</li><li><code>opaque</code>：如果 <code>fetch()</code> 请求的 <code>type</code> 属性设为 <code>no-cors</code>，就会返回这个值，详见请求部分。表示发出的是简单的跨源请求，类似 <code>&lt;form&gt;</code> 表单的那种跨源请求。</li><li><code>opaqueredirect</code>：如果 <code>fetch()</code> 请求的 <code>redirect</code> 属性设为 <code>manual</code>，就会返回这个值，详见请求部分。</li></ul><p><strong>Response.redirected</strong></p><p><code>Response.redirected</code> 属性返回一个布尔值，表示请求是否发生过跳转。</p><h3 id="判断请求是否成功" tabindex="-1">判断请求是否成功 <a class="header-anchor" href="#判断请求是否成功" aria-label="Permalink to &quot;判断请求是否成功&quot;">​</a></h3><p><code>fetch()</code> 发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，<code>fetch()</code> 才会报错，其他情况都不会报错，而是认为请求成功。</p><p>这就是说，即使服务器返回的状态码是 4xx 或 5xx，<code>fetch()</code> 也不会报错 (即 Promise 不会变为 <code>rejected</code> 状态)。</p><p>只有通过 <code>Response.status</code> 属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功。请看下面的例子。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> fetchText</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> response </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/readme.txt&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (response.status </span><span style="color:#F97583;">&gt;=</span><span style="color:#79B8FF;"> 200</span><span style="color:#F97583;"> &amp;&amp;</span><span style="color:#E1E4E8;"> response.status </span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;"> 300</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">text</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    throw</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Error</span><span style="color:#E1E4E8;">(response.statusText);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>上面示例中，<code>response.status</code> 属性只有等于 2xx (200~299)，才能认定请求成功。这里不用考虑网址跳转 (状态码为 3xx)，因为 <code>fetch()</code> 会将跳转的状态码自动转为 200。</p><p>另一种方法是判断 <code>response.ok</code> 是否为 <code>true</code>。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (response.ok) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 请求成功</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  // 请求失败</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="response-headers-属性" tabindex="-1">Response.headers 属性 <a class="header-anchor" href="#response-headers-属性" aria-label="Permalink to &quot;Response.headers 属性&quot;">​</a></h3><p>Response 对象还有一个 <code>Response.headers</code> 属性，指向一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Headers" target="_blank" rel="noreferrer">Headers 对象</a>，对应 HTTP 回应的所有标头。</p><p>Headers 对象可以使用 <code>for...of</code> 循环进行遍历。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> [key, value] </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> response.headers) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`\${</span><span style="color:#E1E4E8;">key</span><span style="color:#9ECBFF;">} : \${</span><span style="color:#E1E4E8;">value</span><span style="color:#9ECBFF;">}\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 或者</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> [key, value] </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> response.headers.</span><span style="color:#B392F0;">entries</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`\${</span><span style="color:#E1E4E8;">key</span><span style="color:#9ECBFF;">} : \${</span><span style="color:#E1E4E8;">value</span><span style="color:#9ECBFF;">}\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>Headers 对象提供了以下方法，用来操作标头。</p><blockquote><ul><li><code>Headers.get()</code>：根据指定的键名，返回键值。</li><li><code>Headers.has()</code>：返回一个布尔值，表示是否包含某个标头。</li><li><code>Headers.set()</code>：将指定的键名设置为新的键值，如果该键名不存在则会添加。</li><li><code>Headers.append()</code>：添加标头。</li><li><code>Headers.delete()</code>：删除标头。</li><li><code>Headers.keys()</code>：返回一个遍历器，可以依次遍历所有键名。</li><li><code>Headers.values()</code>：返回一个遍历器，可以依次遍历所有键值。</li><li><code>Headers.entries()</code>：返回一个遍历器，可以依次遍历所有键值对 (<code>[key, value]</code>)。</li><li><code>Headers.forEach()</code>：依次遍历标头，每个标头都会执行一次参数函数。</li></ul></blockquote><p>上面的有些方法可以修改标头，那是因为继承自 Headers 接口。对于 HTTP 回应来说，修改标头意义不大，况且很多标头是只读的，浏览器不允许修改。</p><p>这些方法中，最常用的是 <code>response.headers.get()</code>，用于读取某个标头的值。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> response </span><span style="color:#F97583;">=</span><span style="color:#F97583;">  await</span><span style="color:#B392F0;">  fetch</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"><span style="color:#E1E4E8;">response.headers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Content-Type&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#6A737D;">// application/json; charset=utf-8</span></span></code></pre></div><p><code>Headers.keys()</code> 和 <code>Headers.values()</code> 方法用来分别遍历标头的键名和键值。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 键名</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> myHeaders.</span><span style="color:#B392F0;">keys</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(key);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 键值</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> value </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> myHeaders.</span><span style="color:#B392F0;">values</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(value);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p><code>Headers.forEach()</code> 方法也可以遍历所有的键值和键名。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> response </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"><span style="color:#E1E4E8;">response.headers.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(key, </span><span style="color:#9ECBFF;">&#39;:&#39;</span><span style="color:#E1E4E8;">, value)</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre></div><h3 id="读取内容的方法" tabindex="-1">读取内容的方法 <a class="header-anchor" href="#读取内容的方法" aria-label="Permalink to &quot;读取内容的方法&quot;">​</a></h3><p><code>Response</code> 对象根据服务器返回的不同类型的数据，提供了不同的读取方法。</p><blockquote><ul><li><code>response.text()</code>：得到文本字符串。</li><li><code>response.json()</code>：得到 JSON 对象。</li><li><code>response.blob()</code>：得到二进制 Blob 对象。</li><li><code>response.formData()</code>：得到 FormData 表单对象。</li><li><code>response.arrayBuffer()</code>：得到二进制 ArrayBuffer 对象。</li></ul></blockquote><p>上面 5 个读取方法都是异步的，返回的都是 Promise 对象。必须等到异步操作结束，才能得到服务器返回的完整数据。</p><p><strong>response.text()</strong></p><p><code>response.text()</code> 可以用于获取文本数据，比如 HTML 文件。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/users.html&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> body</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">text</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">document.body.innerHTML </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> body</span></span></code></pre></div><p><strong>response.json()</strong></p><p><code>response.json()</code> 主要用于获取服务器返回的 JSON 数据，前面已经举过例子了。</p><p><strong>response.formData()</strong></p><p><code>response.formData()</code> 主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。</p><p><strong>response.blob()</strong></p><p><code>response.blob()</code> 用于获取二进制文件。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;flower.jpg&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> myBlob</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">blob</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> objectURL</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> URL</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">createObjectURL</span><span style="color:#E1E4E8;">(myBlob);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> myImage</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">querySelector</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;img&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">myImage.src </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> objectURL;</span></span></code></pre></div><p>上面示例读取图片文件 <code>flower.jpg</code>，显示在网页上。</p><p><strong>response.arrayBuffer()</strong></p><p><code>response.arrayBuffer()</code> 主要用于获取流媒体文件。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> audioCtx</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#E1E4E8;"> window.</span><span style="color:#B392F0;">AudioContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> source</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> audioCtx.</span><span style="color:#B392F0;">createBufferSource</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;song.ogg&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> buffer</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">arrayBuffer</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> decodeData</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> audioCtx.</span><span style="color:#B392F0;">decodeAudioData</span><span style="color:#E1E4E8;">(buffer);</span></span>
<span class="line"><span style="color:#E1E4E8;">source.buffer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> buffer;</span></span>
<span class="line"><span style="color:#E1E4E8;">source.</span><span style="color:#B392F0;">connect</span><span style="color:#E1E4E8;">(audioCtx.destination);</span></span>
<span class="line"><span style="color:#E1E4E8;">source.loop </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> true</span><span style="color:#E1E4E8;">;</span></span></code></pre></div><p>上面示例是 <code>response.arrayBuffer()</code> 获取音频文件 <code>song.ogg</code>，然后在线播放的例子。</p><h3 id="response-clone" tabindex="-1">Response.clone() <a class="header-anchor" href="#response-clone" aria-label="Permalink to &quot;Response.clone()&quot;">​</a></h3><p>Stream 对象只能读取一次，读取完就没了。这意味着，前一节的五个读取方法，只能使用一个，否则会报错。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> text </span><span style="color:#F97583;">=</span><span style="color:#F97583;">  await</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">text</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> json </span><span style="color:#F97583;">=</span><span style="color:#F97583;">  await</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 报错</span></span></code></pre></div><p>上面示例先使用了 <code>response.text()</code>，就把 Stream 读完了。后面再调用 <code>response.json()</code>，就没有内容可读了，所以报错。</p><p>Response 对象提供 <code>Response.clone()</code> 方法，创建 <code>Response</code> 对象的副本，实现多次读取。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response1</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;flowers.jpg&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response2</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> response1.</span><span style="color:#B392F0;">clone</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> myBlob1</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response1.</span><span style="color:#B392F0;">blob</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> myBlob2</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response2.</span><span style="color:#B392F0;">blob</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">image1.src </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> URL</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">createObjectURL</span><span style="color:#E1E4E8;">(myBlob1);</span></span>
<span class="line"><span style="color:#E1E4E8;">image2.src </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> URL</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">createObjectURL</span><span style="color:#E1E4E8;">(myBlob2);</span></span></code></pre></div><p>上面示例中，<code>response.clone()</code> 复制了一份 Response 对象，然后将同一张图片读取了两次。</p><p>Response 对象还有一个 <code>Response.redirect()</code> 方法，用于将 Response 结果重定向到指定的 URL。该方法一般只用在 Service Worker 里面，这里就不介绍了。</p><h3 id="response-body-属性" tabindex="-1">Response.body 属性 <a class="header-anchor" href="#response-body-属性" aria-label="Permalink to &quot;Response.body 属性&quot;">​</a></h3><p><code>Response.body</code> 属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作。</p><p>它可以用来分块读取内容，应用之一就是显示下载的进度。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;flower.jpg&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> reader</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> response.body.</span><span style="color:#B392F0;">getReader</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">while</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#E1E4E8;"> {</span><span style="color:#79B8FF;">done</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">value</span><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> reader.</span><span style="color:#B392F0;">read</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (done) {</span></span>
<span class="line"><span style="color:#F97583;">    break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`Received \${</span><span style="color:#E1E4E8;">value</span><span style="color:#9ECBFF;">.</span><span style="color:#79B8FF;">length</span><span style="color:#9ECBFF;">} bytes\`</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>上面示例中，<code>response.body.getReader()</code> 方法返回一个遍历器。这个遍历器的 <code>read()</code> 方法每次返回一个对象，表示本次读取的内容块。</p><p>这个对象的 <code>done</code> 属性是一个布尔值，用来判断有没有读完；<code>value</code> 属性是一个 arrayBuffer 数组，表示内容块的内容，而 <code>value.length</code> 属性是当前块的大小。</p><h2 id="fetch-的第二个参数-定制-http-请求" tabindex="-1"><code>fetch()</code> 的第二个参数：定制 HTTP 请求 <a class="header-anchor" href="#fetch-的第二个参数-定制-http-请求" aria-label="Permalink to &quot;\`fetch()\` 的第二个参数：定制 HTTP 请求&quot;">​</a></h2><p><code>fetch()</code> 的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(url, optionObj)</span></span></code></pre></div><p>上面命令的 <code>optionObj</code> 就是第二个参数。</p><p>HTTP 请求的方法、标头、数据体都在这个对象里面设置。下面是一些示例。</p><p><strong>(1) POST 请求</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(url, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  method: </span><span style="color:#9ECBFF;">&#39;POST&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="color:#9ECBFF;">    &quot;Content-type&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  body: </span><span style="color:#9ECBFF;">&#39;foo=bar&amp;lorem=ipsum&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> json</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">();</span></span></code></pre></div><p>上面示例中，配置对象用到了三个属性。</p><blockquote><ul><li><code>method</code>：HTTP 请求的方法，<code>POST</code>、<code>DELETE</code>、<code>PUT</code> 都在这个属性设置。</li><li><code>headers</code>：一个对象，用来定制 HTTP 请求的标头。</li><li><code>body</code>：POST 请求的数据体。</li></ul></blockquote><p>注意，有些标头不能通过 <code>headers</code> 属性设置，比如 <code>Content-Length</code>、<code>Cookie</code>、<code>Host</code> 等等。它们是由浏览器自动生成，无法修改。</p><p><strong>(2) 提交 JSON 数据</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> user</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;">  { name:  </span><span style="color:#9ECBFF;">&#39;John&#39;</span><span style="color:#E1E4E8;">, surname:  </span><span style="color:#9ECBFF;">&#39;Smith&#39;</span><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/article/fetch/post/user&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  method: </span><span style="color:#9ECBFF;">&#39;POST&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="color:#9ECBFF;">   &#39;Content-Type&#39;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&#39;application/json;charset=utf-8&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }, </span></span>
<span class="line"><span style="color:#E1E4E8;">  body: </span><span style="color:#79B8FF;">JSON</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">stringify</span><span style="color:#E1E4E8;">(user) </span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p>上面示例中，标头 <code>Content-Type</code> 要设成 <code>&#39;application/json;charset=utf-8&#39;</code>。因为默认发送的是纯文本，<code>Content-Type</code> 的默认值是 <code>&#39;text/plain;charset=UTF-8&#39;</code>。</p><p><strong>(3) 提交表单</strong></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> form</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">querySelector</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;form&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/users&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  method: </span><span style="color:#9ECBFF;">&#39;POST&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  body: </span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> FormData</span><span style="color:#E1E4E8;">(form)</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p><strong>(4) 文件上传</strong></p><p>如果表单里面有文件选择器，可以用前一个例子的写法，上传的文件包含在整个表单里面，一起提交。</p><p>另一种方法是用脚本添加文件，构造出一个表单，进行上传，请看下面的例子。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> input</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">querySelector</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;input[type=&quot;file&quot;]&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> data</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> FormData</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">data.</span><span style="color:#B392F0;">append</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;file&#39;</span><span style="color:#E1E4E8;">, input.files[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]);</span></span>
<span class="line"><span style="color:#E1E4E8;">data.</span><span style="color:#B392F0;">append</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;user&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/avatars&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  method: </span><span style="color:#9ECBFF;">&#39;POST&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  body: data</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p>上传二进制文件时，不用修改标头的 <code>Content-Type</code>，浏览器会自动设置。</p><p><strong>(5) 直接上传二进制数据</strong></p><p><code>fetch()</code> 也可以直接上传二进制数据，将 Blob 或 arrayBuffer 数据放在 <code>body</code> 属性里面。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> blob </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#F97583;"> new</span><span style="color:#79B8FF;"> Promise</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">resolve</span><span style="color:#F97583;"> =&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  canvasElem.</span><span style="color:#B392F0;">toBlob</span><span style="color:#E1E4E8;">(resolve,  </span><span style="color:#9ECBFF;">&#39;image/png&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> response </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/article/fetch/post/image&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  method:  </span><span style="color:#9ECBFF;">&#39;POST&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  body: blob</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h2 id="fetch-配置对象的完整-api" tabindex="-1"><code>fetch()</code> 配置对象的完整 API <a class="header-anchor" href="#fetch-配置对象的完整-api" aria-label="Permalink to &quot;\`fetch()\` 配置对象的完整 API&quot;">​</a></h2><p><code>fetch()</code> 第二个参数的完整 API 如下。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(url, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  method: </span><span style="color:#9ECBFF;">&quot;GET&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  headers: {</span></span>
<span class="line"><span style="color:#9ECBFF;">    &quot;Content-Type&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;text/plain;charset=UTF-8&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  body: </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  referrer: </span><span style="color:#9ECBFF;">&quot;about:client&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  referrerPolicy: </span><span style="color:#9ECBFF;">&quot;no-referrer-when-downgrade&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  mode: </span><span style="color:#9ECBFF;">&quot;cors&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  credentials: </span><span style="color:#9ECBFF;">&quot;same-origin&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  cache: </span><span style="color:#9ECBFF;">&quot;default&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  redirect: </span><span style="color:#9ECBFF;">&quot;follow&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  integrity: </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  keepalive: </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  signal: </span><span style="color:#79B8FF;">undefined</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p><code>fetch()</code> 请求的底层用的是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request" target="_blank" rel="noreferrer">Request() 对象</a>的接口，参数完全一样，因此上面的 API 也是 <code>Request()</code> 的 API。</p><p>这些属性里面，<code>headers</code>、<code>body</code>、<code>method</code> 前面已经给过示例了，下面是其他属性的介绍。</p><p><strong>cache</strong></p><p><code>cache</code> 属性指定如何处理缓存。可能的取值如下：</p><ul><li><code>default</code>：默认值，先在缓存里面寻找匹配的请求。</li><li><code>no-store</code>：直接请求远程服务器，并且不更新缓存。</li><li><code>reload</code>：直接请求远程服务器，并且更新缓存。</li><li><code>no-cache</code>：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存。</li><li><code>force-cache</code>：缓存优先，只有不存在缓存的情况下，才请求远程服务器。</li><li><code>only-if-cached</code>：只检查缓存，如果缓存里面不存在，将返回 504 错误。</li></ul><p><strong>mode</strong></p><p><code>mode</code> 属性指定请求的模式。可能的取值如下：</p><ul><li><code>cors</code>：默认值，允许跨源请求。</li><li><code>same-origin</code>：只允许同源请求。</li><li><code>no-cors</code>：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨源的复杂标头，相当于提交表单、<code>&lt;script&gt;</code> 加载脚本、<code>&lt;img&gt;</code> 加载图片等传统的跨源请求方法。</li></ul><p><strong>credentials</strong></p><p><code>credentials</code> 属性指定是否发送 Cookie。可能的取值如下：</p><ul><li><code>same-origin</code>：默认值，同源请求时发送 Cookie，跨源请求时不发送。</li><li><code>include</code>：不管同源请求，还是跨源请求，一律发送 Cookie。</li><li><code>omit</code>：一律不发送。</li></ul><p>跨源请求发送 Cookie，需要将 <code>credentials</code> 属性设为 <code>include</code>。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;http://another.com&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  credentials: </span><span style="color:#9ECBFF;">&quot;include&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p><strong>signal</strong></p><p><code>signal</code> 属性指定一个 AbortSignal 实例，用于取消 <code>fetch()</code> 请求，详见下一节。</p><p><strong>keepalive</strong></p><p><code>keepalive</code> 属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。</p><p>一个典型的场景就是，用户离开网页时，脚本向服务器提交一些用户行为的统计信息。这时，如果不用 <code>keepalive</code> 属性，数据可能无法发送，因为浏览器已经把页面卸载了。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">window.</span><span style="color:#B392F0;">onunload</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#B392F0;">  fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/analytics&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">    method: </span><span style="color:#9ECBFF;">&#39;POST&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    headers: {</span></span>
<span class="line"><span style="color:#9ECBFF;">      &#39;Content-Type&#39;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&#39;application/json&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">    body: </span><span style="color:#79B8FF;">JSON</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">stringify</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">      some: </span><span style="color:#9ECBFF;">&#39;data&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }),</span></span>
<span class="line"><span style="color:#E1E4E8;">    keepalive: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><p><strong>redirect</strong></p><p><code>redirect</code> 属性指定 HTTP 跳转的处理方法。可能的取值如下：</p><ul><li><code>follow</code>：默认值，<code>fetch()</code> 跟随 HTTP 跳转。</li><li><code>error</code>：如果发生跳转，<code>fetch()</code> 就报错。</li><li><code>manual</code>：<code>fetch()</code> 不跟随 HTTP 跳转，但是 <code>response.url</code> 属性会指向新的 URL，<code>response.redirected</code> 属性会变为 <code>true</code>，由开发者自己决定后续如何处理跳转。</li></ul><p><strong>integrity</strong></p><p><code>integrity</code> 属性指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。</p><p>比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;http://site.com/file&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  integrity: </span><span style="color:#9ECBFF;">&#39;sha256-abcdef&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p><strong>referrer</strong></p><p><code>referrer</code> 属性用于设定 <code>fetch()</code> 请求的 <code>referer</code> 标头。</p><p>这个属性可以为任意字符串，也可以设为空字符串 (即不发送 <code>referer</code> 标头)。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/page&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  referrer: </span><span style="color:#9ECBFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p><strong>referrerPolicy</strong></p><p><code>referrerPolicy</code> 属性用于设定 <code>Referer</code> 标头的规则。可能的取值如下：</p><ul><li><code>no-referrer-when-downgrade</code>：默认值，总是发送 <code>Referer</code> 标头，除非从 HTTPS 页面请求 HTTP 资源时不发送。</li><li><code>no-referrer</code>：不发送 <code>Referer</code> 标头。</li><li><code>origin</code>：<code>Referer</code> 标头只包含域名，不包含完整的路径。</li><li><code>origin-when-cross-origin</code>：同源请求 <code>Referer</code> 标头包含完整的路径，跨源请求只包含域名。</li><li><code>same-origin</code>：跨源请求不发送 <code>Referer</code>，同源请求发送。</li><li><code>strict-origin</code>：<code>Referer</code> 标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送 <code>Referer</code> 标头。</li><li><code>strict-origin-when-cross-origin</code>：同源请求时 <code>Referer</code> 标头包含完整路径，跨源请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头。</li><li><code>unsafe-url</code>：不管什么情况，总是发送 <code>Referer</code> 标头。</li></ul><h2 id="取消-fetch-请求" tabindex="-1">取消 <code>fetch()</code> 请求 <a class="header-anchor" href="#取消-fetch-请求" aria-label="Permalink to &quot;取消 \`fetch()\` 请求&quot;">​</a></h2><p><code>fetch()</code> 请求发送以后，如果中途想要取消，需要使用 <code>AbortController</code> 对象。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> controller </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> AbortController</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> signal </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> controller.signal;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(url, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  signal: controller.signal</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">signal.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;abort&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;abort!&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">controller.</span><span style="color:#B392F0;">abort</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 取消</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(signal.aborted); </span><span style="color:#6A737D;">// true</span></span></code></pre></div><p>上面示例中，首先新建 AbortController 实例，然后发送 <code>fetch()</code> 请求，配置对象的 <code>signal</code> 属性必须指定接收 AbortController 实例发送的信号 <code>controller.signal</code>。</p><p><code>controller.abort()</code> 方法用于发出取消信号。这时会触发 <code>abort</code> 事件，这个事件可以监听，也可以通过 <code>controller.signal.aborted</code> 属性判断取消信号是否已经发出。</p><p>下面是一个1秒后自动取消请求的例子。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> controller </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> AbortController</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> controller.</span><span style="color:#B392F0;">abort</span><span style="color:#E1E4E8;">(), </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> response </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/long-operation&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">    signal: controller.signal</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;">(err) {</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (err.name </span><span style="color:#F97583;">==</span><span style="color:#9ECBFF;"> &#39;AbortError&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Aborted!&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    throw</span><span style="color:#E1E4E8;"> err;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://javascript.info/fetch" target="_blank" rel="noreferrer">Network requests: Fetch</a></li><li><a href="https://github.com/node-fetch/node-fetch" target="_blank" rel="noreferrer">node-fetch</a></li><li><a href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch" target="_blank" rel="noreferrer">Introduction to fetch()</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noreferrer">Using Fetch</a></li><li><a href="https://developerhowto.com/2019/09/14/javascript-fetch-api/" target="_blank" rel="noreferrer">Javascript Fetch API: The XMLHttpRequest evolution</a></li><li><a href="https://www.sitepen.com/blog/2017/10/02/a-guide-to-faster-web-app-io-and-data-operations-with-streams/" target="_blank" rel="noreferrer">A Guide to Faster Web App I/O and Data Operations with Streams</a></li></ul>`,161)])])}const F=a(p,[["render",l]]);export{d as __pageData,F as default};
