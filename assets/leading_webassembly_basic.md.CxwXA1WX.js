import{_ as s,c as n,o as l,b as e}from"./chunks/framework.CMLuPXeo.js";const b=JSON.parse('{"title":"WASM 基础","description":"","frontmatter":{},"headers":[{"level":2,"title":"什么是 WebAssembly？","slug":"什么是-webassembly","link":"#什么是-webassembly","children":[]},{"level":2,"title":"主要特点","slug":"主要特点","link":"#主要特点","children":[{"level":3,"title":"高效性能","slug":"高效性能","link":"#高效性能","children":[]},{"level":3,"title":"安全沙箱","slug":"安全沙箱","link":"#安全沙箱","children":[]},{"level":3,"title":"跨平台可移植","slug":"跨平台可移植","link":"#跨平台可移植","children":[]},{"level":3,"title":"与 JavaScript 互操作","slug":"与-javascript-互操作","link":"#与-javascript-互操作","children":[]}]},{"level":2,"title":"工作原理","slug":"工作原理","link":"#工作原理","children":[{"level":3,"title":"编译与模块结构","slug":"编译与模块结构","link":"#编译与模块结构","children":[]},{"level":3,"title":"加载与执行","slug":"加载与执行","link":"#加载与执行","children":[]},{"level":3,"title":"内存管理","slug":"内存管理","link":"#内存管理","children":[]}]},{"level":2,"title":"使用示例","slug":"使用示例","link":"#使用示例","children":[]},{"level":2,"title":"工具链与生态","slug":"工具链与生态","link":"#工具链与生态","children":[]},{"level":2,"title":"优势与局限","slug":"优势与局限","link":"#优势与局限","children":[{"level":3,"title":"优势","slug":"优势","link":"#优势","children":[]},{"level":3,"title":"局限","slug":"局限","link":"#局限","children":[]}]}],"relativePath":"leading/webassembly/basic.md","filePath":"leading/webassembly/basic.md"}'),p={name:"leading/webassembly/basic.md"};function t(i,a,o,c,r,d){return l(),n("div",null,[...a[0]||(a[0]=[e(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /leading/webassembly/basic.md for this page in Markdown format</div><h1 id="wasm-基础" tabindex="-1">WASM 基础 <a class="header-anchor" href="#wasm-基础" aria-label="Permalink to &quot;WASM 基础&quot;">​</a></h1><h2 id="什么是-webassembly" tabindex="-1">什么是 WebAssembly？ <a class="header-anchor" href="#什么是-webassembly" aria-label="Permalink to &quot;什么是 WebAssembly？&quot;">​</a></h2><p>WebAssembly (简称 WASM) 是一种低级字节码格式，专为在 Web 环境中高效执行而设计。它由 W3C 标准组织推动，旨在弥补 JavaScript 在性能密集型任务上的不足，同时保持与现有 Web 平台的兼容性。WASM 不是一门编程语言，而是一种编译目标，允许开发者使用 C/C++、Rust 等语言编写代码，并将其转换为可在浏览器中运行的紧凑二进制格式。</p><h2 id="主要特点" tabindex="-1">主要特点 <a class="header-anchor" href="#主要特点" aria-label="Permalink to &quot;主要特点&quot;">​</a></h2><h3 id="高效性能" tabindex="-1">高效性能 <a class="header-anchor" href="#高效性能" aria-label="Permalink to &quot;高效性能&quot;">​</a></h3><p>WASM 采用紧凑的二进制格式，加载和解析速度快于等效的 JavaScript 文本。其指令集设计贴近硬件，支持即时编译 (JIT) 和预编译，执行效率接近原生代码。例如，在数值计算或图形处理任务中，WASM 可显著提升性能。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>源代码 (C/Rust) -&gt; 编译器 -&gt; WASM 二进制 -&gt; 浏览器 JIT 编译 -&gt; 原生机器码执行</span></span></code></pre></div><h3 id="安全沙箱" tabindex="-1">安全沙箱 <a class="header-anchor" href="#安全沙箱" aria-label="Permalink to &quot;安全沙箱&quot;">​</a></h3><p>WASM 运行在严格的沙箱环境中，无法直接访问系统资源 (如文件系统或网络)。所有内存访问均通过线性内存模型进行隔离，并通过导入/导出机制与外部交互，防止恶意代码破坏宿主环境。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>[ WASM 实例 ]</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    |--- 线性内存 (受限访问)</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    |--- 导入函数 (例如 JavaScript API)</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    |--- 导出函数 (供外部调用)</span></span></code></pre></div><h3 id="跨平台可移植" tabindex="-1">跨平台可移植 <a class="header-anchor" href="#跨平台可移植" aria-label="Permalink to &quot;跨平台可移植&quot;">​</a></h3><p>WASM 独立于特定硬件或操作系统，只需目标环境 (如浏览器、服务器) 具备 WASM 虚拟机即可运行。这使得同一份代码可部署在 Web、边缘计算或物联网设备中。</p><h3 id="与-javascript-互操作" tabindex="-1">与 JavaScript 互操作 <a class="header-anchor" href="#与-javascript-互操作" aria-label="Permalink to &quot;与 JavaScript 互操作&quot;">​</a></h3><p>WASM 与 JavaScript 无缝集成，可通过 JavaScript API 加载和实例化模块，并双向调用函数。这允许渐进式迁移：性能关键部分用 WASM 实现，其余逻辑保留在 JavaScript 中。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>JavaScript 代码</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    |-- 调用 --&gt; WASM 导出函数</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    |-- 传递数据 --&gt; 共享内存</span></span></code></pre></div><h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h2><h3 id="编译与模块结构" tabindex="-1">编译与模块结构 <a class="header-anchor" href="#编译与模块结构" aria-label="Permalink to &quot;编译与模块结构&quot;">​</a></h3><p>源代码 (如 C++) 通过编译器 (如 Emscripten) 转换为。wasm 二进制文件。该文件包含模块定义，由以下部分组成：</p><ul><li><strong>类型段</strong>：定义函数签名。</li><li><strong>函数段</strong>：包含代码逻辑。</li><li><strong>内存段</strong>：描述线性内存布局。</li><li><strong>导入/导出段</strong>：声明依赖项和公开接口。</li></ul><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>C++ 文件</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    emcc 编译</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>WASM 模块结构：</span></span>
<span class="line"><span>    [类型段] [函数段] [内存段] [导入段] [导出段]</span></span></code></pre></div><h3 id="加载与执行" tabindex="-1">加载与执行 <a class="header-anchor" href="#加载与执行" aria-label="Permalink to &quot;加载与执行&quot;">​</a></h3><p>浏览器通过 JavaScript API 加载。wasm 文件，验证其安全性后实例化模块。实例化后，WASM 函数可通过 JavaScript 调用，并通过线性内存交换数据。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>浏览器</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    |--- 下载 .wasm 文件</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    |--- 验证模块完整性</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    |--- 实例化：创建内存和函数表</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    |--- 调用导出函数</span></span></code></pre></div><h3 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h3><p>WASM 使用连续的线性内存空间，初始大小可配置，并可动态增长。JavaScript 可通过 <code>WebAssembly.Memory</code> 对象与之交互，实现高效数据共享 (如数组缓冲区)。</p><p>示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>线性内存布局：</span></span>
<span class="line"><span>[0x0000: 数据段]</span></span>
<span class="line"><span>[0x1000: 堆栈]</span></span>
<span class="line"><span>[0x2000: 动态分配区]</span></span></code></pre></div><h2 id="使用示例" tabindex="-1">使用示例 <a class="header-anchor" href="#使用示例" aria-label="Permalink to &quot;使用示例&quot;">​</a></h2><p>以下是一个简单加法函数的实现流程，使用 C 代码编译为 WASM：</p><ol><li><strong>编写 C 代码</strong> (add.c)：</li></ol><div class="language-c"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#B392F0;"> add</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#FFAB70;"> a</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#FFAB70;"> b</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li><strong>编译为 WASM</strong>：</li></ol><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">emcc</span><span style="color:#9ECBFF;"> add.c</span><span style="color:#79B8FF;"> -O3</span><span style="color:#79B8FF;"> -o</span><span style="color:#9ECBFF;"> add.wasm</span></span></code></pre></div><ol start="3"><li><strong>在 JavaScript 中加载并调用</strong>：</li></ol><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">WebAssembly.</span><span style="color:#B392F0;">instantiateStreaming</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;add.wasm&#39;</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">obj</span><span style="color:#F97583;"> =&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(obj.instance.exports.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">)); </span><span style="color:#6A737D;">// 输出 5</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span></code></pre></div><h2 id="工具链与生态" tabindex="-1">工具链与生态 <a class="header-anchor" href="#工具链与生态" aria-label="Permalink to &quot;工具链与生态&quot;">​</a></h2><ul><li><strong>编译器</strong>：Emscripten (C/C++)、Rust WASM-pack (Rust)。</li><li><strong>调试工具</strong>：浏览器开发者工具支持 WASM 单步调试。</li><li><strong>运行时</strong>：除浏览器外，Node.js 和 WASM 专用运行时 (如 Wasmtime) 支持服务端执行。</li></ul><h2 id="优势与局限" tabindex="-1">优势与局限 <a class="header-anchor" href="#优势与局限" aria-label="Permalink to &quot;优势与局限&quot;">​</a></h2><h3 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h3><ul><li><strong>高性能</strong>：适用于游戏、音视频处理等计算密集型场景。</li><li><strong>语言多样性</strong>：支持多语言开发，复用现有代码库。</li><li><strong>标准化</strong>：W3C 标准确保长期兼容性。</li></ul><h3 id="局限" tabindex="-1">局限 <a class="header-anchor" href="#局限" aria-label="Permalink to &quot;局限&quot;">​</a></h3><ul><li><strong>DOM 访问限制</strong>：需通过 JavaScript 胶水代码操作 DOM。</li><li><strong>工具链复杂度</strong>：需配置编译环境，调试体验待完善。</li></ul>`,48)])])}const u=s(p,[["render",t]]);export{b as __pageData,u as default};
