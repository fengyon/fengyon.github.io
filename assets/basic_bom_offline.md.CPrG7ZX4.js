import{_ as s,c as n,o as e,b as o}from"./chunks/framework.CMLuPXeo.js";const y=JSON.parse('{"title":"Offline 应用","description":"","frontmatter":{},"headers":[],"relativePath":"basic/bom/offline.md","filePath":"basic/bom/offline.md"}'),l={name:"basic/bom/offline.md"};function p(t,a,c,i,d,r){return e(),n("div",null,[...a[0]||(a[0]=[o(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /basic/bom/offline.md for this page in Markdown format</div><h1 id="offline-应用" tabindex="-1">Offline 应用 <a class="header-anchor" href="#offline-应用" aria-label="Permalink to &quot;Offline 应用&quot;">​</a></h1><p>Web 应用不仅可以在浏览器缓存资源文件 (HTML、CSS、JS 脚本、图片等)，还可以把应用本身储存到浏览器。</p><p>缓存的资源文件必须在线使用，只有先从服务器加载网页，然后才能使用本地缓存；但是，应用一旦储存，就可以离线使用。另外，用户常规性地清除浏览器缓存，并不会清除储存的应用，除非用户显式地卸载或删除它们。</p><p>为了开启离线储存，必须创建一个 manifest 文件。该文件列出了所有需要储存的文件。</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">CACHE MANIFEST</span></span>
<span class="line"><span style="color:#E1E4E8;">myapp.html</span></span>
<span class="line"><span style="color:#E1E4E8;">myapp.js</span></span>
<span class="line"><span style="color:#E1E4E8;">myapp.css</span></span>
<span class="line"><span style="color:#E1E4E8;">images/background.png</span></span></code></pre></div><p>Manifest 文件的第一行必须是 <code>CACHE MANIFEST</code>。然后，每一行列出一个需要储存的文件，它们的位置都是相对于 Manifest 文件的位置。空行会被忽略，以 <code>#</code> 开头的行是注释，也会被忽略。</p><p>这个文件的后缀名一般是 <code>.appcache</code>。它的 MIME 类型必须是 <code>text/cache-manifest</code>，如果服务器将其设为其他类型，就不会被浏览器缓存。</p><p>编写完这个文件以后，要将 <code>&lt;html&gt;</code> 元素的 <code>manifest</code> 属性指向它。浏览器加载这个网页的时候，就会读取这个 Manifest 文件，离线储存这个网页和相关的资源。</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;!</span><span style="color:#85E89D;">DOCTYPE</span><span style="color:#B392F0;"> HTML</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">html</span><span style="color:#B392F0;"> manifest</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;myapp.appcache&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">head</span><span style="color:#E1E4E8;">&gt;...&lt;/</span><span style="color:#85E89D;">head</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">body</span><span style="color:#E1E4E8;">&gt;...&lt;/</span><span style="color:#85E89D;">body</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">html</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>如果一个 Web 应用有多个网页需要离线储存，那么每个网页都应该将 <code>manifest</code> 属性指向这个文件。一旦被储存，以后加载该网页的时候，就会从缓存里面加载。这时，只有 Manifest 文件里面列出的文件会被加载，其他文件不会。如果这时浏览器在线，浏览器就会去检查 Manifest 文件是否有新版本，如果有新版本，就会重新储存和更新该文件列出的资源。最方便的办法是在 Manifest 文件里面用注释列出版本号。</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">CACHE MANIFEST</span></span>
<span class="line"><span style="color:#E1E4E8;"># MyApp version 1</span></span>
<span class="line"><span style="color:#E1E4E8;">MyApp.html</span></span>
<span class="line"><span style="color:#E1E4E8;">MyApp.js</span></span></code></pre></div><p>如果需要删除离线储存，只要删除 Manifest 文件，让其返回 404 状态码即可。</p><p>离线储存更新完成，会触发浏览器的 <code>updateready</code> 事件，可以对这个事件指定监听函数。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">window.applicationCache.</span><span style="color:#B392F0;">onupdateready</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  var</span><span style="color:#E1E4E8;"> reload </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> confirm</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;新版本下载完成。是否需要重新加载？&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (reload) location.</span><span style="color:#B392F0;">reload</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>脚本可以注册 <code>online</code> 和 <code>offline</code> 事件的监听函数，通过 <code>navigator.onLine</code> 属性，判断浏览器是否在线从而进行数据同步。</p><p>每次浏览器加载一个具有 <code>manifest</code> 属性的网页，浏览器就会触发一个 <code>checking</code> 事件，然后去加载 Manifest 文件。</p><ul><li>如果应用已经储存，并且 Manifest 文件没有变化，那么触发 <code>noupdate</code> 事件。</li><li>如果应用已经储存，并且 Manifest 文件有变化，那么触发 <code>downloading</code> 事件，浏览器重新下载所有离线资源。下载过程中，触发 <code>progress</code> 事件，下载结束触发 <code>updateready</code> 事件。</li><li>如果应用没有储存，下载结束将触发 <code>cached</code> 事件。</li><li>如果离线，无法检查 Manifest 文件，浏览器会触发一个 <code>error</code> 事件。</li><li>如果浏览器在线，而且应用已经储存，但是 Manifest 文件返回 404，浏览器触发 <code>obsolete</code> 事件，将储存的应用移除。</li></ul><p>所有这些事件都是可以取消的。监听函数可以返回 <code>false</code>，取消这些事件的默认动作。</p><p><code>applicationCache. status</code> 属性返回离线储存的状态。</p><ul><li>ApplicationCache.UNCACHED (0) This application does not have a manifest attribute: it is not cached.</li><li>ApplicationCache.IDLE (1) The manifest has been checked and this application is cached and up to date.</li><li>ApplicationCache.CHECKING (2) The browser is checking the manifest file.</li><li>ApplicationCache.DOWNLOADING (3) The browser is downloading and caching files listed in the manifest.</li><li>ApplicationCache.UPDATEREADY (4) A new version of the application has been downloaded and cached.</li><li>ApplicationCache.OBSOLETE (5) The manifest no longer exists and the cache will be deleted.</li></ul>`,21)])])}const h=s(l,[["render",p]]);export{y as __pageData,h as default};
