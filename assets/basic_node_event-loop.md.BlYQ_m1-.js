import{_ as a,c as n,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const F=JSON.parse('{"title":"node 事件循环","description":"","frontmatter":{},"headers":[{"level":2,"title":"事件循环基本概念","slug":"事件循环基本概念","link":"#事件循环基本概念","children":[]},{"level":2,"title":"事件循环阶段","slug":"事件循环阶段","link":"#事件循环阶段","children":[{"level":3,"title":"定时器阶段 (Timers)","slug":"定时器阶段-timers","link":"#定时器阶段-timers","children":[]},{"level":3,"title":"待定回调阶段 (Pending Callbacks)","slug":"待定回调阶段-pending-callbacks","link":"#待定回调阶段-pending-callbacks","children":[]},{"level":3,"title":"空闲/准备阶段 (Idle，Prepare)","slug":"空闲-准备阶段-idle-prepare","link":"#空闲-准备阶段-idle-prepare","children":[]},{"level":3,"title":"轮询阶段 (Poll)","slug":"轮询阶段-poll","link":"#轮询阶段-poll","children":[]},{"level":3,"title":"检查阶段 (Check)","slug":"检查阶段-check","link":"#检查阶段-check","children":[]},{"level":3,"title":"关闭事件回调阶段 (Close Callbacks)","slug":"关闭事件回调阶段-close-callbacks","link":"#关闭事件回调阶段-close-callbacks","children":[]}]},{"level":2,"title":"微任务队列","slug":"微任务队列","link":"#微任务队列","children":[{"level":3,"title":"Promise 回调","slug":"promise-回调","link":"#promise-回调","children":[]},{"level":3,"title":"process.nextTick","slug":"process-nexttick","link":"#process-nexttick","children":[]}]},{"level":2,"title":"事件循环执行顺序","slug":"事件循环执行顺序","link":"#事件循环执行顺序","children":[]},{"level":2,"title":"事件循环与异步 I/O","slug":"事件循环与异步-i-o","link":"#事件循环与异步-i-o","children":[{"level":3,"title":"文件 I/O 操作","slug":"文件-i-o-操作","link":"#文件-i-o-操作","children":[]},{"level":3,"title":"网络 I/O 操作","slug":"网络-i-o-操作","link":"#网络-i-o-操作","children":[]}]},{"level":2,"title":"事件循环性能特征","slug":"事件循环性能特征","link":"#事件循环性能特征","children":[{"level":3,"title":"CPU 密集型任务的影响","slug":"cpu-密集型任务的影响","link":"#cpu-密集型任务的影响","children":[]},{"level":3,"title":"非阻塞模式的最佳实践","slug":"非阻塞模式的最佳实践","link":"#非阻塞模式的最佳实践","children":[]}]},{"level":2,"title":"事件循环与集群","slug":"事件循环与集群","link":"#事件循环与集群","children":[]},{"level":2,"title":"事件循环监控与调试","slug":"事件循环监控与调试","link":"#事件循环监控与调试","children":[{"level":3,"title":"监控事件循环延迟","slug":"监控事件循环延迟","link":"#监控事件循环延迟","children":[]},{"level":3,"title":"检测事件循环阻塞","slug":"检测事件循环阻塞","link":"#检测事件循环阻塞","children":[]}]},{"level":2,"title":"事件循环最佳实践","slug":"事件循环最佳实践","link":"#事件循环最佳实践","children":[{"level":3,"title":"避免阻塞操作","slug":"避免阻塞操作","link":"#避免阻塞操作","children":[]},{"level":3,"title":"合理使用异步模式","slug":"合理使用异步模式","link":"#合理使用异步模式","children":[]},{"level":3,"title":"合理设置定时器","slug":"合理设置定时器","link":"#合理设置定时器","children":[]}]}],"relativePath":"basic/node/event-loop.md","filePath":"basic/node/event-loop.md"}'),o={name:"basic/node/event-loop.md"};function e(c,s,t,r,E,i){return l(),n("div",null,[...s[0]||(s[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /basic/node/event-loop.md for this page in Markdown format</div><h1 id="node-事件循环" tabindex="-1">node 事件循环 <a class="header-anchor" href="#node-事件循环" aria-label="Permalink to &quot;node 事件循环&quot;">​</a></h1><p>Node.js 事件循环是其非阻塞 I/O 模型的核心机制，它允许 Node.js 在单线程中高效处理大量并发操作。事件循环是一个持续运行的进程，负责协调和执行 JavaScript 代码、处理回调函数和管理异步操作。理解事件循环对于编写高性能的 Node.js 应用至关重要。</p><h2 id="事件循环基本概念" tabindex="-1">事件循环基本概念 <a class="header-anchor" href="#事件循环基本概念" aria-label="Permalink to &quot;事件循环基本概念&quot;">​</a></h2><p>事件循环是 Node.js 实现非阻塞 I/O 的基础，它通过不断地检查和处理事件队列中的任务来实现并发。与传统的多线程模型不同，Node.js 使用单线程配合事件循环来处理多个并发连接。</p><p>基本工作原理示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>事件循环流程:</span></span>
<span class="line"><span>  开始 → 检查定时器 → 处理I/O回调 → 准备阶段 → 轮询新I/O → 检查阶段 → 关闭回调 → 循环</span></span></code></pre></div><h2 id="事件循环阶段" tabindex="-1">事件循环阶段 <a class="header-anchor" href="#事件循环阶段" aria-label="Permalink to &quot;事件循环阶段&quot;">​</a></h2><p>Node.js 事件循环分为六个主要阶段，每个阶段都有特定的任务队列：</p><h3 id="定时器阶段-timers" tabindex="-1">定时器阶段 (Timers) <a class="header-anchor" href="#定时器阶段-timers" aria-label="Permalink to &quot;定时器阶段 (Timers)&quot;">​</a></h3><p>此阶段执行 <code>setTimeout()</code> 和 <code>setInterval()</code> 的回调函数。事件循环检查定时器队列，执行所有到达设定时间的回调。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 定时器示例</span></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;定时器回调执行&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">setImmediate</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Immediate 回调执行&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p>执行顺序示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>定时器阶段:</span></span>
<span class="line"><span>  检查定时器队列 → 执行到期回调 → 进入下一阶段</span></span></code></pre></div><h3 id="待定回调阶段-pending-callbacks" tabindex="-1">待定回调阶段 (Pending Callbacks) <a class="header-anchor" href="#待定回调阶段-pending-callbacks" aria-label="Permalink to &quot;待定回调阶段 (Pending Callbacks)&quot;">​</a></h3><p>此阶段执行某些系统操作的回调，如 TCP 错误处理等操作系统相关的回调。</p><h3 id="空闲-准备阶段-idle-prepare" tabindex="-1">空闲/准备阶段 (Idle，Prepare) <a class="header-anchor" href="#空闲-准备阶段-idle-prepare" aria-label="Permalink to &quot;空闲/准备阶段 (Idle，Prepare)&quot;">​</a></h3><p>内部使用的阶段，为轮询阶段做准备。</p><h3 id="轮询阶段-poll" tabindex="-1">轮询阶段 (Poll) <a class="header-anchor" href="#轮询阶段-poll" aria-label="Permalink to &quot;轮询阶段 (Poll)&quot;">​</a></h3><p>这是事件循环的核心阶段，主要职责是：</p><ul><li>计算应该阻塞和轮询 I/O 的时间</li><li>处理轮询队列中的事件</li><li>执行与文件系统、网络等 I/O 相关的回调</li></ul><p>轮询阶段工作机制：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>轮询阶段:</span></span>
<span class="line"><span>  如果轮询队列不为空 → 同步执行队列回调直到清空或达到上限</span></span>
<span class="line"><span>  如果轮询队列为空:</span></span>
<span class="line"><span>    如果有setImmediate回调 → 结束轮询，进入检查阶段</span></span>
<span class="line"><span>    如果没有setImmediate回调 → 等待新回调加入队列</span></span></code></pre></div><h3 id="检查阶段-check" tabindex="-1">检查阶段 (Check) <a class="header-anchor" href="#检查阶段-check" aria-label="Permalink to &quot;检查阶段 (Check)&quot;">​</a></h3><p>此阶段专门执行 <code>setImmediate()</code> 的回调函数。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// setImmediate 与 setTimeout 比较</span></span>
<span class="line"><span style="color:#B392F0;">setImmediate</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;setImmediate 回调&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;setTimeout 回调&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><h3 id="关闭事件回调阶段-close-callbacks" tabindex="-1">关闭事件回调阶段 (Close Callbacks) <a class="header-anchor" href="#关闭事件回调阶段-close-callbacks" aria-label="Permalink to &quot;关闭事件回调阶段 (Close Callbacks)&quot;">​</a></h3><p>执行一些关闭事件的回调，如 <code>socket.on(&#39;close&#39;, ...)</code>。</p><h2 id="微任务队列" tabindex="-1">微任务队列 <a class="header-anchor" href="#微任务队列" aria-label="Permalink to &quot;微任务队列&quot;">​</a></h2><p>除了事件循环的主要阶段，Node.js 还有微任务队列，包括：</p><h3 id="promise-回调" tabindex="-1">Promise 回调 <a class="header-anchor" href="#promise-回调" aria-label="Permalink to &quot;Promise 回调&quot;">​</a></h3><p>Promise 的 <code>.then()</code>、<code>.catch()</code> 和 <code>.finally()</code> 回调进入微任务队列。</p><h3 id="process-nexttick" tabindex="-1">process.nextTick <a class="header-anchor" href="#process-nexttick" aria-label="Permalink to &quot;process.nextTick&quot;">​</a></h3><p><code>process.nextTick()</code> 的回调具有最高优先级，在当前操作结束后立即执行。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 微任务执行顺序示例</span></span>
<span class="line"><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Promise 回调&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">process.</span><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;nextTick 回调&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;主线程执行&#39;</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>执行顺序示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>当前操作 → nextTick队列 → Promise队列 → 事件循环下一阶段</span></span></code></pre></div><h2 id="事件循环执行顺序" tabindex="-1">事件循环执行顺序 <a class="header-anchor" href="#事件循环执行顺序" aria-label="Permalink to &quot;事件循环执行顺序&quot;">​</a></h2><p>完整的事件循环执行顺序如下所示：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 事件循环阶段验证</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;开始&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;setTimeout&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">setImmediate</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;setImmediate&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Promise&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">process.</span><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;nextTick&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;结束&#39;</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>典型输出顺序：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>开始</span></span>
<span class="line"><span>结束</span></span>
<span class="line"><span>nextTick</span></span>
<span class="line"><span>Promise</span></span>
<span class="line"><span>setTimeout 或 setImmediate</span></span>
<span class="line"><span>setImmediate 或 setTimeout</span></span></code></pre></div><p>执行流程详细示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>主线程执行</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>nextTick 队列执行</span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>Promise 微任务队列执行  </span></span>
<span class="line"><span>  ↓</span></span>
<span class="line"><span>事件循环开始</span></span>
<span class="line"><span>  ↓ → 定时器阶段 → 待定回调 → 空闲准备 → 轮询阶段 → 检查阶段 → 关闭回调</span></span></code></pre></div><h2 id="事件循环与异步-i-o" tabindex="-1">事件循环与异步 I/O <a class="header-anchor" href="#事件循环与异步-i-o" aria-label="Permalink to &quot;事件循环与异步 I/O&quot;">​</a></h2><p>Node.js 通过事件循环和线程池实现非阻塞 I/O：</p><h3 id="文件-i-o-操作" tabindex="-1">文件 I/O 操作 <a class="header-anchor" href="#文件-i-o-操作" aria-label="Permalink to &quot;文件 I/O 操作&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> fs </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;fs&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;开始文件读取&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">fs.</span><span style="color:#B392F0;">readFile</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;example.txt&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;utf8&#39;</span><span style="color:#E1E4E8;">, (</span><span style="color:#FFAB70;">err</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;文件读取完成&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">setImmediate</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;setImmediate 回调&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;继续执行其他任务&#39;</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>执行流程：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>主线程: 开始文件读取 → 发起异步I/O → 继续执行其他任务</span></span>
<span class="line"><span>        ↓</span></span>
<span class="line"><span>      文件读取完成 → 回调加入轮询队列 → 事件循环处理回调</span></span></code></pre></div><h3 id="网络-i-o-操作" tabindex="-1">网络 I/O 操作 <a class="header-anchor" href="#网络-i-o-操作" aria-label="Permalink to &quot;网络 I/O 操作&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> http </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;http&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> server</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> http.</span><span style="color:#B392F0;">createServer</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">req</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">res</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;收到请求&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  res.</span><span style="color:#B392F0;">end</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Hello World&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">server.</span><span style="color:#B392F0;">listen</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3000</span><span style="color:#E1E4E8;">, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;服务器启动&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p>网络 I/O 处理示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>请求到达 → 加入待处理队列 → 轮询阶段处理 → 执行请求回调</span></span></code></pre></div><h2 id="事件循环性能特征" tabindex="-1">事件循环性能特征 <a class="header-anchor" href="#事件循环性能特征" aria-label="Permalink to &quot;事件循环性能特征&quot;">​</a></h2><h3 id="cpu-密集型任务的影响" tabindex="-1">CPU 密集型任务的影响 <a class="header-anchor" href="#cpu-密集型任务的影响" aria-label="Permalink to &quot;CPU 密集型任务的影响&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// CPU 密集型任务会阻塞事件循环</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> heavyComputation</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> result </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">  for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;"> 1000000000</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    result </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">sqrt</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#F97583;">  return</span><span style="color:#E1E4E8;"> result;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;开始计算&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#B392F0;">heavyComputation</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 这会阻塞事件循环</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;计算完成&#39;</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>阻塞问题示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>事件循环 → 遇到CPU密集型任务 → 主线程阻塞 → 其他任务等待</span></span></code></pre></div><h3 id="非阻塞模式的最佳实践" tabindex="-1">非阻塞模式的最佳实践 <a class="header-anchor" href="#非阻塞模式的最佳实践" aria-label="Permalink to &quot;非阻塞模式的最佳实践&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 使用 setImmediate 或 process.nextTick 分解任务</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> chunkedHeavyComputation</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">callback</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> result </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  function</span><span style="color:#B392F0;"> computeChunk</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> end</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">min</span><span style="color:#E1E4E8;">(i </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1000000</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1000000000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">    for</span><span style="color:#E1E4E8;"> (; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> end; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      result </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">sqrt</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;"> 1000000000</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#B392F0;">      setImmediate</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> computeChunk</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#B392F0;">      callback</span><span style="color:#E1E4E8;">(result);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#B392F0;">  computeChunk</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;开始分块计算&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#B392F0;">chunkedHeavyComputation</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">result</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;计算完成:&#39;</span><span style="color:#E1E4E8;">, result);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;继续处理其他任务&#39;</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>非阻塞处理示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>主线程 → 处理小块任务 → 让出控制权 → 事件循环处理其他任务 → 继续下一块任务</span></span></code></pre></div><h2 id="事件循环与集群" tabindex="-1">事件循环与集群 <a class="header-anchor" href="#事件循环与集群" aria-label="Permalink to &quot;事件循环与集群&quot;">​</a></h2><p>对于多核 CPU，可以使用集群模式充分利用系统资源：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> cluster </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;cluster&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> os </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;os&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cluster.isPrimary) {</span></span>
<span class="line"><span style="color:#6A737D;">  // 主进程 - 创建工作进程</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> numCPUs</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> os.</span><span style="color:#B392F0;">cpus</span><span style="color:#E1E4E8;">().</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`主进程 \${</span><span style="color:#E1E4E8;">process</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">pid</span><span style="color:#9ECBFF;">} 正在运行\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> numCPUs; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    cluster.</span><span style="color:#B392F0;">fork</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  cluster.</span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;exit&#39;</span><span style="color:#E1E4E8;">, (</span><span style="color:#FFAB70;">worker</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`工作进程 \${</span><span style="color:#E1E4E8;">worker</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">process</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">pid</span><span style="color:#9ECBFF;">} 已退出\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">  // 工作进程 - 共享同一个端口</span></span>
<span class="line"><span style="color:#F97583;">  import</span><span style="color:#E1E4E8;"> http </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;http&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  http.</span><span style="color:#B392F0;">createServer</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">req</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">res</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    res.</span><span style="color:#B392F0;">writeHead</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">200</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    res.</span><span style="color:#B392F0;">end</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`请求由进程 \${</span><span style="color:#E1E4E8;">process</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">pid</span><span style="color:#9ECBFF;">} 处理\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }).</span><span style="color:#B392F0;">listen</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3000</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`工作进程 \${</span><span style="color:#E1E4E8;">process</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">pid</span><span style="color:#9ECBFF;">} 已启动\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>集群架构示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>主进程 (负载均衡)</span></span>
<span class="line"><span>  ├── 工作进程1 (独立事件循环)</span></span>
<span class="line"><span>  ├── 工作进程2 (独立事件循环) </span></span>
<span class="line"><span>  ├── 工作进程3 (独立事件循环)</span></span>
<span class="line"><span>  └── 工作进程4 (独立事件循环)</span></span></code></pre></div><h2 id="事件循环监控与调试" tabindex="-1">事件循环监控与调试 <a class="header-anchor" href="#事件循环监控与调试" aria-label="Permalink to &quot;事件循环监控与调试&quot;">​</a></h2><h3 id="监控事件循环延迟" tabindex="-1">监控事件循环延迟 <a class="header-anchor" href="#监控事件循环延迟" aria-label="Permalink to &quot;监控事件循环延迟&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { monitorEventLoopDelay } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;perf_hooks&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> histogram</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> monitorEventLoopDelay</span><span style="color:#E1E4E8;">({ resolution: </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;"> });</span></span>
<span class="line"><span style="color:#E1E4E8;">histogram.</span><span style="color:#B392F0;">enable</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">setInterval</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`事件循环延迟:</span></span>
<span class="line"><span style="color:#9ECBFF;">    最小值: \${</span><span style="color:#E1E4E8;">histogram</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">min</span><span style="color:#F97583;"> /</span><span style="color:#79B8FF;"> 1000000</span><span style="color:#9ECBFF;">}ms</span></span>
<span class="line"><span style="color:#9ECBFF;">    最大值: \${</span><span style="color:#E1E4E8;">histogram</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">max</span><span style="color:#F97583;"> /</span><span style="color:#79B8FF;"> 1000000</span><span style="color:#9ECBFF;">}ms  </span></span>
<span class="line"><span style="color:#9ECBFF;">    平均值: \${</span><span style="color:#9ECBFF;">(</span><span style="color:#E1E4E8;">histogram</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">mean</span><span style="color:#F97583;"> /</span><span style="color:#79B8FF;"> 1000000</span><span style="color:#9ECBFF;">).</span><span style="color:#B392F0;">toFixed</span><span style="color:#9ECBFF;">(</span><span style="color:#79B8FF;">2</span><span style="color:#9ECBFF;">)</span><span style="color:#9ECBFF;">}ms</span></span>
<span class="line"><span style="color:#9ECBFF;">    P50: \${</span><span style="color:#9ECBFF;">(</span><span style="color:#E1E4E8;">histogram</span><span style="color:#9ECBFF;">.</span><span style="color:#B392F0;">percentile</span><span style="color:#9ECBFF;">(</span><span style="color:#79B8FF;">50</span><span style="color:#9ECBFF;">) </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 1000000</span><span style="color:#9ECBFF;">).</span><span style="color:#B392F0;">toFixed</span><span style="color:#9ECBFF;">(</span><span style="color:#79B8FF;">2</span><span style="color:#9ECBFF;">)</span><span style="color:#9ECBFF;">}ms</span></span>
<span class="line"><span style="color:#9ECBFF;">    P99: \${</span><span style="color:#9ECBFF;">(</span><span style="color:#E1E4E8;">histogram</span><span style="color:#9ECBFF;">.</span><span style="color:#B392F0;">percentile</span><span style="color:#9ECBFF;">(</span><span style="color:#79B8FF;">99</span><span style="color:#9ECBFF;">) </span><span style="color:#F97583;">/</span><span style="color:#79B8FF;"> 1000000</span><span style="color:#9ECBFF;">).</span><span style="color:#B392F0;">toFixed</span><span style="color:#9ECBFF;">(</span><span style="color:#79B8FF;">2</span><span style="color:#9ECBFF;">)</span><span style="color:#9ECBFF;">}ms</span></span>
<span class="line"><span style="color:#9ECBFF;">  \`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  histogram.</span><span style="color:#B392F0;">reset</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">5000</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><h3 id="检测事件循环阻塞" tabindex="-1">检测事件循环阻塞 <a class="header-anchor" href="#检测事件循环阻塞" aria-label="Permalink to &quot;检测事件循环阻塞&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> lastLoopTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Date.</span><span style="color:#B392F0;">now</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> checkEventLoop</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> now</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> Date.</span><span style="color:#B392F0;">now</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> loopDelay</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> now </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> lastLoopTime;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (loopDelay </span><span style="color:#F97583;">&gt;</span><span style="color:#79B8FF;"> 100</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">warn</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`事件循环延迟: \${</span><span style="color:#E1E4E8;">loopDelay</span><span style="color:#9ECBFF;">}ms\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  lastLoopTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> now;</span></span>
<span class="line"><span style="color:#B392F0;">  setImmediate</span><span style="color:#E1E4E8;">(checkEventLoop);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">checkEventLoop</span><span style="color:#E1E4E8;">();</span></span></code></pre></div><h2 id="事件循环最佳实践" tabindex="-1">事件循环最佳实践 <a class="header-anchor" href="#事件循环最佳实践" aria-label="Permalink to &quot;事件循环最佳实践&quot;">​</a></h2><h3 id="避免阻塞操作" tabindex="-1">避免阻塞操作 <a class="header-anchor" href="#避免阻塞操作" aria-label="Permalink to &quot;避免阻塞操作&quot;">​</a></h3><ul><li>将 CPU 密集型任务分解为小块</li><li>使用工作线程处理复杂计算</li><li>避免在主线程中进行大量同步操作</li></ul><h3 id="合理使用异步模式" tabindex="-1">合理使用异步模式 <a class="header-anchor" href="#合理使用异步模式" aria-label="Permalink to &quot;合理使用异步模式&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 好的实践 - 使用异步API</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> fs </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;fs/promises&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">async</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> readFiles</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> data</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> fs.</span><span style="color:#B392F0;">readFile</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;file.txt&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;utf8&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> data;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;读取文件失败:&#39;</span><span style="color:#E1E4E8;">, error);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 避免 - 使用同步API阻塞事件循环</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> readFilesSync</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">  try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> data</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> fs.</span><span style="color:#B392F0;">readFileSync</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;file.txt&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;utf8&#39;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 阻塞!</span></span>
<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> data;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;读取文件失败:&#39;</span><span style="color:#E1E4E8;">, error);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="合理设置定时器" tabindex="-1">合理设置定时器 <a class="header-anchor" href="#合理设置定时器" aria-label="Permalink to &quot;合理设置定时器&quot;">​</a></h3><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 避免设置大量短期定时器</span></span>
<span class="line"><span style="color:#6A737D;">// 不好的做法</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;"> 1000</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#B392F0;">  setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">    // 处理任务</span></span>
<span class="line"><span style="color:#E1E4E8;">  }, i </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> 10</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 好的做法 - 批量处理</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> processBatch</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">items</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">batchSize</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> 100</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> index </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#F97583;">  function</span><span style="color:#B392F0;"> processNextBatch</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> batch</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> items.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(index, index </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> batchSize);</span></span>
<span class="line"><span style="color:#E1E4E8;">    index </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> batchSize;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#6A737D;">    // 处理当前批次</span></span>
<span class="line"><span style="color:#E1E4E8;">    batch.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(processItem);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#F97583;">    if</span><span style="color:#E1E4E8;"> (index </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> items.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#B392F0;">      setImmediate</span><span style="color:#E1E4E8;">(processNextBatch);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#B392F0;">  processNextBatch</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>事件循环优化示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>优化前: 大量短期任务 → 频繁上下文切换 → 性能下降</span></span>
<span class="line"><span>优化后: 批次处理任务 → 减少切换次数 → 性能提升</span></span></code></pre></div>`,82)])])}const d=a(o,[["render",e]]);export{F as __pageData,d as default};
