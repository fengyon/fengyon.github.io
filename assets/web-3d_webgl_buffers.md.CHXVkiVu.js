import{_ as a,c as n,o as l,b as p}from"./chunks/framework.CMLuPXeo.js";const d=JSON.parse('{"title":"缓冲区与顶点","description":"","frontmatter":{},"headers":[{"level":2,"title":"缓冲区基础","slug":"缓冲区基础","link":"#缓冲区基础","children":[]},{"level":2,"title":"顶点数据结构","slug":"顶点数据结构","link":"#顶点数据结构","children":[]},{"level":2,"title":"缓冲区类型","slug":"缓冲区类型","link":"#缓冲区类型","children":[]},{"level":2,"title":"创建和初始化缓冲区","slug":"创建和初始化缓冲区","link":"#创建和初始化缓冲区","children":[]},{"level":2,"title":"顶点属性指针","slug":"顶点属性指针","link":"#顶点属性指针","children":[]},{"level":2,"title":"索引绘制","slug":"索引绘制","link":"#索引绘制","children":[]},{"level":2,"title":"顶点数组对象","slug":"顶点数组对象","link":"#顶点数组对象","children":[]},{"level":2,"title":"数据更新策略","slug":"数据更新策略","link":"#数据更新策略","children":[]},{"level":2,"title":"内存布局优化","slug":"内存布局优化","link":"#内存布局优化","children":[{"level":3,"title":"交错布局","slug":"交错布局","link":"#交错布局","children":[]},{"level":3,"title":"分离布局","slug":"分离布局","link":"#分离布局","children":[]}]},{"level":2,"title":"数据类型与精度","slug":"数据类型与精度","link":"#数据类型与精度","children":[]},{"level":2,"title":"实例化渲染","slug":"实例化渲染","link":"#实例化渲染","children":[]},{"level":2,"title":"性能考量","slug":"性能考量","link":"#性能考量","children":[]}],"relativePath":"web-3d/webgl/buffers.md","filePath":"web-3d/webgl/buffers.md"}'),e={name:"web-3d/webgl/buffers.md"};function o(t,s,c,i,r,E){return l(),n("div",null,[...s[0]||(s[0]=[p(`<div style="display:none;" hidden="true" aria-hidden="true">Are you an LLM? You can read better optimized documentation at /web-3d/webgl/buffers.md for this page in Markdown format</div><h1 id="缓冲区与顶点" tabindex="-1">缓冲区与顶点 <a class="header-anchor" href="#缓冲区与顶点" aria-label="Permalink to &quot;缓冲区与顶点&quot;">​</a></h1><p>缓冲区是 WebGL 中用于在 CPU 和 GPU 之间传递数据的核心机制，而顶点数据则是构建 3D 模型的基础。理解缓冲区的工作原理和顶点数据的组织方式对于高效 WebGL 编程至关重要。</p><h2 id="缓冲区基础" tabindex="-1">缓冲区基础 <a class="header-anchor" href="#缓冲区基础" aria-label="Permalink to &quot;缓冲区基础&quot;">​</a></h2><p>缓冲区是 GPU 内存中的一块连续区域，用于存储顶点数据、索引数据和其他几何信息。WebGL 通过缓冲区对象管理这些数据，实现 CPU 到 GPU 的高效数据传输。</p><p>特点：</p><ul><li>一次性上传数据，多次渲染使用</li><li>支持多种数据类型 (位置、颜色、法线、纹理坐标等)</li><li>硬件加速访问，优化渲染性能</li></ul><p>示意图 (缓冲区数据流)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>JavaScript数组 → 类型化数组 → WebGL缓冲区 → GPU显存</span></span>
<span class="line"><span>   [数据...]      Float32Array   gl.bufferData()   高速访问</span></span></code></pre></div><h2 id="顶点数据结构" tabindex="-1">顶点数据结构 <a class="header-anchor" href="#顶点数据结构" aria-label="Permalink to &quot;顶点数据结构&quot;">​</a></h2><p>顶点是 3D 模型的基本构造单元，每个顶点包含多个属性。合理组织顶点数据结构对内存效率和渲染性能有重要影响。</p><p>特点：</p><ul><li>每个顶点包含位置、法线、颜色、纹理坐标等属性</li><li>属性可以交错存储或分离存储</li><li>数据格式影响内存布局和访问速度</li></ul><p>顶点属性示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>单个顶点：</span></span>
<span class="line"><span>位置 (x,y,z) + 法线 (nx,ny,nz) + 纹理坐标 (u,v) + 颜色 (r,g,b,a)</span></span>
<span class="line"><span>    ↓             ↓                 ↓                 ↓</span></span>
<span class="line"><span> 3个float      3个float          2个float         4个float</span></span></code></pre></div><h2 id="缓冲区类型" tabindex="-1">缓冲区类型 <a class="header-anchor" href="#缓冲区类型" aria-label="Permalink to &quot;缓冲区类型&quot;">​</a></h2><p>WebGL 支持多种缓冲区类型，每种类型服务于不同的渲染需求。主要缓冲区类型包括数组缓冲区和元素数组缓冲区。</p><p>特点：</p><ul><li>ARRAY_BUFFER：存储顶点属性数据</li><li>ELEMENT_ARRAY_BUFFER：存储顶点索引数据</li><li>其他类型：变换反馈缓冲区、统一缓冲区 (WebGL 2)</li></ul><p>缓冲区类型示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>WebGL缓冲区</span></span>
<span class="line"><span>├── ARRAY_BUFFER (顶点属性)</span></span>
<span class="line"><span>│   ├── 位置数据</span></span>
<span class="line"><span>│   ├── 法线数据</span></span>
<span class="line"><span>│   ├── 颜色数据</span></span>
<span class="line"><span>│   └── 纹理坐标</span></span>
<span class="line"><span>└── ELEMENT_ARRAY_BUFFER (顶点索引)</span></span>
<span class="line"><span>    └── 三角形索引</span></span></code></pre></div><h2 id="创建和初始化缓冲区" tabindex="-1">创建和初始化缓冲区 <a class="header-anchor" href="#创建和初始化缓冲区" aria-label="Permalink to &quot;创建和初始化缓冲区&quot;">​</a></h2><p>缓冲区的创建和初始化涉及多个步骤，包括对象创建、数据上传和状态绑定。正确的初始化顺序确保数据可用性。</p><p>特点：</p><ul><li>缓冲区创建是轻量级操作</li><li>数据上传可能成为性能瓶颈</li><li>使用提示优化数据使用模式</li></ul><p>创建流程代码：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建缓冲区对象</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> buffer</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> gl.</span><span style="color:#B392F0;">createBuffer</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 绑定缓冲区类型</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">bindBuffer</span><span style="color:#E1E4E8;">(gl.</span><span style="color:#79B8FF;">ARRAY_BUFFER</span><span style="color:#E1E4E8;">, buffer);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 上传数据</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">bufferData</span><span style="color:#E1E4E8;">(gl.</span><span style="color:#79B8FF;">ARRAY_BUFFER</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> Float32Array</span><span style="color:#E1E4E8;">(vertexData), gl.</span><span style="color:#79B8FF;">STATIC_DRAW</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>数据使用提示：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>gl.STATIC_DRAW:  数据不常改变，适合静态几何</span></span>
<span class="line"><span>gl.DYNAMIC_DRAW: 数据经常改变，适合动态物体</span></span>
<span class="line"><span>gl.STREAM_DRAW:  数据每帧改变，适合粒子系统</span></span></code></pre></div><h2 id="顶点属性指针" tabindex="-1">顶点属性指针 <a class="header-anchor" href="#顶点属性指针" aria-label="Permalink to &quot;顶点属性指针&quot;">​</a></h2><p>顶点属性指针定义如何从缓冲区中提取顶点属性数据。它指定数据的偏移量、stride 和数据类型等参数。</p><p>特点：</p><ul><li>定义缓冲区数据的解释方式</li><li>支持交错数组和分离数组布局</li><li>必须与着色器中的 attribute 变量匹配</li></ul><p>vertexAttribPointer 参数：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>gl.vertexAttribPointer(位置, 分量数, 数据类型, 归一化, stride, 偏移量)</span></span>
<span class="line"><span>     ↓           ↓         ↓         ↓       ↓        ↓</span></span>
<span class="line"><span> attribute    size      type    normalized stride   offset</span></span></code></pre></div><p>数据布局示意图 (交错数组)：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>缓冲区内容：[x,y,z, r,g,b, x,y,z, r,g,b, ...]</span></span>
<span class="line"><span>            |------| |------| |------|</span></span>
<span class="line"><span>            顶点0     顶点1     顶点2</span></span>
<span class="line"><span>           位置+颜色  位置+颜色  位置+颜色</span></span>
<span class="line"><span></span></span>
<span class="line"><span>stride = 6 * 4字节 (6个float)</span></span>
<span class="line"><span>位置偏移 = 0</span></span>
<span class="line"><span>颜色偏移 = 3 * 4字节</span></span></code></pre></div><h2 id="索引绘制" tabindex="-1">索引绘制 <a class="header-anchor" href="#索引绘制" aria-label="Permalink to &quot;索引绘制&quot;">​</a></h2><p>索引绘制通过顶点索引重用顶点数据，减少内存占用和提高渲染效率。元素数组缓冲区存储这些索引。</p><p>特点：</p><ul><li>显著减少重复顶点数据</li><li>提高顶点缓存利用率</li><li>支持三角形带、扇形等优化图元</li></ul><p>索引绘制示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>顶点缓冲区：v0, v1, v2, v3, v4, v5</span></span>
<span class="line"><span>索引缓冲区：0, 1, 2, 2, 1, 3, ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>绘制三角形：(v0,v1,v2), (v2,v1,v3), ...</span></span>
<span class="line"><span>    v0-----v1</span></span>
<span class="line"><span>    | \\    |</span></span>
<span class="line"><span>    |  \\   |</span></span>
<span class="line"><span>    |   \\  |</span></span>
<span class="line"><span>    |    \\ |</span></span>
<span class="line"><span>    v2-----v3</span></span></code></pre></div><p>索引绘制代码：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建索引缓冲区</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> indexBuffer</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> gl.</span><span style="color:#B392F0;">createBuffer</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">bindBuffer</span><span style="color:#E1E4E8;">(gl.</span><span style="color:#79B8FF;">ELEMENT_ARRAY_BUFFER</span><span style="color:#E1E4E8;">, indexBuffer);</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">bufferData</span><span style="color:#E1E4E8;">(gl.</span><span style="color:#79B8FF;">ELEMENT_ARRAY_BUFFER</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> Uint16Array</span><span style="color:#E1E4E8;">(indices), gl.</span><span style="color:#79B8FF;">STATIC_DRAW</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用索引绘制</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">drawElements</span><span style="color:#E1E4E8;">(gl.</span><span style="color:#79B8FF;">TRIANGLES</span><span style="color:#E1E4E8;">, indexCount, gl.</span><span style="color:#79B8FF;">UNSIGNED_SHORT</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><h2 id="顶点数组对象" tabindex="-1">顶点数组对象 <a class="header-anchor" href="#顶点数组对象" aria-label="Permalink to &quot;顶点数组对象&quot;">​</a></h2><p>顶点数组对象 (VAO) 封装顶点属性状态，简化顶点设置过程。WebGL 2 原生支持，WebGL 1 可通过扩展使用。</p><p>特点：</p><ul><li>批量管理顶点属性状态</li><li>减少渲染时的 API 调用</li><li>提高复杂场景的渲染性能</li></ul><p>VAO 使用示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>VAO 绑定前：</span></span>
<span class="line"><span>设置位置属性 → 设置法线属性 → 设置颜色属性 → 绘制</span></span>
<span class="line"><span></span></span>
<span class="line"><span>VAO 绑定后：</span></span>
<span class="line"><span>绑定VAO（包含所有属性状态）→ 绘制</span></span></code></pre></div><p>VAO 管理代码：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 创建 VAO</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> vao</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> gl.</span><span style="color:#B392F0;">createVertexArray</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">bindVertexArray</span><span style="color:#E1E4E8;">(vao);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 设置顶点属性（状态被记录到 VAO 中）</span></span>
<span class="line"><span style="color:#B392F0;">setupVertexAttributes</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 渲染时只需绑定 VAO</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">bindVertexArray</span><span style="color:#E1E4E8;">(vao);</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">drawArrays</span><span style="color:#E1E4E8;">(gl.</span><span style="color:#79B8FF;">TRIANGLES</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, vertexCount);</span></span></code></pre></div><h2 id="数据更新策略" tabindex="-1">数据更新策略 <a class="header-anchor" href="#数据更新策略" aria-label="Permalink to &quot;数据更新策略&quot;">​</a></h2><p>根据数据变化的频率，采用不同的缓冲区更新策略。合理的选择对性能有显著影响。</p><p>特点：</p><ul><li>静态数据：一次性上传，不再修改</li><li>动态数据：周期性更新，平衡性能和灵活性</li><li>流式数据：每帧更新，特殊优化需求</li></ul><p>更新策略对比：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>静态几何：gl.bufferData(..., gl.STATIC_DRAW)</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>一次性上传，GPU高效访问</span></span>
<span class="line"><span></span></span>
<span class="line"><span>动态物体：gl.bufferData(..., gl.DYNAMIC_DRAW) 或 gl.bufferSubData()</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>定期更新，平衡CPU/GPU负载</span></span>
<span class="line"><span></span></span>
<span class="line"><span>粒子系统：gl.bufferData(..., gl.STREAM_DRAW)</span></span>
<span class="line"><span>    ↓</span></span>
<span class="line"><span>每帧更新，特殊优化路径</span></span></code></pre></div><p>动态更新代码：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 部分更新缓冲区数据</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">bufferSubData</span><span style="color:#E1E4E8;">(gl.</span><span style="color:#79B8FF;">ARRAY_BUFFER</span><span style="color:#E1E4E8;">, offset, </span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> Float32Array</span><span style="color:#E1E4E8;">(updatedData));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 或者重新创建缓冲区（避免内存碎片）</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">bufferData</span><span style="color:#E1E4E8;">(gl.</span><span style="color:#79B8FF;">ARRAY_BUFFER</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">new</span><span style="color:#B392F0;"> Float32Array</span><span style="color:#E1E4E8;">(newData), gl.</span><span style="color:#79B8FF;">DYNAMIC_DRAW</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><h2 id="内存布局优化" tabindex="-1">内存布局优化 <a class="header-anchor" href="#内存布局优化" aria-label="Permalink to &quot;内存布局优化&quot;">​</a></h2><p>顶点数据的内存布局影响缓存效率和渲染性能。主要布局方式包括交错布局和分离布局。</p><h3 id="交错布局" tabindex="-1">交错布局 <a class="header-anchor" href="#交错布局" aria-label="Permalink to &quot;交错布局&quot;">​</a></h3><p>所有顶点属性交错存储在单个缓冲区中。</p><p>特点：</p><ul><li>更好的缓存一致性</li><li>减少缓冲区绑定调用</li><li>内存访问模式优化</li></ul><p>交错布局示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>缓冲区：[P0,C0,N0, P1,C1,N1, P2,C2,N2, ...]</span></span>
<span class="line"><span>        |-------| |-------| |-------|</span></span>
<span class="line"><span>        顶点0     顶点1     顶点2</span></span>
<span class="line"><span>        P=位置, C=颜色, N=法线</span></span></code></pre></div><h3 id="分离布局" tabindex="-1">分离布局 <a class="header-anchor" href="#分离布局" aria-label="Permalink to &quot;分离布局&quot;">​</a></h3><p>每种顶点属性存储在独立的缓冲区中。</p><p>特点：</p><ul><li>灵活的属性更新</li><li>适合部分属性动态的场景</li><li>可能增加 API 调用开销</li></ul><p>分离布局示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>位置缓冲区：[P0, P1, P2, ...]</span></span>
<span class="line"><span>颜色缓冲区：[C0, C1, C2, ...]</span></span>
<span class="line"><span>法线缓冲区：[N0, N1, N2, ...]</span></span></code></pre></div><h2 id="数据类型与精度" tabindex="-1">数据类型与精度 <a class="header-anchor" href="#数据类型与精度" aria-label="Permalink to &quot;数据类型与精度&quot;">​</a></h2><p>选择适当的数值类型和精度平衡内存使用和渲染质量。WebGL 支持多种顶点数据类型。</p><p>常用数据类型：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>浮点类型：gl.FLOAT (32位) - 位置、法线等需要高精度</span></span>
<span class="line"><span>整型类型：gl.BYTE, gl.SHORT, gl.UNSIGNED_SHORT - 颜色、索引</span></span>
<span class="line"><span>归一化类型：gl.UNSIGNED_BYTE (归一化到 0-1) - 压缩颜色数据</span></span></code></pre></div><p>数据类型选择策略：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 位置数据：需要高精度</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">vertexAttribPointer</span><span style="color:#E1E4E8;">(positionLoc, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, gl.</span><span style="color:#79B8FF;">FLOAT</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, stride, offset);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 颜色数据：可以使用压缩格式</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">vertexAttribPointer</span><span style="color:#E1E4E8;">(colorLoc, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, gl.</span><span style="color:#79B8FF;">UNSIGNED_BYTE</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">, stride, offset);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 索引数据：根据顶点数量选择</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> indices</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> vertexCount </span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;"> 256</span><span style="color:#F97583;"> ?</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Uint8Array</span><span style="color:#E1E4E8;">(indices) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">               vertexCount </span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;"> 65536</span><span style="color:#F97583;"> ?</span><span style="color:#F97583;"> new</span><span style="color:#B392F0;"> Uint16Array</span><span style="color:#E1E4E8;">(indices) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#F97583;">                                     new</span><span style="color:#B392F0;"> Uint32Array</span><span style="color:#E1E4E8;">(indices);</span></span></code></pre></div><h2 id="实例化渲染" tabindex="-1">实例化渲染 <a class="header-anchor" href="#实例化渲染" aria-label="Permalink to &quot;实例化渲染&quot;">​</a></h2><p>实例化渲染允许使用单个绘制调用渲染多个相似对象，每个实例可以有不同的变换参数。这是高级优化技术。</p><p>特点：</p><ul><li>大幅减少绘制调用次数</li><li>通过实例属性区分不同实例</li><li>适合渲染大量相似对象 (树木、人群等)</li></ul><p>实例化示意图：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>单个模型 + 多个变换矩阵 → 实例化绘制 → 多个渲染实例</span></span>
<span class="line"><span>     ↓           ↓             ↓           ↓</span></span>
<span class="line"><span>  网格数据   位置/旋转/缩放    gl.drawArraysInstanced()  场景中多个物体</span></span></code></pre></div><p>实例化代码：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// 设置实例数据（如变换矩阵）</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">vertexAttribPointer</span><span style="color:#E1E4E8;">(instanceMatrixLoc, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, gl.</span><span style="color:#79B8FF;">FLOAT</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">vertexAttribPointer</span><span style="color:#E1E4E8;">(instanceMatrixLoc </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, gl.</span><span style="color:#79B8FF;">FLOAT</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">16</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">vertexAttribPointer</span><span style="color:#E1E4E8;">(instanceMatrixLoc </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, gl.</span><span style="color:#79B8FF;">FLOAT</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">32</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">vertexAttribPointer</span><span style="color:#E1E4E8;">(instanceMatrixLoc </span><span style="color:#F97583;">+</span><span style="color:#79B8FF;"> 3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, gl.</span><span style="color:#79B8FF;">FLOAT</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">64</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">48</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">vertexAttribDivisor</span><span style="color:#E1E4E8;">(instanceMatrixLoc, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 每实例更新</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 实例化绘制</span></span>
<span class="line"><span style="color:#E1E4E8;">gl.</span><span style="color:#B392F0;">drawArraysInstanced</span><span style="color:#E1E4E8;">(gl.</span><span style="color:#79B8FF;">TRIANGLES</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, vertexCount, instanceCount);</span></span></code></pre></div><h2 id="性能考量" tabindex="-1">性能考量 <a class="header-anchor" href="#性能考量" aria-label="Permalink to &quot;性能考量&quot;">​</a></h2><p>缓冲区使用中的性能优化涉及内存管理、数据更新策略和访问模式等多个方面。</p><p>性能优化要点：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>内存使用：选择合适的数值类型和精度</span></span>
<span class="line"><span>数据更新：根据变化频率选择更新策略</span></span>
<span class="line"><span>访问模式：优化内存布局提高缓存命中率</span></span>
<span class="line"><span>批处理：减少状态改变和绘制调用</span></span></code></pre></div><p>内存使用分析：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span>原始JavaScript数组 → 类型化数组 → GPU缓冲区</span></span>
<span class="line"><span>    [1,2,3,...]       Float32Array  显存分配</span></span>
<span class="line"><span>     灵活但低效        高效CPU访问   高效GPU访问</span></span>
<span class="line"><span>                     固定类型       对齐存储</span></span></code></pre></div>`,95)])])}const u=a(e,[["render",o]]);export{d as __pageData,u as default};
