---
url: /leading/webassembly/stack-vm-and-instructions.md
---
# WASM 栈式虚拟机与指令集

## 虚拟机架构概述

WebAssembly 采用基于栈的虚拟机设计，这种架构选择在代码密度和执行效率之间取得了精心平衡。与基于寄存器的虚拟机相比，栈式虚拟机使用更紧凑的指令编码，同时保持了良好的运行时性能。

**核心架构对比：**

```
基于寄存器的虚拟机:
指令: add r1, r2, r3
操作: 从指定寄存器读取操作数，结果写入目标寄存器

基于栈的虚拟机:  
指令: i32.const 5 → i32.const 3 → i32.add
操作: 操作数从栈顶弹出，结果压回栈顶
```

## 栈执行模型

### 操作数栈机制

操作数栈是 WASM 虚拟机的核心执行引擎，所有计算都通过栈操作完成。

**栈状态变迁示意图：**

```
初始栈状态: []
执行 i32.const 5: [5]
执行 i32.const 3: [5, 3]
执行 i32.add:    [8]        ; 弹出5和3，压入8
执行 i32.const 2: [8, 2]
执行 i32.mul:    [16]       ; 弹出8和2，压入16
```

### 栈帧管理

函数调用时创建新的栈帧，包含局部变量和返回地址等信息。

**栈帧布局：**

```
调用前栈: [参数N, ..., 参数1, 返回地址?]
调用后栈帧:
[局部变量M] ... [局部变量1] [参数N] ... [参数1] [返回地址]
    ↑
当前栈指针
```

## 指令集分类与编码

### 数值指令

数值指令操作基本数据类型，包括整数和浮点数的算术、比较、转换运算。

**整数运算指令示例：**

```
i32.add:  弹出两个i32，压入它们的和
i64.sub:  弹出两个i64，压入它们的差  
i32.mul:  弹出两个i32，压入它们的积
i32.div_s: 有符号除法
i32.div_u: 无符号除法
```

**位运算指令：**

```
i32.and:  按位与
i32.or:   按位或
i32.xor:  按位异或
i32.shl:  左移位
i32.shr_s: 算术右移位
i32.shr_u: 逻辑右移位
```

### 控制流指令

控制流指令实现结构化编程范式，确保代码的可验证性和安全性。

#### 块结构指令

```
block $label [结果类型]
    ... 指令序列 ...
end

loop $label [结果类型]  
    ... 循环体 ...
end

if $label [结果类型]
    ... 条件为真时执行 ...
else
    ... 条件为假时执行 ...  
end
```

**块执行流程：**

```
if 指令: 弹出条件值
    ↓
条件为真 → 执行 then 分支
条件为假 → 执行 else 分支 (如果有)
    ↓
分支出口栈高度必须匹配块声明的结果类型
```

#### 分支指令

```
br $label      ; 无条件跳转到指定标签
br_if $label   ; 条件跳转，弹出条件值
br_table [标签列表] $default ; 跳转表，弹出索引值
```

**br\_table 执行逻辑：**

```
弹出索引值 i
如果 i < 标签列表长度 → 跳转到 labels[i]
否则 → 跳转到 default 标签
```

### 内存访问指令

内存指令提供对线性内存的精细控制，支持多种数据类型和访问模式。

**加载指令格式：**

```
i32.load [offset=imm] [align=imm]
i64.load8_s [offset=imm] [align=imm]  
f32.load [offset=imm] [align=imm]
```

**存储指令格式：**

```
i32.store [offset=imm] [align=imm]
i64.store16 [offset=imm] [align=imm]
f64.store [offset=imm] [align=imm]
```

**内存访问语义：**

```
地址计算: base_address + offset
对齐要求: 访问必须在 2^align 字节边界上
边界检查: 运行时验证地址在内存有效范围内
```

### 变量访问指令

变量指令操作局部变量和全局变量，实现数据存储和检索。

**局部变量指令：**

```
local.get $index  ; 获取局部变量值压栈
local.set $index  ; 弹出值设置到局部变量  
local.tee $index  ; 弹出值设置变量并保留值在栈顶
```

**全局变量指令：**

```
global.get $index ; 获取全局变量值
global.set $index ; 设置全局变量值
```

**变量访问示意图：**

```
局部变量空间: [var0, var1, var2, ...]
全局变量空间: [global0, global1, ...]

执行 local.get 2: 读取 var2 值压栈
执行 global.set 0: 弹出栈顶值设置到 global0
```

## 函数调用机制

### 直接调用

```
call $func_index ; 直接调用函数
```

**调用过程：**

```
1. 压入返回地址
2. 为被调用函数创建新栈帧
3. 传递参数到新栈帧
4. 执行函数体
5. 返回时弹出结果，恢复调用者栈帧
```

### 间接调用

```
call_indirect $type_index ; 通过函数表间接调用
```

**间接调用验证：**

```
1. 弹出表索引和调用参数
2. 检查表索引有效性
3. 验证函数签名匹配 type_index
4. 执行动态调用
```

## 高级指令特性

### 多值操作

WebAssembly 支持多值返回，增强函数间数据传递能力。

**多值块示例：**

```
block (result i32 i32)
    i32.const 42
    i32.const 100
end

; 栈状态: [42, 100]
```

### 批量内存操作

内存初始化、复制和填充指令支持高效数据处理。

```
memory.init $segment ; 从数据段初始化内存
memory.copy          ; 内存区域复制  
memory.fill          ; 用指定值填充内存区域
```

**memory.copy 操作：**

```
参数: [dest, src, size]
效果: 将 src 开始的 size 字节复制到 dest
自动边界检查确保操作在有效内存范围内
```

## 指令编码优化

### 紧凑操作码设计

WASM 指令采用单字节或多字节操作码，常用指令使用短编码。

**操作码分布：**

```
0x00-0xBF: 核心指令 (数值运算、变量访问等)
0xC0-0xFF: 扩展指令 (SIMD、原子操作等)
```

### 立即数编码

立即数使用 LEB128 变长编码，实现空间效率优化。

**LEB128 编码示例：**

```
值: 127    → 编码: 0x7F
值: 128    → 编码: 0x80 0x01  
值: 624485 → 编码: 0xE5 0x8E 0x26
```

## 验证与安全

### 栈高度验证

在验证阶段检查所有执行路径的栈高度一致性。

**栈高度规则：**

* 块入口和出口栈高度必须匹配声明结果类型
* 分支目标栈高度必须一致
* 函数返回栈高度必须匹配签名

### 类型安全验证

所有指令操作数类型在验证阶段检查，确保运行时类型正确。

**类型检查示例：**

```
i32.add 指令:
期望栈顶: [i32, i32]
实际栈顶类型不匹配 → 验证失败
```

## 性能优化策略

### 栈操作优化

现代 WASM 运行时将栈操作映射到寄存器操作，减少实际内存访问。

**JIT 编译优化：**

```
WASM 栈操作 → 中间表示 → 寄存器分配 → 本地代码
    i32.add          %0 = add %1, %2
```

### 指令流水线

利用 CPU 流水线特性优化指令解码和执行。

**执行流水线：**

```
指令获取 → 解码 → 操作数准备 → 执行 → 结果写回
```

## 实际执行示例

### 完整函数执行跟踪

```
函数签名: (i32, i32) → i32
函数体:
local.get 0      ; 栈: [a]
local.get 1      ; 栈: [a, b]  
i32.add          ; 栈: [a+b]
i32.const 1      ; 栈: [a+b, 1]
i32.sub          ; 栈: [a+b-1]
end              ; 返回栈顶值
```

### 复杂控制流示例

```
block $outer (result i32)
    i32.const 0
    local.set $i
    
    loop $loop
        local.get $i
        i32.const 10
        i32.lt_s
        if
            local.get $i
            i32.const 1
            i32.add
            local.set $i
            br $loop
        else
            local.get $i
            br $outer
        end
    end
end
```

通过深入理解 WebAssembly 栈式虚拟机和指令集的设计原理，开发者能够编写出更高效、更安全的 WASM 代码，并更好地理解运行时行为和执行特征。
