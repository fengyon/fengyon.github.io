---
url: /engineering/architecture/monorep.md
---
# monorepo

monorepo (单体仓库) 是一种软件开发策略，将多个相关项目的代码存储在同一个版本控制仓库中。与传统的多仓库方式不同，monorepo 通过统一的仓库管理来优化代码共享、依赖管理和团队协作。

## 什么是 monorepo？

monorepo 是单个仓库中包含多个独立项目或包的代码管理方式，这些项目可以是应用、库、工具等，它们共享相同的版本控制历史、构建工具和开发流程。

```
多仓库 vs 单仓库:

多仓库 (Polyrepo):
[仓库A] - 项目A
[仓库B] - 项目B  
[仓库C] - 项目C
    |       |
独立版本  独立流水线

单仓库 (Monorepo):
[统一仓库]
    |
    +-- 项目A
    |
    +-- 项目B
    |
    +-- 项目C
    |
   共享工具和配置
```

## 核心架构模式

### 基本结构

monorepo 的典型目录组织结构。

```
monorepo/
├── apps/                 # 应用目录
│   ├── web-app/         # 网页应用
│   ├── mobile-app/      # 移动应用
│   └── admin/           # 管理后台
├── packages/            # 共享包
│   ├── ui-components/   # UI组件库
│   ├── utils/           # 工具函数
│   ├── config/          # 配置包
│   └── api/             # API客户端
├── tools/               # 开发工具
├── docs/                # 文档
└── 配置文件
    ├── package.json
    ├── turbo.json
    └── pnpm-workspace.yaml
```

### 工作空间概念

通过工作空间链接管理多个包的依赖关系。

```
工作空间依赖:
[应用A] -- 依赖 --> [共享组件库]
[应用B] -- 依赖 --> [共享组件库]
[应用C] -- 依赖 --> [工具包]
    |                  |
 直接引用           本地链接
    |                  |
 无需发布           实时同步
```

## 关键技术实现

### 包管理工具支持

现代包管理器对 monorepo 的原生支持。

```
工具对比:
- pnpm:    pnpm-workspace.yaml
- yarn:    workspaces (package.json)
- npm:     workspaces (package.json)

配置示例:
// package.json
{
  "workspaces": ["packages/*", "apps/*"]
}
```

### 构建工具集成

专用构建工具优化 monorepo 的构建性能。

```
构建工具:
Turborepo:  [依赖分析] -> [缓存优化] -> [并行构建]
        |          |           |           |
     快速构建    智能跳过    缓存复用    最大并发

Nx:        [项目图] -> [任务管道] -> [分布式执行]
        |        |           |           |
     影响分析   任务调度    优化执行    集群构建
```

## 依赖管理策略

### 内部依赖解析

monorepo 内部包之间的依赖关系管理。

```
内部依赖流程:
[包A] -- 依赖 --> [包B]
    |               |
 源码引用        本地符号链接
    |               |
 开发时实时更新   无需发布npm
```

### 版本管理策略

monorepo 中版本号的协同管理。

```
版本管理方式:
固定版本:   所有包使用相同版本号 (如: 1.0.0)
独立版本:   每个包独立版本号 (如: A@1.0.0, B@2.1.0)

发布流程:
[代码变更] -> [版本号更新] -> [依赖更新] -> [发布包]
     |             |             |           |
 功能开发      自动/手动      联动更新     批量发布
```

## 开发工作流

### 代码修改流程

在 monorepo 中进行功能开发和修改的典型流程。

```
开发流程:
[创建分支] -> [修改多个包] -> [本地测试] -> [提交PR] -> [CI验证] -> [合并]
     |           |             |           |          |           |
 功能分支     跨包变更       集成测试    代码审查    全量测试     主干发布
```

### 变更集管理

通过变更集工具管理版本发布。

```
变更集工作流:
[修改代码] -> [生成changeset] -> [版本规划] -> [发布包]
     |             |               |           |
 功能实现       描述变更影响      自动计算版本  批量发布
```

## 工具生态系统

### 主流工具栈

monorepo 开发的完整工具链。

```
工具栈分层:
[包管理器] -> [构建工具] -> [版本工具] -> [部署平台]
    |            |            |            |
 pnpm/yarn    Turborepo    Changesets    Vercel
    |            |            |            |
 依赖管理      任务调度      版本管理      部署发布
```

### 开发体验优化

提升 monorepo 开发效率的配套工具。

```
开发工具:
- 代码生成器:   快速创建新包模板
- 依赖可视化:   图形化展示包关系
- 影响分析:   识别变更的影响范围
- 任务运行器:   智能执行相关任务
```

## 实际应用场景

### 前端全栈应用

前后端项目在同一个仓库中管理。

```
全栈monorepo:
monorepo/
├── apps/
│   ├── frontend/     # 前端React应用
│   ├── backend/      # 后端Node.js服务
│   └── mobile/       # 移动端应用
├── packages/
│   ├── database/     # 数据库模型
│   ├── api-schema/   # API接口定义
│   └── shared/       # 前后端共享代码
└── 统一配置和脚本
```

### 组件库生态系统

UI 组件库及其相关生态项目。

```
组件库monorepo:
monorepo/
├── packages/
│   ├── core/         # 核心组件
│   ├── icons/        # 图标库
│   ├── themes/       # 主题系统
│   └── docs/         # 文档站点
├── examples/         # 使用示例
└── tools/           # 构建工具
```

### 微前端架构

微前端项目在 monorepo 中的组织方式。

```
微前端monorepo:
monorepo/
├── apps/
│   ├── shell/        # 基座应用
│   ├── micro-app-a/  # 微应用A
│   ├── micro-app-b/  # 微应用B
│   └── micro-app-c/  # 微应用C
├── packages/
│   ├── shared-utils/ # 共享工具
│   └── types/        # 类型定义
└── 统一构建部署配置
```

## 优势与挑战

### 核心优势

```
monorepo价值:
[代码共享] -> [统一工具链] -> [简化依赖] -> [更好的协作]
     |            |            |            |
 跨项目复用     一致的标准     内部包链接     全局可见性
```

### 具体收益

```
实际收益展示:
重构效率:    [跨包重构] -> 原子提交 -> 无破坏性变更
    |               |           |           |
 安全重构       一次性修改   完整提交   保证兼容性

开发体验:    [新成员] -> 单一仓库克隆 -> 快速上手
    |               |               |
 降低门槛       所有代码可用     统一开发环境
```

### 面临挑战

```
实施挑战:
[仓库规模] -> [构建性能] -> [权限控制] -> [工具复杂度]
     |            |            |            |
 巨型仓库       构建耗时       细粒度权限     学习成本
```

### 解决方案

```
应对策略:
- 分层结构:   按领域组织代码
- 增量构建:   只构建受影响部分  
- 代码分割:   按需加载模块
- 工具优化:   使用专用monorepo工具
```

## 规模化实践

### 大型 monorepo 策略

应对超大规模 monorepo 的技术方案。

```
规模化方案:
[代码分割] -> [分布式构建] -> [增量部署] -> [智能缓存]
     |            |            |            |
 模块化架构     并行编译     部分发布     构建缓存
```

### 企业级最佳实践

企业环境中 monorepo 的成功模式。

```
企业实践:
[代码所有权] -> [质量门禁] -> [自动化流水线] -> [监控告警]
     |            |            |            |
 明确责任       代码标准     持续集成     性能监控
```
