---
url: /basic/algorithm/complexity.md
---
# 复杂度分析

## 什么是复杂度分析

复杂度分析是评估算法效率的数学方法，用于预测算法在输入规模增长时资源消耗的变化趋势。它不依赖具体硬件和编程语言，而是关注算法内在的效能特性。

特点：

* 抽象性：忽略常数因子和低阶项，关注增长趋势
* 预测性：在算法实现前即可评估其 scalability
* 双重性：同时分析时间复杂度和空间复杂度

示意图：

```
输入规模n增大时：
高效算法：资源消耗缓慢增长 → ／
低效算法：资源消耗快速增长 → ＼
```

## 大 O 表示法

大 O 表示法描述算法复杂度的上界，表示最坏情况下的增长趋势。它捕捉算法性能的本质特征，忽略具体细节。

特点：

* 渐进性：只关心 n 趋近无穷大时的行为
* 简化性：去掉常数系数和低阶项
* 可比性：便于不同算法间的效率比较

示意图：

```
O(1):     ─────────  恒定不变
O(log n): ／          缓慢增长  
O(n):    ／│          线性增长
O(n²):   ／│││        平方增长
O(2ⁿ):   ／││││││││  指数爆炸
```

## 时间复杂度

时间复杂度度量算法运行时间随输入规模的增长关系。通过分析基本操作次数来估算，重点关注循环和递归结构。

特点：

* 操作计数：以基本操作 (比较、赋值等) 为单位
* 最坏情况：保证算法在任何输入下的性能下限
* 平均情况：反映算法在典型输入下的表现

示意图 (常见时间复杂度对比)：

```
n=10时：
O(1): 1步
O(log n): ~3步  
O(n): 10步
O(n log n): ~30步
O(n²): 100步
O(2ⁿ): 1024步
```

### 循环结构分析

单层循环的时间复杂度通常为 O(n)，嵌套循环为 O(n²)，但具体取决于循环条件和步长。

特点：

* 循环变量：分析索引 i 的变化模式
* 终止条件：确定循环执行次数
* 步长影响：i\*=2 产生 O(log n)

示意图 (不同循环模式)：

```
for(i=0; i<n; i++):     O(n)  → ││││││││
for(i=1; i<n; i*=2):    O(log n) → │ │ │
for(i=0; i<n; i++):     O(n²) → 每个│展开为n个小│
    for(j=0; j<n; j++)
```

### 递归算法分析

递归复杂度通过递推关系式求解，常用主定理或递归树方法。

特点：

* 递推方程：T(n) = aT(n/b) + f(n)
* 递归深度：影响空间复杂度
* 子问题数：决定时间复杂度

示意图 (递归树，以归并排序为例)：

```
        n
      /   \
    n/2   n/2
    / \   / \
  n/4 n/4 n/4 n/4
  ...直到叶子节点为1
每层工作量：n → n → n → ...
层数：log n
总工作量：O(n log n)
```

## 空间复杂度

空间复杂度度量算法执行所需内存空间随输入规模的增长关系，包括程序代码、变量、栈空间等。

特点：

* 固定部分：与输入无关的常量空间
* 可变部分：依赖输入规模的额外空间
* 原地算法：空间复杂度为 O(1)

示意图 (内存使用分布)：

```
[代码区][静态数据区][栈空间][堆空间]
        固定部分     ↑     可变部分
                递归深度  动态分配
```

### 递归空间分析

递归调用在栈中保存状态信息，空间复杂度与递归深度直接相关。

特点：

* 栈帧累积：每次递归调用创建新的栈帧
* 深度影响：最坏情况下可能达到 O(n)
* 尾递归优化：可减少栈空间使用

示意图 (递归调用栈)：

```
函数A(n)调用A(n-1)调用A(n-2)...调用A(1)
栈深度：n
栈内容：[A(n)状态][A(n-1)状态]...[A(1)状态]
```

## 常见复杂度类别

### 常数复杂度 O(1)

算法执行时间与输入规模无关，是最理想的复杂度。

特点：

* 无循环：操作次数固定
* 直接访问：如数组按索引访问
* 数学运算：基本算术操作

示例：

```python
def get_first_element(arr):
    return arr[0]  # 无论arr多大，都只需一步
```

### 对数复杂度 O(log n)

算法每步将问题规模减小固定比例，常见于分治算法。

特点：

* 问题折半：每次减少一半搜索空间
* 指数逆运算：log₂n 是 2ⁿ 的反函数
* 高效搜索：在有序数据中快速定位

示意图 (二分搜索)：

```
搜索空间: n → n/2 → n/4 → ... → 1
步骤数: log₂n
如n=16: 16→8→4→2→1 (4步)
```

### 线性复杂度 O(n)

算法执行时间与输入规模成正比，需要遍历整个输入。

特点：

* 单次遍历：从头到尾处理每个元素
* 比例关系：输入翻倍，时间翻倍
* 基础操作：如查找最大值、求和

示意图：

```
处理数组: [×][×][×][×][×][×][×][×]
每个×需要固定时间c，总时间c×n
```

### 线性对数复杂度 O(n log n)

结合线性和对数特性，常见于高效排序算法。

特点：

* 分层处理：每层 O(n) 工作，共 O(log n) 层
* 最优比较排序：基于比较的排序算法下限
* 分治策略：如归并排序、快速排序

示意图 (归并排序工作模式)：

```
分层:    [n个元素]
        [n/2][n/2]      ← 每层合并工作量O(n)
        [n/4][n/4][n/4][n/4]
        ...共log n层
总工作量: n × log n
```

### 平方复杂度 O(n²)

通常源于嵌套循环，输入规模微小增加导致时间显著增长。

特点：

* 成对比较：每个元素与其他所有元素交互
* 效率低下：大规模数据时性能急剧下降
* 简单算法：如冒泡排序、选择排序

示意图 (嵌套循环访问模式)：

```
i=0: j=0,1,2,...,n-1
i=1: j=0,1,2,...,n-1
...
i=n-1: j=0,1,2,...,n-1
总访问次数: n × n = n²
```

### 指数复杂度 O(2ⁿ)

问题规模轻微增加导致运行时间翻倍，仅适用于极小规模问题。

特点：

* 组合爆炸：处理所有子集或排列
* 暴力搜索：穷举所有可能解
* 实际限制：n>30时通常不可行

示意图 (子集生成)：

```
n=3时子集: {},{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}
数量: 2³ = 8
n每增加1，子集数翻倍
```

## 复杂度计算规则

### 加法规则

顺序执行多个算法时，总复杂度由最高阶项决定。

特点：

* 取最大值：O(f(n)) + O(g(n)) = O(max(f(n)，g(n)))
* 忽略低阶：n² + n = O(n²)
* 关注主导：增长最快的项决定整体行为

示例：

```python
# O(n) + O(n²) = O(n²)
for i in range(n):        # O(n)
    print(i)
for i in range(n):        # O(n²)  
    for j in range(n):
        print(i, j)
```

### 乘法规则

嵌套执行算法时，复杂度为各层复杂度的乘积。

特点：

* 逐层相乘：O(f(n)) × O(g(n)) = O(f(n) × g(n))
* 循环嵌套：外层循环次数乘以内层循环次数
* 递归调用：递归次数乘以每次递归的工作量

示例：

```python
# O(n) × O(n) = O(n²)
for i in range(n):        # O(n)次
    for j in range(n):    # 每次O(n)
        print(i, j)
```

### 其他规则

多项式复杂度保留最高次项，对数复杂度忽略底数。

特点：

* 多项式简化：O(3n³ + 2n² + 10n + 5) = O(n³)
* 对数底转换：O(log₂n) = O(log₃n) = O(log n)
* 常数忽略：O(2n) = O(n)，O(500) = O(1)

## 实际应用技巧

### 代码分析步骤

从内到外分析代码，识别循环和递归结构。

分析流程：

```
1. 识别基本操作（最内层语句）
2. 计算每层循环执行次数
3. 应用乘法和加法规则
4. 简化表达式，保留主导项
```

示例分析：

```python
def example(n):
    sum = 0
    # 外层循环：O(n)
    for i in range(n):
        # 内层循环：O(log n)  
        j = 1
        while j < n:
            sum += i + j
            j *= 2
    return sum
# 总复杂度：O(n) × O(log n) = O(n log n)
```

### 复杂度优化策略

根据瓶颈分析，选择合适的数据结构和算法。

优化方向：

* 时间换空间：缓存计算结果
* 空间换时间：使用辅助数据结构
* 算法升级：从 O(n²) 优化到 O(n log n)

示意图 (优化路径)：

```
原始: O(n³) → 优化循环: O(n²) → 使用哈希: O(n) → 数学优化: O(1)
每一步都可能大幅提升性能
```
