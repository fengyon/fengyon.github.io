---
url: /special/mobile/publish/hot-update.md
---
# 热更新

## 热更新概述

热更新是一种允许应用程序在运行时进行更新的技术。它通过动态替换应用程序的部分代码或资源来实现更新，而无需重新安装整个应用程序。这种技术已经成为移动开发中的重要工具，帮助开发者在用户无感知的情况下修复 BUG 和发布新功能。

热更新与传统应用商店更新形成鲜明对比：

```
传统更新: [应用商店下载] -> [用户手动安装] -> [重启应用] -> [更新完成]
热更新:   [检测更新] -> [下载补丁] -> [动态替换] -> [立即生效]
```

核心特点包括：

* **动态性**：在应用程序运行时动态加载和替换代码
* **无感知**：用户无需重新下载安装整个应用
* **敏捷性**：绕过应用商店审核流程，快速迭代
* **精准性**：可针对不同用户群体或地区发布不同的更新

## 技术方案

移动端热更新技术主要分为两大类方案，各有其特点与适用场景。

### 原生方案

原生热更新方案直接针对平台特性设计，性能高效但实现复杂。

**Android 方案**：

* **Tinker**：微信团队推出的方案，采用 Dex 差分合并技术

```
[旧APK] --[差分]--> [Patch文件] --[合并]--> [新APK]
```

特点：稳定性高，但需要重启应用

* **Robust**：美团推出的即时更新方案
  原理：为每个方法自动插入代理逻辑

```
public long getIndex() {
    if(changeQuickRedirect != null) {
        // 执行补丁逻辑
    }
    return 100L; // 原逻辑
}
```

特点：兼容性好，实时生效，但会增加方法数

**iOS 方案**：

* **JSPatch**：使用 JavaScript 调用 iOS 原生接口
  特点：符合 Apple 审核原则，群众基础广泛

### 混合方案

混合方案基于 Web 技术，开发效率高但性能略有损耗。

**HTML5 方案**：

```
[Web资源] -> [下载更新] -> [替换缓存] -> [立即生效]
```

特点：跨平台支持，简单易用，但性能较差

**小程序容器**：
如 FinClip SDK，将小程序运行时嵌入原生应用

```
[原生应用] + [小程序容器] -> [加载小程序] -> [热更新业务模块]
```

特点：体验接近原生，安全沙箱隔离

## 工作原理

热更新系统的核心技术流程涉及客户端与服务端的协同工作。

### 核心流程

典型的热更新过程包含以下几个阶段：

1. **更新检测**：应用启动时或定期检查服务器是否有更新

```
[应用启动] -> [请求服务器] -> [版本比对] -> [判断是否需要更新]
```

2. **补丁下载**：从服务器获取差异化的更新包

```
[全量更新] : 下载完整新版本
[增量更新] : 仅下载变更部分，节省流量
```

3. **验证合并**：校验补丁完整性并合并到应用中

```
[签名验证] -> [完整性检查] -> [安全合并]
```

4. **动态加载**：使用类加载机制替换原有代码

```
[DexClassLoader] (Android)
[JSContext] (iOS JSPatch)
```

### Webpack HMR 原理

Webpack 的热模块替换是现代前端开发中的重要技术。

```
[文件修改] -> [Webpack检测] -> [编译补丁] -> [WS推送] -> [浏览器替换]
```

详细流程：

1. 文件系统监听文件变化
2. Webpack 编译生成两个补丁文件：
   * `manifest` (JSON)：描述变化的模块
   * `updated chunk` (JS)：包含实现代码
3. 通过 WebSocket 推送到浏览器
4. HMR Runtime 接收并应用更新

### 资源更新机制

除了代码更新，资源文件也有不同的更新策略：

* **增量更新**：只更新变化的资源文件
  优点：速度快，流量小
  缺点：需要维护版本管理
* **全量更新**：替换所有资源文件
  优点：管理简单
  缺点：速度慢，流量大

## 实现要点

实现一个稳定可靠的热更新系统需要关注多个技术细节。

### 客户端实现

客户端需要具备更新检测、下载和安全验证能力。

**更新检测策略**：

```javascript
// 示例：检测更新时机
function checkUpdate() {
    // 启动时检测
    appLaunch → checkVersion()

    // 定时检测
    setInterval(checkVersion, 24 * 60 * 60 * 1000)

    // 用户手动触发
    settingsPage → manualCheck()
}
```

**下载与验证**：

* 断点续传支持
* 文件完整性校验 (MD5/SHA1)
* 数字签名验证

### 服务端管理

服务端需要支持精准的更新发布控制。

**灰度发布策略**：

```
[内部测试] -> [5%用户] -> [20%用户] -> [全量发布]
```

可根据设备类型、版本、用户标签等进行精准控制

**版本管理**：

* 补丁版本兼容性检查
* 多版本支持与回滚机制
* 更新策略配置化

### 安全与稳定性

热更新引入的安全风险需要特别关注。

**安全措施**：

* 补丁签名机制，防止篡改
* 传输加密，避免中间人攻击
* 代码混淆，增加反编译难度

**稳定性保障**：

* 补丁兼容性测试
* 回滚机制，更新失败时恢复
* 性能监控，确保更新后应用稳定

## 适用场景

热更新技术在不同场景下发挥独特价值。

### 业务场景

* **紧急 Bug 修复**：绕过商店审核，快速修复线上问题
* **AB 测试**：同一批用户可测试不同方案
* **活动运营**：快速上线临时活动页面
* **渐进式发布**：逐步放开新功能，降低风险

### 技术场景

* **基础库更新**：修复安全漏洞，更新工具库
* **UI 调整**：修改界面样式和交互逻辑
* **业务逻辑变更**：调整业务流程和规则
* **资源更新**：更新图片、文案等静态资源

### 限制与约束

热更新并非万能，有其使用边界：

* iOS 对热更新有严格限制，可能违反审核协议
* 结构性变更无法通过热更新实现
* 性能敏感场景需谨慎使用
* 二进制代码更新受平台限制
