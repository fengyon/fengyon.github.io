---
url: /full-stack/network/udp.md
---
# UDP

## 介绍

UDP (User Datagram Protocol) 是一种无连接的传输层协议，提供简单的、不可靠的数据报服务。与 TCP 的可靠传输不同，UDP 专注于最小化的协议机制，为应用程序提供低开销、低延迟的通信能力。UDP 不保证数据交付、不保证顺序、不提供拥塞控制，将可靠性责任完全交给应用层。

## 历史

UDP 源于 1980 年的 RFC 768，由 David P。Reed 设计。作为 TCP/IP 协议套件的重要组成部分，UDP 与 TCP 形成互补。早期主要用于 DNS 查询、路由信息协议等简单应用。随着实时多媒体应用的发展，UDP 的重要性日益凸显。在视频会议、在线游戏、流媒体等场景中，UDP 的低延迟特性使其成为不可替代的选择。

## 协议概述

UDP 位于 TCP/IP 模型的传输层，直接基于 IP 协议工作：

```
应用层数据
↓
UDP头部封装
↓
IP数据包
↓
网络传输
```

UDP 在协议栈中的位置与 TCP 平行，为应用提供另一种传输选择。

## 核心特点

### 无连接通信

UDP 不需要预先建立连接，每个数据报独立处理。

```
客户端: [数据报1] -> 服务器
客户端: [数据报2] -> 服务器
客户端: [数据报3] -> 服务器
```

与 TCP 对比：

```
TCP: 握手 -> 数据传输 -> 挥手
UDP: 直接发送数据报
```

优势：减少延迟、降低开销。

### 不可靠传输

UDP 不保证数据交付，数据报可能丢失、重复、乱序。

```
发送: 包1, 包2, 包3, 包4
接收: 包1, 包3, 包4 (包2丢失)
```

应用层需要自行处理丢包和乱序问题。

### 无拥塞控制

UDP 不包含拥塞避免机制，可能加剧网络拥塞。

```
UDP流: 持续高速发送 -> 可能造成网络拥堵
TCP流: 根据拥塞窗口调整速率 -> 相对友好
```

需要应用层实现适当的速率控制。

### 消息边界保留

UDP 保留应用层消息边界，每个数据报独立交付。

```
发送: "Hello" + "World"
接收: "Hello", "World" (两个独立数据报)
```

与 TCP 的字节流对比：

```
TCP发送: "Hello" + "World"
TCP接收: "HelloWorld" (可能合并)
```

### 轻量级头部

UDP 头部固定 8 字节，远小于 TCP 的 20-60 字节头部。

```
UDP头部: [源端口|目的端口|长度|校验和]
TCP头部: [更多字段包括序列号、确认号、窗口等]
```

减少协议开销，提高传输效率。

### 支持广播和多播

UDP 支持一对一、一对多、多对多通信模式。

```
单播:   客户端A -> 服务器
广播:   服务器 -> 所有客户端
多播:   服务器 -> 组成员
```

适用于群组通信场景。

## 工作原理

### 数据报封装

应用数据添加 UDP 头部形成 UDP 数据报，再封装为 IP 数据包。

```
[应用数据]
↓ 添加UDP头部
[UDP头][应用数据] (UDP数据报)
↓ 添加IP头部
[IP头][UDP头][应用数据] (IP数据包)
```

### 端口机制

UDP 使用端口号标识应用进程，实现多路复用。

```
客户端端口1234 -> 服务器端口53 (DNS)
客户端端口1235 -> 服务器端口80 (HTTP后端)
```

同一 IP 地址可运行多个 UDP 服务。

### 校验和计算

UDP 提供可选的校验和机制，检测数据 corruption。

```
计算: 伪头部 + UDP头部 + 数据 -> 16位反码求和
验证: 接收方重新计算，不匹配则静默丢弃
```

## 头部格式

UDP 头部简洁明了，包含四个 16 位字段：

```
 0       16       32       48
+--------+--------+--------+--------+
|   源端口   |     目的端口    |
+--------+--------+--------+--------+
|     长度     |     校验和     |
+--------+--------+--------+--------+
|            应用数据              |
+----------------------------------+
```

字段说明：

* 源端口：发送方端口号 (可选，0 表示无)
* 目的端口：接收方端口号
* 长度：UDP 头部和数据的总长度 (字节)
* 校验和：头部和数据的错误检测码

## 适用场景

### 实时多媒体传输

视频会议、VoIP 等应用能容忍少量丢包，但不能接受 TCP 重传延迟。

```
视频帧1 [丢失] 视频帧2 [到达] 视频帧3 [到达]
处理: 跳过帧1，继续播放帧2、帧3
```

### 查询-响应协议

DNS、DHCP 等简单查询，单个请求响应对。

```
客户端: [DNS查询] -> 服务器
客户端: [DNS响应] <- 服务器
超时则重试
```

### 在线游戏

游戏状态更新需要低延迟，偶尔丢包可接受。

```
玩家位置更新: 高频发送，最新状态覆盖旧状态
丢包影响: 短暂卡顿，但很快恢复
```

### 流媒体广播

音视频流媒体，消费者能容忍少量数据丢失。

```
音频流: [包1][包2][丢失][包4]...
处理: 使用插值掩盖丢失数据
```

### 网络监控

大量设备状态报告，个别丢失不影响整体统计。

```
设备1: [状态] -> 监控服务器
设备2: [状态] [丢失]
设备3: [状态] -> 监控服务器
```

## 与 TCP 对比

### 特性对比

```
可靠性:    TCP - 有, UDP - 无
连接性:    TCP - 面向连接, UDP - 无连接
有序性:    TCP - 保证顺序, UDP - 不保证
速度:      TCP - 较慢, UDP - 较快
开销:      TCP - 较高, UDP - 较低
控制:      TCP - 拥塞控制, UDP - 无控制
```

### 选择指南

```
选择TCP当: 需要可靠交付、数据完整性关键、能容忍延迟
选择UDP当: 延迟敏感、能容忍丢包、需要多播、简单查询
```

## 应用层可靠性

在 UDP 基础上实现可靠性的常见模式：

### 确认与重传

```
发送: 序列号N -> 接收方
接收: 确认N -> 发送方
超时未确认 -> 重传序列号N
```

### 前向纠错

添加冗余数据，在丢包时恢复信息。

```
原始: 数据1, 数据2, 数据3
发送: 数据1, 数据2, 数据3, 奇偶校验包
丢失数据2 -> 通过数据1、数据3、奇偶校验包恢复
```

### 质量反馈

接收方向发送方报告网络状况，动态调整。

```
接收方: 报告丢包率20% -> 发送方降低速率
接收方: 报告丢包率5% -> 发送方保持或提高速率
```

## 安全考虑

### 固有漏洞

* 无连接性易受洪水攻击
* 源地址易伪造
* 无拥塞控制可能加剧 DDoS

### 防护措施

* 实施速率限制
* 验证数据包真实性
* 使用 DTLS (UDP 的 TLS 版本) 加密
